{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java", "func_name": "QueueDrainObserver.fastPathOrderedEmit", "original_string": "protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {\n        final Observer<? super V> observer = downstream;\n        final SimplePlainQueue<U> q = queue;\n\n        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {\n            if (q.isEmpty()) {\n                accept(observer, value);\n                if (leave(-1) == 0) {\n                    return;\n                }\n            } else {\n                q.offer(value);\n            }\n        } else {\n            q.offer(value);\n            if (!enter()) {\n                return;\n            }\n        }\n        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);\n    }", "language": "java", "code": "protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {\n        final Observer<? super V> observer = downstream;\n        final SimplePlainQueue<U> q = queue;\n\n        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {\n            if (q.isEmpty()) {\n                accept(observer, value);\n                if (leave(-1) == 0) {\n                    return;\n                }\n            } else {\n                q.offer(value);\n            }\n        } else {\n            q.offer(value);\n            if (!enter()) {\n                return;\n            }\n        }\n        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);\n    }", "code_tokens": ["protected", "final", "void", "fastPathOrderedEmit", "(", "U", "value", ",", "boolean", "delayError", ",", "Disposable", "disposable", ")", "{", "final", "Observer", "<", "?", "super", "V", ">", "observer", "=", "downstream", ";", "final", "SimplePlainQueue", "<", "U", ">", "q", "=", "queue", ";", "if", "(", "wip", ".", "get", "(", ")", "==", "0", "&&", "wip", ".", "compareAndSet", "(", "0", ",", "1", ")", ")", "{", "if", "(", "q", ".", "isEmpty", "(", ")", ")", "{", "accept", "(", "observer", ",", "value", ")", ";", "if", "(", "leave", "(", "-", "1", ")", "==", "0", ")", "{", "return", ";", "}", "}", "else", "{", "q", ".", "offer", "(", "value", ")", ";", "}", "}", "else", "{", "q", ".", "offer", "(", "value", ")", ";", "if", "(", "!", "enter", "(", ")", ")", "{", "return", ";", "}", "}", "QueueDrainHelper", ".", "drainLoop", "(", "q", ",", "observer", ",", "delayError", ",", "disposable", ",", "this", ")", ";", "}"], "docstring": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "docstring_tokens": ["Makes", "sure", "the", "fast", "-", "path", "emits", "in", "order", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java#L88-L108", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Observable.java", "func_name": "Observable.wrap", "original_string": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> wrap(ObservableSource<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        if (source instanceof Observable) {\n            return RxJavaPlugins.onAssembly((Observable<T>)source);\n        }\n        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));\n    }", "language": "java", "code": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> wrap(ObservableSource<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        if (source instanceof Observable) {\n            return RxJavaPlugins.onAssembly((Observable<T>)source);\n        }\n        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Observable", "<", "T", ">", "wrap", "(", "ObservableSource", "<", "T", ">", "source", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "source", ",", "\"source is null\"", ")", ";", "if", "(", "source", "instanceof", "Observable", ")", "{", "return", "RxJavaPlugins", ".", "onAssembly", "(", "(", "Observable", "<", "T", ">", ")", "source", ")", ";", "}", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "ObservableFromUnsafeSource", "<", "T", ">", "(", "source", ")", ")", ";", "}"], "docstring": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code wrap} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <T> the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "docstring_tokens": ["Wraps", "an", "ObservableSource", "into", "an", "Observable", "if", "not", "already", "an", "Observable", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Observable.java", "func_name": "Observable.sorted", "original_string": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Observable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\");\n        return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "language": "java", "code": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Observable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\");\n        return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Observable", "<", "T", ">", "sorted", "(", "Comparator", "<", "?", "super", "T", ">", "sortFunction", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sortFunction", ",", "\"sortFunction is null\"", ")", ";", "return", "toList", "(", ")", ".", "toObservable", "(", ")", ".", "map", "(", "Functions", ".", "listSorter", "(", "sortFunction", ")", ")", ".", "flatMapIterable", "(", "Functions", ".", "<", "List", "<", "T", ">", ">", "identity", "(", ")", ")", ";", "}"], "docstring": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\n<p>Note that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "docstring_tokens": ["Returns", "an", "Observable", "that", "emits", "the", "events", "emitted", "by", "source", "ObservableSource", "in", "a", "sorted", "order", "based", "on", "a", "specified", "comparison", "function", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L12008-L12013", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java", "func_name": "ObservableReplay.observeOn", "original_string": "public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {\n        final Observable<T> observable = co.observeOn(scheduler);\n        return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));\n    }", "language": "java", "code": "public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {\n        final Observable<T> observable = co.observeOn(scheduler);\n        return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));\n    }", "code_tokens": ["public", "static", "<", "T", ">", "ConnectableObservable", "<", "T", ">", "observeOn", "(", "final", "ConnectableObservable", "<", "T", ">", "co", ",", "final", "Scheduler", "scheduler", ")", "{", "final", "Observable", "<", "T", ">", "observable", "=", "co", ".", "observeOn", "(", "scheduler", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "Replay", "<", "T", ">", "(", "co", ",", "observable", ")", ")", ";", "}"], "docstring": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param <T> the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "docstring_tokens": ["Child", "Observers", "will", "observe", "the", "events", "of", "the", "ConnectableObservable", "on", "the", "specified", "scheduler", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java#L74-L77", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/UnicastProcessor.java", "func_name": "UnicastProcessor.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint) {\n        return new UnicastProcessor<T>(capacityHint);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint) {\n        return new UnicastProcessor<T>(capacityHint);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastProcessor", "<", "T", ">", "create", "(", "int", "capacityHint", ")", "{", "return", "new", "UnicastProcessor", "<", "T", ">", "(", "capacityHint", ")", ";", "}"], "docstring": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "docstring_tokens": ["Creates", "an", "UnicastProcessor", "with", "the", "given", "internal", "buffer", "capacity", "hint", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/UnicastProcessor.java#L192-L196", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/UnicastProcessor.java", "func_name": "UnicastProcessor.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {\n        ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\n        return new UnicastProcessor<T>(capacityHint, onCancelled);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {\n        ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\n        return new UnicastProcessor<T>(capacityHint, onCancelled);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastProcessor", "<", "T", ">", "create", "(", "int", "capacityHint", ",", "Runnable", "onCancelled", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "onCancelled", ",", "\"onTerminate\"", ")", ";", "return", "new", "UnicastProcessor", "<", "T", ">", "(", "capacityHint", ",", "onCancelled", ")", ";", "}"], "docstring": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "docstring_tokens": ["Creates", "an", "UnicastProcessor", "with", "the", "given", "internal", "buffer", "capacity", "hint", "and", "a", "callback", "for", "the", "case", "when", "the", "single", "Subscriber", "cancels", "its", "subscription", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/UnicastProcessor.java#L224-L229", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java", "func_name": "FlowableScalarXMap.tryScalarXMapSubscribe", "original_string": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,\n            Subscriber<? super R> subscriber,\n            Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (t == null) {\n                EmptySubscription.complete(subscriber);\n                return true;\n            }\n\n            Publisher<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptySubscription.error(ex, subscriber);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptySubscription.complete(subscriber);\n                    return true;\n                }\n                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));\n            } else {\n                r.subscribe(subscriber);\n            }\n\n            return true;\n        }\n        return false;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,\n            Subscriber<? super R> subscriber,\n            Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (t == null) {\n                EmptySubscription.complete(subscriber);\n                return true;\n            }\n\n            Publisher<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptySubscription.error(ex, subscriber);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptySubscription.complete(subscriber);\n                    return true;\n                }\n                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));\n            } else {\n                r.subscribe(subscriber);\n            }\n\n            return true;\n        }\n        return false;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "<", "T", ",", "R", ">", "boolean", "tryScalarXMapSubscribe", "(", "Publisher", "<", "T", ">", "source", ",", "Subscriber", "<", "?", "super", "R", ">", "subscriber", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "Publisher", "<", "?", "extends", "R", ">", ">", "mapper", ")", "{", "if", "(", "source", "instanceof", "Callable", ")", "{", "T", "t", ";", "try", "{", "t", "=", "(", "(", "Callable", "<", "T", ">", ")", "source", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "t", "==", "null", ")", "{", "EmptySubscription", ".", "complete", "(", "subscriber", ")", ";", "return", "true", ";", "}", "Publisher", "<", "?", "extends", "R", ">", "r", ";", "try", "{", "r", "=", "ObjectHelper", ".", "requireNonNull", "(", "mapper", ".", "apply", "(", "t", ")", ",", "\"The mapper returned a null Publisher\"", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "r", "instanceof", "Callable", ")", "{", "R", "u", ";", "try", "{", "u", "=", "(", "(", "Callable", "<", "R", ">", ")", "r", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "u", "==", "null", ")", "{", "EmptySubscription", ".", "complete", "(", "subscriber", ")", ";", "return", "true", ";", "}", "subscriber", ".", "onSubscribe", "(", "new", "ScalarSubscription", "<", "R", ">", "(", "subscriber", ",", "u", ")", ")", ";", "}", "else", "{", "r", ".", "subscribe", "(", "subscriber", ")", ";", "}", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param <T> the input value type\n@param <R> the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "docstring_tokens": ["Tries", "to", "subscribe", "to", "a", "possibly", "Callable", "source", "s", "mapped", "Publisher", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java#L46-L99", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java", "func_name": "FlowableScalarXMap.scalarXMap", "original_string": "public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));\n    }", "language": "java", "code": "public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "Flowable", "<", "U", ">", "scalarXMap", "(", "final", "T", "value", ",", "final", "Function", "<", "?", "super", "T", ",", "?", "extends", "Publisher", "<", "?", "extends", "U", ">", ">", "mapper", ")", "{", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "ScalarXMapFlowable", "<", "T", ",", "U", ">", "(", "value", ",", "mapper", ")", ")", ";", "}"], "docstring": "Maps a scalar value into a Publisher and emits its values.\n\n@param <T> the scalar value type\n@param <U> the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "docstring_tokens": ["Maps", "a", "scalar", "value", "into", "a", "Publisher", "and", "emits", "its", "values", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java#L111-L113", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/plugins/RxJavaPlugins.java", "func_name": "RxJavaPlugins.reset", "original_string": "public static void reset() {\n        setErrorHandler(null);\n        setScheduleHandler(null);\n\n        setComputationSchedulerHandler(null);\n        setInitComputationSchedulerHandler(null);\n\n        setIoSchedulerHandler(null);\n        setInitIoSchedulerHandler(null);\n\n        setSingleSchedulerHandler(null);\n        setInitSingleSchedulerHandler(null);\n\n        setNewThreadSchedulerHandler(null);\n        setInitNewThreadSchedulerHandler(null);\n\n        setOnFlowableAssembly(null);\n        setOnFlowableSubscribe(null);\n\n        setOnObservableAssembly(null);\n        setOnObservableSubscribe(null);\n\n        setOnSingleAssembly(null);\n        setOnSingleSubscribe(null);\n\n        setOnCompletableAssembly(null);\n        setOnCompletableSubscribe(null);\n\n        setOnConnectableFlowableAssembly(null);\n        setOnConnectableObservableAssembly(null);\n\n        setOnMaybeAssembly(null);\n        setOnMaybeSubscribe(null);\n\n        setOnParallelAssembly(null);\n\n        setFailOnNonBlockingScheduler(false);\n        setOnBeforeBlocking(null);\n    }", "language": "java", "code": "public static void reset() {\n        setErrorHandler(null);\n        setScheduleHandler(null);\n\n        setComputationSchedulerHandler(null);\n        setInitComputationSchedulerHandler(null);\n\n        setIoSchedulerHandler(null);\n        setInitIoSchedulerHandler(null);\n\n        setSingleSchedulerHandler(null);\n        setInitSingleSchedulerHandler(null);\n\n        setNewThreadSchedulerHandler(null);\n        setInitNewThreadSchedulerHandler(null);\n\n        setOnFlowableAssembly(null);\n        setOnFlowableSubscribe(null);\n\n        setOnObservableAssembly(null);\n        setOnObservableSubscribe(null);\n\n        setOnSingleAssembly(null);\n        setOnSingleSubscribe(null);\n\n        setOnCompletableAssembly(null);\n        setOnCompletableSubscribe(null);\n\n        setOnConnectableFlowableAssembly(null);\n        setOnConnectableObservableAssembly(null);\n\n        setOnMaybeAssembly(null);\n        setOnMaybeSubscribe(null);\n\n        setOnParallelAssembly(null);\n\n        setFailOnNonBlockingScheduler(false);\n        setOnBeforeBlocking(null);\n    }", "code_tokens": ["public", "static", "void", "reset", "(", ")", "{", "setErrorHandler", "(", "null", ")", ";", "setScheduleHandler", "(", "null", ")", ";", "setComputationSchedulerHandler", "(", "null", ")", ";", "setInitComputationSchedulerHandler", "(", "null", ")", ";", "setIoSchedulerHandler", "(", "null", ")", ";", "setInitIoSchedulerHandler", "(", "null", ")", ";", "setSingleSchedulerHandler", "(", "null", ")", ";", "setInitSingleSchedulerHandler", "(", "null", ")", ";", "setNewThreadSchedulerHandler", "(", "null", ")", ";", "setInitNewThreadSchedulerHandler", "(", "null", ")", ";", "setOnFlowableAssembly", "(", "null", ")", ";", "setOnFlowableSubscribe", "(", "null", ")", ";", "setOnObservableAssembly", "(", "null", ")", ";", "setOnObservableSubscribe", "(", "null", ")", ";", "setOnSingleAssembly", "(", "null", ")", ";", "setOnSingleSubscribe", "(", "null", ")", ";", "setOnCompletableAssembly", "(", "null", ")", ";", "setOnCompletableSubscribe", "(", "null", ")", ";", "setOnConnectableFlowableAssembly", "(", "null", ")", ";", "setOnConnectableObservableAssembly", "(", "null", ")", ";", "setOnMaybeAssembly", "(", "null", ")", ";", "setOnMaybeSubscribe", "(", "null", ")", ";", "setOnParallelAssembly", "(", "null", ")", ";", "setFailOnNonBlockingScheduler", "(", "false", ")", ";", "setOnBeforeBlocking", "(", "null", ")", ";", "}"], "docstring": "Removes all handlers and resets to default behavior.", "docstring_tokens": ["Removes", "all", "handlers", "and", "resets", "to", "default", "behavior", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/plugins/RxJavaPlugins.java#L493-L531", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Maybe.java", "func_name": "Maybe.fromCompletable", "original_string": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) {\n        ObjectHelper.requireNonNull(completableSource, \"completableSource is null\");\n        return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource));\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) {\n        ObjectHelper.requireNonNull(completableSource, \"completableSource is null\");\n        return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource));\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Maybe", "<", "T", ">", "fromCompletable", "(", "CompletableSource", "completableSource", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "completableSource", ",", "\"completableSource is null\"", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "MaybeFromCompletable", "<", "T", ">", "(", "completableSource", ")", ")", ";", "}"], "docstring": "Wraps a CompletableSource into a Maybe.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param <T> the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "docstring_tokens": ["Wraps", "a", "CompletableSource", "into", "a", "Maybe", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Maybe.java#L705-L711", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Maybe.java", "func_name": "Maybe.fromSingle", "original_string": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {\n        ObjectHelper.requireNonNull(singleSource, \"singleSource is null\");\n        return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource));\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {\n        ObjectHelper.requireNonNull(singleSource, \"singleSource is null\");\n        return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource));\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Maybe", "<", "T", ">", "fromSingle", "(", "SingleSource", "<", "T", ">", "singleSource", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "singleSource", ",", "\"singleSource is null\"", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "MaybeFromSingle", "<", "T", ">", "(", "singleSource", ")", ")", ";", "}"], "docstring": "Wraps a SingleSource into a Maybe.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code fromSingle} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param <T> the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "docstring_tokens": ["Wraps", "a", "SingleSource", "into", "a", "Maybe", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Maybe.java#L725-L731", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Maybe.java", "func_name": "Maybe.retry", "original_string": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) {\n        return toFlowable().retry(times, predicate).singleElement();\n    }", "language": "java", "code": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) {\n        return toFlowable().retry(times, predicate).singleElement();\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Maybe", "<", "T", ">", "retry", "(", "long", "times", ",", "Predicate", "<", "?", "super", "Throwable", ">", "predicate", ")", "{", "return", "toFlowable", "(", ")", ".", "retry", "(", "times", ",", "predicate", ")", ".", "singleElement", "(", ")", ";", "}"], "docstring": "Retries at most times or until the predicate returns false, whichever happens first.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code retry} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "docstring_tokens": ["Retries", "at", "most", "times", "or", "until", "the", "predicate", "returns", "false", "whichever", "happens", "first", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Maybe.java#L4055-L4059", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/functions/ObjectHelper.java", "func_name": "ObjectHelper.requireNonNull", "original_string": "public static <T> T requireNonNull(T object, String message) {\n        if (object == null) {\n            throw new NullPointerException(message);\n        }\n        return object;\n    }", "language": "java", "code": "public static <T> T requireNonNull(T object, String message) {\n        if (object == null) {\n            throw new NullPointerException(message);\n        }\n        return object;\n    }", "code_tokens": ["public", "static", "<", "T", ">", "T", "requireNonNull", "(", "T", "object", ",", "String", "message", ")", "{", "if", "(", "object", "==", "null", ")", "{", "throw", "new", "NullPointerException", "(", "message", ")", ";", "}", "return", "object", ";", "}"], "docstring": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param <T> the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "docstring_tokens": ["Verifies", "if", "the", "object", "is", "not", "null", "and", "returns", "it", "or", "throws", "a", "NullPointerException", "with", "the", "given", "message", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/functions/ObjectHelper.java#L37-L42", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/functions/Functions.java", "func_name": "Functions.identity", "original_string": "@SuppressWarnings(\"unchecked\")\n    public static <T> Function<T, T> identity() {\n        return (Function<T, T>)IDENTITY;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    public static <T> Function<T, T> identity() {\n        return (Function<T, T>)IDENTITY;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "<", "T", ">", "Function", "<", "T", ",", "T", ">", "identity", "(", ")", "{", "return", "(", "Function", "<", "T", ",", "T", ">", ")", "IDENTITY", ";", "}"], "docstring": "Returns an identity function that simply returns its argument.\n@param <T> the input and output value type\n@return the identity function", "docstring_tokens": ["Returns", "an", "identity", "function", "that", "simply", "returns", "its", "argument", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/functions/Functions.java#L88-L91", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/functions/Functions.java", "func_name": "Functions.justCallable", "original_string": "public static <T> Callable<T> justCallable(T value) {\n        return new JustValue<Object, T>(value);\n    }", "language": "java", "code": "public static <T> Callable<T> justCallable(T value) {\n        return new JustValue<Object, T>(value);\n    }", "code_tokens": ["public", "static", "<", "T", ">", "Callable", "<", "T", ">", "justCallable", "(", "T", "value", ")", "{", "return", "new", "JustValue", "<", "Object", ",", "T", ">", "(", "value", ")", ";", "}"], "docstring": "Returns a Callable that returns the given value.\n@param <T> the value type\n@param value the value to return\n@return the new Callable instance", "docstring_tokens": ["Returns", "a", "Callable", "that", "returns", "the", "given", "value", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/functions/Functions.java#L198-L200", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/functions/Functions.java", "func_name": "Functions.justFunction", "original_string": "public static <T, U> Function<T, U> justFunction(U value) {\n        return new JustValue<T, U>(value);\n    }", "language": "java", "code": "public static <T, U> Function<T, U> justFunction(U value) {\n        return new JustValue<T, U>(value);\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "Function", "<", "T", ",", "U", ">", "justFunction", "(", "U", "value", ")", "{", "return", "new", "JustValue", "<", "T", ",", "U", ">", "(", "value", ")", ";", "}"], "docstring": "Returns a Function that ignores its parameter and returns the given value.\n@param <T> the function's input type\n@param <U> the value and return type of the function\n@param value the value to return\n@return the new Function instance", "docstring_tokens": ["Returns", "a", "Function", "that", "ignores", "its", "parameter", "and", "returns", "the", "given", "value", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/functions/Functions.java#L209-L211", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/functions/Functions.java", "func_name": "Functions.castFunction", "original_string": "public static <T, U> Function<T, U> castFunction(Class<U> target) {\n        return new CastToClass<T, U>(target);\n    }", "language": "java", "code": "public static <T, U> Function<T, U> castFunction(Class<U> target) {\n        return new CastToClass<T, U>(target);\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "Function", "<", "T", ",", "U", ">", "castFunction", "(", "Class", "<", "U", ">", "target", ")", "{", "return", "new", "CastToClass", "<", "T", ",", "U", ">", "(", "target", ")", ";", "}"], "docstring": "Returns a function that cast the incoming values via a Class object.\n@param <T> the input value type\n@param <U> the output and target type\n@param target the target class\n@return the new Function instance", "docstring_tokens": ["Returns", "a", "function", "that", "cast", "the", "incoming", "values", "via", "a", "Class", "object", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/functions/Functions.java#L233-L235", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subjects/UnicastSubject.java", "func_name": "UnicastSubject.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create() {\n        return new UnicastSubject<T>(bufferSize(), true);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create() {\n        return new UnicastSubject<T>(bufferSize(), true);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastSubject", "<", "T", ">", "create", "(", ")", "{", "return", "new", "UnicastSubject", "<", "T", ">", "(", "bufferSize", "(", ")", ",", "true", ")", ";", "}"], "docstring": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param <T> the value type\n@return an UnicastSubject instance", "docstring_tokens": ["Creates", "an", "UnicastSubject", "with", "an", "internal", "buffer", "capacity", "hint", "16", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subjects/UnicastSubject.java#L181-L185", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subjects/UnicastSubject.java", "func_name": "UnicastSubject.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(int capacityHint) {\n        return new UnicastSubject<T>(capacityHint, true);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(int capacityHint) {\n        return new UnicastSubject<T>(capacityHint, true);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastSubject", "<", "T", ">", "create", "(", "int", "capacityHint", ")", "{", "return", "new", "UnicastSubject", "<", "T", ">", "(", "capacityHint", ",", "true", ")", ";", "}"], "docstring": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "docstring_tokens": ["Creates", "an", "UnicastSubject", "with", "the", "given", "internal", "buffer", "capacity", "hint", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subjects/UnicastSubject.java#L193-L197", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subjects/UnicastSubject.java", "func_name": "UnicastSubject.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {\n        return new UnicastSubject<T>(capacityHint, onTerminate, true);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {\n        return new UnicastSubject<T>(capacityHint, onTerminate, true);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastSubject", "<", "T", ">", "create", "(", "int", "capacityHint", ",", "Runnable", "onTerminate", ")", "{", "return", "new", "UnicastSubject", "<", "T", ">", "(", "capacityHint", ",", "onTerminate", ",", "true", ")", ";", "}"], "docstring": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "docstring_tokens": ["Creates", "an", "UnicastSubject", "with", "the", "given", "internal", "buffer", "capacity", "hint", "and", "a", "callback", "for", "the", "case", "when", "the", "single", "Subscriber", "cancels", "its", "subscription", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subjects/UnicastSubject.java#L211-L215", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subjects/UnicastSubject.java", "func_name": "UnicastSubject.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(boolean delayError) {\n        return new UnicastSubject<T>(bufferSize(), delayError);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(boolean delayError) {\n        return new UnicastSubject<T>(bufferSize(), delayError);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastSubject", "<", "T", ">", "create", "(", "boolean", "delayError", ")", "{", "return", "new", "UnicastSubject", "<", "T", ">", "(", "bufferSize", "(", ")", ",", "delayError", ")", ";", "}"], "docstring": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n<p>History: 2.0.8 - experimental\n@param <T> the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "docstring_tokens": ["Creates", "an", "UnicastSubject", "with", "an", "internal", "buffer", "capacity", "hint", "16", "and", "given", "delay", "error", "flag", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subjects/UnicastSubject.java#L248-L252", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java", "func_name": "BlockingMultiObserver.blockingGetError", "original_string": "public Throwable blockingGetError() {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                await();\n            } catch (InterruptedException ex) {\n                dispose();\n                return ex;\n            }\n        }\n        return error;\n    }", "language": "java", "code": "public Throwable blockingGetError() {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                await();\n            } catch (InterruptedException ex) {\n                dispose();\n                return ex;\n            }\n        }\n        return error;\n    }", "code_tokens": ["public", "Throwable", "blockingGetError", "(", ")", "{", "if", "(", "getCount", "(", ")", "!=", "0", ")", "{", "try", "{", "BlockingHelper", ".", "verifyNonBlocking", "(", ")", ";", "await", "(", ")", ";", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "dispose", "(", ")", ";", "return", "ex", ";", "}", "}", "return", "error", ";", "}"], "docstring": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "docstring_tokens": ["Block", "until", "the", "latch", "is", "counted", "down", "and", "return", "the", "error", "received", "or", "null", "if", "no", "error", "happened", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java#L127-L138", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java", "func_name": "BlockingMultiObserver.blockingGetError", "original_string": "public Throwable blockingGetError(long timeout, TimeUnit unit) {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                if (!await(timeout, unit)) {\n                    dispose();\n                    throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));\n                }\n            } catch (InterruptedException ex) {\n                dispose();\n                throw ExceptionHelper.wrapOrThrow(ex);\n            }\n        }\n        return error;\n    }", "language": "java", "code": "public Throwable blockingGetError(long timeout, TimeUnit unit) {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                if (!await(timeout, unit)) {\n                    dispose();\n                    throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));\n                }\n            } catch (InterruptedException ex) {\n                dispose();\n                throw ExceptionHelper.wrapOrThrow(ex);\n            }\n        }\n        return error;\n    }", "code_tokens": ["public", "Throwable", "blockingGetError", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "{", "if", "(", "getCount", "(", ")", "!=", "0", ")", "{", "try", "{", "BlockingHelper", ".", "verifyNonBlocking", "(", ")", ";", "if", "(", "!", "await", "(", "timeout", ",", "unit", ")", ")", "{", "dispose", "(", ")", ";", "throw", "ExceptionHelper", ".", "wrapOrThrow", "(", "new", "TimeoutException", "(", "timeoutMessage", "(", "timeout", ",", "unit", ")", ")", ")", ";", "}", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "dispose", "(", ")", ";", "throw", "ExceptionHelper", ".", "wrapOrThrow", "(", "ex", ")", ";", "}", "}", "return", "error", ";", "}"], "docstring": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "docstring_tokens": ["Block", "until", "the", "latch", "is", "counted", "down", "and", "return", "the", "error", "received", "or", "when", "the", "wait", "is", "interrupted", "or", "times", "out", "null", "otherwise", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java#L147-L161", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java", "func_name": "BlockingMultiObserver.blockingAwait", "original_string": "public boolean blockingAwait(long timeout, TimeUnit unit) {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                if (!await(timeout, unit)) {\n                    dispose();\n                    return false;\n                }\n            } catch (InterruptedException ex) {\n                dispose();\n                throw ExceptionHelper.wrapOrThrow(ex);\n            }\n        }\n        Throwable ex = error;\n        if (ex != null) {\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n        return true;\n    }", "language": "java", "code": "public boolean blockingAwait(long timeout, TimeUnit unit) {\n        if (getCount() != 0) {\n            try {\n                BlockingHelper.verifyNonBlocking();\n                if (!await(timeout, unit)) {\n                    dispose();\n                    return false;\n                }\n            } catch (InterruptedException ex) {\n                dispose();\n                throw ExceptionHelper.wrapOrThrow(ex);\n            }\n        }\n        Throwable ex = error;\n        if (ex != null) {\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n        return true;\n    }", "code_tokens": ["public", "boolean", "blockingAwait", "(", "long", "timeout", ",", "TimeUnit", "unit", ")", "{", "if", "(", "getCount", "(", ")", "!=", "0", ")", "{", "try", "{", "BlockingHelper", ".", "verifyNonBlocking", "(", ")", ";", "if", "(", "!", "await", "(", "timeout", ",", "unit", ")", ")", "{", "dispose", "(", ")", ";", "return", "false", ";", "}", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "dispose", "(", ")", ";", "throw", "ExceptionHelper", ".", "wrapOrThrow", "(", "ex", ")", ";", "}", "}", "Throwable", "ex", "=", "error", ";", "if", "(", "ex", "!=", "null", ")", "{", "throw", "ExceptionHelper", ".", "wrapOrThrow", "(", "ex", ")", ";", "}", "return", "true", ";", "}"], "docstring": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "docstring_tokens": ["Block", "until", "the", "observer", "terminates", "and", "return", "true", ";", "return", "false", "if", "the", "wait", "times", "out", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java#L170-L188", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/QueueDrainHelper.java", "func_name": "QueueDrainHelper.drainMaxLoop", "original_string": "public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd) {\n        int missed = 1;\n\n        for (;;) {\n            for (;;) {\n                boolean d = qd.done();\n\n                T v = q.poll();\n\n                boolean empty = v == null;\n\n                if (checkTerminated(d, empty, a, delayError, q, qd)) {\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                long r = qd.requested();\n                if (r != 0L) {\n                    if (qd.accept(a, v)) {\n                        if (r != Long.MAX_VALUE) {\n                            qd.produced(1);\n                        }\n                    }\n                } else {\n                    q.clear();\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\"));\n                    return;\n                }\n            }\n\n            missed = qd.leave(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }", "language": "java", "code": "public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,\n            Disposable dispose, QueueDrain<T, U> qd) {\n        int missed = 1;\n\n        for (;;) {\n            for (;;) {\n                boolean d = qd.done();\n\n                T v = q.poll();\n\n                boolean empty = v == null;\n\n                if (checkTerminated(d, empty, a, delayError, q, qd)) {\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                long r = qd.requested();\n                if (r != 0L) {\n                    if (qd.accept(a, v)) {\n                        if (r != Long.MAX_VALUE) {\n                            qd.produced(1);\n                        }\n                    }\n                } else {\n                    q.clear();\n                    if (dispose != null) {\n                        dispose.dispose();\n                    }\n                    a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\"));\n                    return;\n                }\n            }\n\n            missed = qd.leave(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "void", "drainMaxLoop", "(", "SimplePlainQueue", "<", "T", ">", "q", ",", "Subscriber", "<", "?", "super", "U", ">", "a", ",", "boolean", "delayError", ",", "Disposable", "dispose", ",", "QueueDrain", "<", "T", ",", "U", ">", "qd", ")", "{", "int", "missed", "=", "1", ";", "for", "(", ";", ";", ")", "{", "for", "(", ";", ";", ")", "{", "boolean", "d", "=", "qd", ".", "done", "(", ")", ";", "T", "v", "=", "q", ".", "poll", "(", ")", ";", "boolean", "empty", "=", "v", "==", "null", ";", "if", "(", "checkTerminated", "(", "d", ",", "empty", ",", "a", ",", "delayError", ",", "q", ",", "qd", ")", ")", "{", "if", "(", "dispose", "!=", "null", ")", "{", "dispose", ".", "dispose", "(", ")", ";", "}", "return", ";", "}", "if", "(", "empty", ")", "{", "break", ";", "}", "long", "r", "=", "qd", ".", "requested", "(", ")", ";", "if", "(", "r", "!=", "0L", ")", "{", "if", "(", "qd", ".", "accept", "(", "a", ",", "v", ")", ")", "{", "if", "(", "r", "!=", "Long", ".", "MAX_VALUE", ")", "{", "qd", ".", "produced", "(", "1", ")", ";", "}", "}", "}", "else", "{", "q", ".", "clear", "(", ")", ";", "if", "(", "dispose", "!=", "null", ")", "{", "dispose", ".", "dispose", "(", ")", ";", "}", "a", ".", "onError", "(", "new", "MissingBackpressureException", "(", "\"Could not emit value due to lack of requests.\"", ")", ")", ";", "return", ";", "}", "}", "missed", "=", "qd", ".", "leave", "(", "-", "missed", ")", ";", "if", "(", "missed", "==", "0", ")", "{", "break", ";", "}", "}", "}"], "docstring": "Drain the queue but give up with an error if there aren't enough requests.\n@param <T> the queue value type\n@param <U> the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "docstring_tokens": ["Drain", "the", "queue", "but", "give", "up", "with", "an", "error", "if", "there", "aren", "t", "enough", "requests", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java#L46-L91", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/QueueDrainHelper.java", "func_name": "QueueDrainHelper.request", "original_string": "public static void request(Subscription s, int prefetch) {\n        s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);\n    }", "language": "java", "code": "public static void request(Subscription s, int prefetch) {\n        s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);\n    }", "code_tokens": ["public", "static", "void", "request", "(", "Subscription", "s", ",", "int", "prefetch", ")", "{", "s", ".", "request", "(", "prefetch", "<", "0", "?", "Long", ".", "MAX_VALUE", ":", "prefetch", ")", ";", "}"], "docstring": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "docstring_tokens": ["Requests", "Long", ".", "MAX_VALUE", "if", "prefetch", "is", "negative", "or", "the", "exact", "amount", "if", "prefetch", "is", "positive", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java#L226-L228", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/QueueDrainHelper.java", "func_name": "QueueDrainHelper.postComplete", "original_string": "public static <T> void postComplete(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled) {\n\n        if (queue.isEmpty()) {\n            actual.onComplete();\n            return;\n        }\n\n        if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {\n            return;\n        }\n\n        for (; ; ) {\n            long r = state.get();\n\n            if ((r & COMPLETED_MASK) != 0L) {\n                return;\n            }\n\n            long u = r | COMPLETED_MASK;\n            // (active, r) -> (complete, r) transition\n            if (state.compareAndSet(r, u)) {\n                // if the requested amount was non-zero, drain the queue\n                if (r != 0L) {\n                    postCompleteDrain(u, actual, queue, state, isCancelled);\n                }\n\n                return;\n            }\n        }\n\n    }", "language": "java", "code": "public static <T> void postComplete(Subscriber<? super T> actual,\n                                        Queue<T> queue,\n                                        AtomicLong state,\n                                        BooleanSupplier isCancelled) {\n\n        if (queue.isEmpty()) {\n            actual.onComplete();\n            return;\n        }\n\n        if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {\n            return;\n        }\n\n        for (; ; ) {\n            long r = state.get();\n\n            if ((r & COMPLETED_MASK) != 0L) {\n                return;\n            }\n\n            long u = r | COMPLETED_MASK;\n            // (active, r) -> (complete, r) transition\n            if (state.compareAndSet(r, u)) {\n                // if the requested amount was non-zero, drain the queue\n                if (r != 0L) {\n                    postCompleteDrain(u, actual, queue, state, isCancelled);\n                }\n\n                return;\n            }\n        }\n\n    }", "code_tokens": ["public", "static", "<", "T", ">", "void", "postComplete", "(", "Subscriber", "<", "?", "super", "T", ">", "actual", ",", "Queue", "<", "T", ">", "queue", ",", "AtomicLong", "state", ",", "BooleanSupplier", "isCancelled", ")", "{", "if", "(", "queue", ".", "isEmpty", "(", ")", ")", "{", "actual", ".", "onComplete", "(", ")", ";", "return", ";", "}", "if", "(", "postCompleteDrain", "(", "state", ".", "get", "(", ")", ",", "actual", ",", "queue", ",", "state", ",", "isCancelled", ")", ")", "{", "return", ";", "}", "for", "(", ";", ";", ")", "{", "long", "r", "=", "state", ".", "get", "(", ")", ";", "if", "(", "(", "r", "&", "COMPLETED_MASK", ")", "!=", "0L", ")", "{", "return", ";", "}", "long", "u", "=", "r", "|", "COMPLETED_MASK", ";", "// (active, r) -> (complete, r) transition", "if", "(", "state", ".", "compareAndSet", "(", "r", ",", "u", ")", ")", "{", "// if the requested amount was non-zero, drain the queue", "if", "(", "r", "!=", "0L", ")", "{", "postCompleteDrain", "(", "u", ",", "actual", ",", "queue", ",", "state", ",", "isCancelled", ")", ";", "}", "return", ";", "}", "}", "}"], "docstring": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n<p>\nDon't modify the queue after calling this method!\n\n<p>\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n<p>\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param <T> the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "docstring_tokens": ["Signals", "the", "completion", "of", "the", "main", "sequence", "and", "switches", "to", "post", "-", "completion", "replay", "mode", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java#L395-L428", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/subscribers/SinglePostCompleteSubscriber.java", "func_name": "SinglePostCompleteSubscriber.complete", "original_string": "protected final void complete(R n) {\n        long p = produced;\n        if (p != 0) {\n            BackpressureHelper.produced(this, p);\n        }\n\n        for (;;) {\n            long r = get();\n            if ((r & COMPLETE_MASK) != 0) {\n                onDrop(n);\n                return;\n            }\n            if ((r & REQUEST_MASK) != 0) {\n                lazySet(COMPLETE_MASK + 1);\n                downstream.onNext(n);\n                downstream.onComplete();\n                return;\n            }\n            value = n;\n            if (compareAndSet(0, COMPLETE_MASK)) {\n                return;\n            }\n            value = null;\n        }\n    }", "language": "java", "code": "protected final void complete(R n) {\n        long p = produced;\n        if (p != 0) {\n            BackpressureHelper.produced(this, p);\n        }\n\n        for (;;) {\n            long r = get();\n            if ((r & COMPLETE_MASK) != 0) {\n                onDrop(n);\n                return;\n            }\n            if ((r & REQUEST_MASK) != 0) {\n                lazySet(COMPLETE_MASK + 1);\n                downstream.onNext(n);\n                downstream.onComplete();\n                return;\n            }\n            value = n;\n            if (compareAndSet(0, COMPLETE_MASK)) {\n                return;\n            }\n            value = null;\n        }\n    }", "code_tokens": ["protected", "final", "void", "complete", "(", "R", "n", ")", "{", "long", "p", "=", "produced", ";", "if", "(", "p", "!=", "0", ")", "{", "BackpressureHelper", ".", "produced", "(", "this", ",", "p", ")", ";", "}", "for", "(", ";", ";", ")", "{", "long", "r", "=", "get", "(", ")", ";", "if", "(", "(", "r", "&", "COMPLETE_MASK", ")", "!=", "0", ")", "{", "onDrop", "(", "n", ")", ";", "return", ";", "}", "if", "(", "(", "r", "&", "REQUEST_MASK", ")", "!=", "0", ")", "{", "lazySet", "(", "COMPLETE_MASK", "+", "1", ")", ";", "downstream", ".", "onNext", "(", "n", ")", ";", "downstream", ".", "onComplete", "(", ")", ";", "return", ";", "}", "value", "=", "n", ";", "if", "(", "compareAndSet", "(", "0", ",", "COMPLETE_MASK", ")", ")", "{", "return", ";", "}", "value", "=", "null", ";", "}", "}"], "docstring": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "docstring_tokens": ["Signals", "the", "given", "value", "and", "an", "onComplete", "if", "the", "downstream", "is", "ready", "to", "receive", "the", "final", "value", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/subscribers/SinglePostCompleteSubscriber.java#L67-L91", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Notification.java", "func_name": "Notification.getValue", "original_string": "@SuppressWarnings(\"unchecked\")\n    @Nullable\n    public T getValue() {\n        Object o = value;\n        if (o != null && !NotificationLite.isError(o)) {\n            return (T)value;\n        }\n        return null;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    @Nullable\n    public T getValue() {\n        Object o = value;\n        if (o != null && !NotificationLite.isError(o)) {\n            return (T)value;\n        }\n        return null;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "@", "Nullable", "public", "T", "getValue", "(", ")", "{", "Object", "o", "=", "value", ";", "if", "(", "o", "!=", "null", "&&", "!", "NotificationLite", ".", "isError", "(", "o", ")", ")", "{", "return", "(", "T", ")", "value", ";", "}", "return", "null", ";", "}"], "docstring": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "docstring_tokens": ["Returns", "the", "contained", "value", "if", "this", "notification", "is", "an", "onNext", "signal", "null", "otherwise", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Notification.java#L69-L77", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Notification.java", "func_name": "Notification.getError", "original_string": "@Nullable\n    public Throwable getError() {\n        Object o = value;\n        if (NotificationLite.isError(o)) {\n            return NotificationLite.getError(o);\n        }\n        return null;\n    }", "language": "java", "code": "@Nullable\n    public Throwable getError() {\n        Object o = value;\n        if (NotificationLite.isError(o)) {\n            return NotificationLite.getError(o);\n        }\n        return null;\n    }", "code_tokens": ["@", "Nullable", "public", "Throwable", "getError", "(", ")", "{", "Object", "o", "=", "value", ";", "if", "(", "NotificationLite", ".", "isError", "(", "o", ")", ")", "{", "return", "NotificationLite", ".", "getError", "(", "o", ")", ";", "}", "return", "null", ";", "}"], "docstring": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "docstring_tokens": ["Returns", "the", "container", "Throwable", "error", "if", "this", "notification", "is", "an", "onError", "signal", "null", "otherwise", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Notification.java#L85-L92", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/EndConsumerHelper.java", "func_name": "EndConsumerHelper.validate", "original_string": "public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (upstream != null) {\n            next.dispose();\n            if (upstream != DisposableHelper.DISPOSED) {\n                reportDoubleSubscription(observer);\n            }\n            return false;\n        }\n        return true;\n    }", "language": "java", "code": "public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (upstream != null) {\n            next.dispose();\n            if (upstream != DisposableHelper.DISPOSED) {\n                reportDoubleSubscription(observer);\n            }\n            return false;\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "validate", "(", "Disposable", "upstream", ",", "Disposable", "next", ",", "Class", "<", "?", ">", "observer", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "next", ",", "\"next is null\"", ")", ";", "if", "(", "upstream", "!=", "null", ")", "{", "next", ".", "dispose", "(", ")", ";", "if", "(", "upstream", "!=", "DisposableHelper", ".", "DISPOSED", ")", "{", "reportDoubleSubscription", "(", "observer", ")", ";", "}", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "docstring_tokens": ["Ensures", "that", "the", "upstream", "Disposable", "is", "null", "and", "returns", "true", "otherwise", "disposes", "the", "next", "Disposable", "and", "if", "the", "upstream", "is", "not", "the", "shared", "disposed", "instance", "reports", "a", "ProtocolViolationException", "due", "to", "multiple", "subscribe", "attempts", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/EndConsumerHelper.java#L52-L62", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/EndConsumerHelper.java", "func_name": "EndConsumerHelper.setOnce", "original_string": "public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (!upstream.compareAndSet(null, next)) {\n            next.dispose();\n            if (upstream.get() != DisposableHelper.DISPOSED) {\n                reportDoubleSubscription(observer);\n            }\n            return false;\n        }\n        return true;\n    }", "language": "java", "code": "public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (!upstream.compareAndSet(null, next)) {\n            next.dispose();\n            if (upstream.get() != DisposableHelper.DISPOSED) {\n                reportDoubleSubscription(observer);\n            }\n            return false;\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "setOnce", "(", "AtomicReference", "<", "Disposable", ">", "upstream", ",", "Disposable", "next", ",", "Class", "<", "?", ">", "observer", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "next", ",", "\"next is null\"", ")", ";", "if", "(", "!", "upstream", ".", "compareAndSet", "(", "null", ",", "next", ")", ")", "{", "next", ".", "dispose", "(", ")", ";", "if", "(", "upstream", ".", "get", "(", ")", "!=", "DisposableHelper", ".", "DISPOSED", ")", "{", "reportDoubleSubscription", "(", "observer", ")", ";", "}", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "docstring_tokens": ["Atomically", "updates", "the", "target", "upstream", "AtomicReference", "from", "null", "to", "the", "non", "-", "null", "next", "Disposable", "otherwise", "disposes", "next", "and", "reports", "a", "ProtocolViolationException", "if", "the", "AtomicReference", "doesn", "t", "contain", "the", "shared", "disposed", "indicator", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/EndConsumerHelper.java#L74-L84", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/EndConsumerHelper.java", "func_name": "EndConsumerHelper.validate", "original_string": "public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (upstream != null) {\n            next.cancel();\n            if (upstream != SubscriptionHelper.CANCELLED) {\n                reportDoubleSubscription(subscriber);\n            }\n            return false;\n        }\n        return true;\n    }", "language": "java", "code": "public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (upstream != null) {\n            next.cancel();\n            if (upstream != SubscriptionHelper.CANCELLED) {\n                reportDoubleSubscription(subscriber);\n            }\n            return false;\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "validate", "(", "Subscription", "upstream", ",", "Subscription", "next", ",", "Class", "<", "?", ">", "subscriber", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "next", ",", "\"next is null\"", ")", ";", "if", "(", "upstream", "!=", "null", ")", "{", "next", ".", "cancel", "(", ")", ";", "if", "(", "upstream", "!=", "SubscriptionHelper", ".", "CANCELLED", ")", "{", "reportDoubleSubscription", "(", "subscriber", ")", ";", "}", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "docstring_tokens": ["Ensures", "that", "the", "upstream", "Subscription", "is", "null", "and", "returns", "true", "otherwise", "cancels", "the", "next", "Subscription", "and", "if", "the", "upstream", "is", "not", "the", "shared", "cancelled", "instance", "reports", "a", "ProtocolViolationException", "due", "to", "multiple", "subscribe", "attempts", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/EndConsumerHelper.java#L97-L107", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/EndConsumerHelper.java", "func_name": "EndConsumerHelper.setOnce", "original_string": "public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (!upstream.compareAndSet(null, next)) {\n            next.cancel();\n            if (upstream.get() != SubscriptionHelper.CANCELLED) {\n                reportDoubleSubscription(subscriber);\n            }\n            return false;\n        }\n        return true;\n    }", "language": "java", "code": "public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (!upstream.compareAndSet(null, next)) {\n            next.cancel();\n            if (upstream.get() != SubscriptionHelper.CANCELLED) {\n                reportDoubleSubscription(subscriber);\n            }\n            return false;\n        }\n        return true;\n    }", "code_tokens": ["public", "static", "boolean", "setOnce", "(", "AtomicReference", "<", "Subscription", ">", "upstream", ",", "Subscription", "next", ",", "Class", "<", "?", ">", "subscriber", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "next", ",", "\"next is null\"", ")", ";", "if", "(", "!", "upstream", ".", "compareAndSet", "(", "null", ",", "next", ")", ")", "{", "next", ".", "cancel", "(", ")", ";", "if", "(", "upstream", ".", "get", "(", ")", "!=", "SubscriptionHelper", ".", "CANCELLED", ")", "{", "reportDoubleSubscription", "(", "subscriber", ")", ";", "}", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "docstring_tokens": ["Atomically", "updates", "the", "target", "upstream", "AtomicReference", "from", "null", "to", "the", "non", "-", "null", "next", "Subscription", "otherwise", "cancels", "next", "and", "reports", "a", "ProtocolViolationException", "if", "the", "AtomicReference", "doesn", "t", "contain", "the", "shared", "cancelled", "indicator", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/EndConsumerHelper.java#L119-L129", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/BackpressureHelper.java", "func_name": "BackpressureHelper.addCap", "original_string": "public static long addCap(long a, long b) {\n        long u = a + b;\n        if (u < 0L) {\n            return Long.MAX_VALUE;\n        }\n        return u;\n    }", "language": "java", "code": "public static long addCap(long a, long b) {\n        long u = a + b;\n        if (u < 0L) {\n            return Long.MAX_VALUE;\n        }\n        return u;\n    }", "code_tokens": ["public", "static", "long", "addCap", "(", "long", "a", ",", "long", "b", ")", "{", "long", "u", "=", "a", "+", "b", ";", "if", "(", "u", "<", "0L", ")", "{", "return", "Long", ".", "MAX_VALUE", ";", "}", "return", "u", ";", "}"], "docstring": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "docstring_tokens": ["Adds", "two", "long", "values", "and", "caps", "the", "sum", "at", "Long", ".", "MAX_VALUE", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/BackpressureHelper.java#L34-L40", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/BackpressureHelper.java", "func_name": "BackpressureHelper.multiplyCap", "original_string": "public static long multiplyCap(long a, long b) {\n        long u = a * b;\n        if (((a | b) >>> 31) != 0) {\n            if (u / a != b) {\n                return Long.MAX_VALUE;\n            }\n        }\n        return u;\n    }", "language": "java", "code": "public static long multiplyCap(long a, long b) {\n        long u = a * b;\n        if (((a | b) >>> 31) != 0) {\n            if (u / a != b) {\n                return Long.MAX_VALUE;\n            }\n        }\n        return u;\n    }", "code_tokens": ["public", "static", "long", "multiplyCap", "(", "long", "a", ",", "long", "b", ")", "{", "long", "u", "=", "a", "*", "b", ";", "if", "(", "(", "(", "a", "|", "b", ")", ">>>", "31", ")", "!=", "0", ")", "{", "if", "(", "u", "/", "a", "!=", "b", ")", "{", "return", "Long", ".", "MAX_VALUE", ";", "}", "}", "return", "u", ";", "}"], "docstring": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "docstring_tokens": ["Multiplies", "two", "long", "values", "and", "caps", "the", "product", "at", "Long", ".", "MAX_VALUE", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/BackpressureHelper.java#L48-L56", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/BackpressureHelper.java", "func_name": "BackpressureHelper.add", "original_string": "public static long add(AtomicLong requested, long n) {\n        for (;;) {\n            long r = requested.get();\n            if (r == Long.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            long u = addCap(r, n);\n            if (requested.compareAndSet(r, u)) {\n                return r;\n            }\n        }\n    }", "language": "java", "code": "public static long add(AtomicLong requested, long n) {\n        for (;;) {\n            long r = requested.get();\n            if (r == Long.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            long u = addCap(r, n);\n            if (requested.compareAndSet(r, u)) {\n                return r;\n            }\n        }\n    }", "code_tokens": ["public", "static", "long", "add", "(", "AtomicLong", "requested", ",", "long", "n", ")", "{", "for", "(", ";", ";", ")", "{", "long", "r", "=", "requested", ".", "get", "(", ")", ";", "if", "(", "r", "==", "Long", ".", "MAX_VALUE", ")", "{", "return", "Long", ".", "MAX_VALUE", ";", "}", "long", "u", "=", "addCap", "(", "r", ",", "n", ")", ";", "if", "(", "requested", ".", "compareAndSet", "(", "r", ",", "u", ")", ")", "{", "return", "r", ";", "}", "}", "}"], "docstring": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "docstring_tokens": ["Atomically", "adds", "the", "positive", "value", "n", "to", "the", "requested", "value", "in", "the", "AtomicLong", "and", "caps", "the", "result", "at", "Long", ".", "MAX_VALUE", "and", "returns", "the", "previous", "value", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/BackpressureHelper.java#L65-L76", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Completable.java", "func_name": "Completable.toNpe", "original_string": "private static NullPointerException toNpe(Throwable ex) {\n        NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n        npe.initCause(ex);\n        return npe;\n    }", "language": "java", "code": "private static NullPointerException toNpe(Throwable ex) {\n        NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\n        npe.initCause(ex);\n        return npe;\n    }", "code_tokens": ["private", "static", "NullPointerException", "toNpe", "(", "Throwable", "ex", ")", "{", "NullPointerException", "npe", "=", "new", "NullPointerException", "(", "\"Actually not, but can't pass out an exception otherwise...\"", ")", ";", "npe", ".", "initCause", "(", "ex", ")", ";", "return", "npe", ";", "}"], "docstring": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "docstring_tokens": ["Creates", "a", "NullPointerException", "instance", "and", "sets", "the", "given", "Throwable", "as", "its", "initial", "cause", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Completable.java#L949-L953", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/LinkedArrayList.java", "func_name": "LinkedArrayList.add", "original_string": "public void add(Object o) {\n        // if no value yet, create the first array\n        if (size == 0) {\n            head = new Object[capacityHint + 1];\n            tail = head;\n            head[0] = o;\n            indexInTail = 1;\n            size = 1;\n        } else\n        // if the tail is full, create a new tail and link\n        if (indexInTail == capacityHint) {\n            Object[] t = new Object[capacityHint + 1];\n            t[0] = o;\n            tail[capacityHint] = t;\n            tail = t;\n            indexInTail = 1;\n            size++;\n        } else {\n            tail[indexInTail] = o;\n            indexInTail++;\n            size++;\n        }\n    }", "language": "java", "code": "public void add(Object o) {\n        // if no value yet, create the first array\n        if (size == 0) {\n            head = new Object[capacityHint + 1];\n            tail = head;\n            head[0] = o;\n            indexInTail = 1;\n            size = 1;\n        } else\n        // if the tail is full, create a new tail and link\n        if (indexInTail == capacityHint) {\n            Object[] t = new Object[capacityHint + 1];\n            t[0] = o;\n            tail[capacityHint] = t;\n            tail = t;\n            indexInTail = 1;\n            size++;\n        } else {\n            tail[indexInTail] = o;\n            indexInTail++;\n            size++;\n        }\n    }", "code_tokens": ["public", "void", "add", "(", "Object", "o", ")", "{", "// if no value yet, create the first array", "if", "(", "size", "==", "0", ")", "{", "head", "=", "new", "Object", "[", "capacityHint", "+", "1", "]", ";", "tail", "=", "head", ";", "head", "[", "0", "]", "=", "o", ";", "indexInTail", "=", "1", ";", "size", "=", "1", ";", "}", "else", "// if the tail is full, create a new tail and link", "if", "(", "indexInTail", "==", "capacityHint", ")", "{", "Object", "[", "]", "t", "=", "new", "Object", "[", "capacityHint", "+", "1", "]", ";", "t", "[", "0", "]", "=", "o", ";", "tail", "[", "capacityHint", "]", "=", "t", ";", "tail", "=", "t", ";", "indexInTail", "=", "1", ";", "size", "++", ";", "}", "else", "{", "tail", "[", "indexInTail", "]", "=", "o", ";", "indexInTail", "++", ";", "size", "++", ";", "}", "}"], "docstring": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "docstring_tokens": ["Adds", "a", "new", "element", "to", "this", "list", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/LinkedArrayList.java#L52-L74", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java", "func_name": "SchedulerPoolFactory.shutdown", "original_string": "public static void shutdown() {\n        ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null);\n        if (exec != null) {\n            exec.shutdownNow();\n        }\n        POOLS.clear();\n    }", "language": "java", "code": "public static void shutdown() {\n        ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null);\n        if (exec != null) {\n            exec.shutdownNow();\n        }\n        POOLS.clear();\n    }", "code_tokens": ["public", "static", "void", "shutdown", "(", ")", "{", "ScheduledExecutorService", "exec", "=", "PURGE_THREAD", ".", "getAndSet", "(", "null", ")", ";", "if", "(", "exec", "!=", "null", ")", "{", "exec", ".", "shutdownNow", "(", ")", ";", "}", "POOLS", ".", "clear", "(", ")", ";", "}"], "docstring": "Stops the purge thread.", "docstring_tokens": ["Stops", "the", "purge", "thread", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java#L84-L90", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java", "func_name": "SchedulerPoolFactory.create", "original_string": "public static ScheduledExecutorService create(ThreadFactory factory) {\n        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n        tryPutIntoPool(PURGE_ENABLED, exec);\n        return exec;\n    }", "language": "java", "code": "public static ScheduledExecutorService create(ThreadFactory factory) {\n        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n        tryPutIntoPool(PURGE_ENABLED, exec);\n        return exec;\n    }", "code_tokens": ["public", "static", "ScheduledExecutorService", "create", "(", "ThreadFactory", "factory", ")", "{", "final", "ScheduledExecutorService", "exec", "=", "Executors", ".", "newScheduledThreadPool", "(", "1", ",", "factory", ")", ";", "tryPutIntoPool", "(", "PURGE_ENABLED", ",", "exec", ")", ";", "return", "exec", ";", "}"], "docstring": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "docstring_tokens": ["Creates", "a", "ScheduledExecutorService", "with", "the", "given", "factory", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java#L134-L138", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java", "func_name": "SubscriptionArbiter.setSubscription", "original_string": "public final void setSubscription(Subscription s) {\n        if (cancelled) {\n            s.cancel();\n            return;\n        }\n\n        ObjectHelper.requireNonNull(s, \"s is null\");\n\n        if (get() == 0 && compareAndSet(0, 1)) {\n            Subscription a = actual;\n\n            if (a != null && cancelOnReplace) {\n                a.cancel();\n            }\n\n            actual = s;\n\n            long r = requested;\n\n            if (decrementAndGet() != 0) {\n                drainLoop();\n            }\n\n            if (r != 0L) {\n                s.request(r);\n            }\n\n            return;\n        }\n\n        Subscription a = missedSubscription.getAndSet(s);\n        if (a != null && cancelOnReplace) {\n            a.cancel();\n        }\n        drain();\n    }", "language": "java", "code": "public final void setSubscription(Subscription s) {\n        if (cancelled) {\n            s.cancel();\n            return;\n        }\n\n        ObjectHelper.requireNonNull(s, \"s is null\");\n\n        if (get() == 0 && compareAndSet(0, 1)) {\n            Subscription a = actual;\n\n            if (a != null && cancelOnReplace) {\n                a.cancel();\n            }\n\n            actual = s;\n\n            long r = requested;\n\n            if (decrementAndGet() != 0) {\n                drainLoop();\n            }\n\n            if (r != 0L) {\n                s.request(r);\n            }\n\n            return;\n        }\n\n        Subscription a = missedSubscription.getAndSet(s);\n        if (a != null && cancelOnReplace) {\n            a.cancel();\n        }\n        drain();\n    }", "code_tokens": ["public", "final", "void", "setSubscription", "(", "Subscription", "s", ")", "{", "if", "(", "cancelled", ")", "{", "s", ".", "cancel", "(", ")", ";", "return", ";", "}", "ObjectHelper", ".", "requireNonNull", "(", "s", ",", "\"s is null\"", ")", ";", "if", "(", "get", "(", ")", "==", "0", "&&", "compareAndSet", "(", "0", ",", "1", ")", ")", "{", "Subscription", "a", "=", "actual", ";", "if", "(", "a", "!=", "null", "&&", "cancelOnReplace", ")", "{", "a", ".", "cancel", "(", ")", ";", "}", "actual", "=", "s", ";", "long", "r", "=", "requested", ";", "if", "(", "decrementAndGet", "(", ")", "!=", "0", ")", "{", "drainLoop", "(", ")", ";", "}", "if", "(", "r", "!=", "0L", ")", "{", "s", ".", "request", "(", "r", ")", ";", "}", "return", ";", "}", "Subscription", "a", "=", "missedSubscription", ".", "getAndSet", "(", "s", ")", ";", "if", "(", "a", "!=", "null", "&&", "cancelOnReplace", ")", "{", "a", ".", "cancel", "(", ")", ";", "}", "drain", "(", ")", ";", "}"], "docstring": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "docstring_tokens": ["Atomically", "sets", "a", "new", "subscription", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java#L75-L110", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subjects/SerializedSubject.java", "func_name": "SerializedSubject.emitLoop", "original_string": "void emitLoop() {\n        for (;;) {\n            AppendOnlyLinkedArrayList<Object> q;\n            synchronized (this) {\n                q = queue;\n                if (q == null) {\n                    emitting = false;\n                    return;\n                }\n                queue = null;\n            }\n            q.forEachWhile(this);\n        }\n    }", "language": "java", "code": "void emitLoop() {\n        for (;;) {\n            AppendOnlyLinkedArrayList<Object> q;\n            synchronized (this) {\n                q = queue;\n                if (q == null) {\n                    emitting = false;\n                    return;\n                }\n                queue = null;\n            }\n            q.forEachWhile(this);\n        }\n    }", "code_tokens": ["void", "emitLoop", "(", ")", "{", "for", "(", ";", ";", ")", "{", "AppendOnlyLinkedArrayList", "<", "Object", ">", "q", ";", "synchronized", "(", "this", ")", "{", "q", "=", "queue", ";", "if", "(", "q", "==", "null", ")", "{", "emitting", "=", "false", ";", "return", ";", "}", "queue", "=", "null", ";", "}", "q", ".", "forEachWhile", "(", "this", ")", ";", "}", "}"], "docstring": "Loops until all notifications in the queue has been processed.", "docstring_tokens": ["Loops", "until", "all", "notifications", "in", "the", "queue", "has", "been", "processed", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subjects/SerializedSubject.java#L165-L178", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/ExceptionHelper.java", "func_name": "ExceptionHelper.wrapOrThrow", "original_string": "public static RuntimeException wrapOrThrow(Throwable error) {\n        if (error instanceof Error) {\n            throw (Error)error;\n        }\n        if (error instanceof RuntimeException) {\n            return (RuntimeException)error;\n        }\n        return new RuntimeException(error);\n    }", "language": "java", "code": "public static RuntimeException wrapOrThrow(Throwable error) {\n        if (error instanceof Error) {\n            throw (Error)error;\n        }\n        if (error instanceof RuntimeException) {\n            return (RuntimeException)error;\n        }\n        return new RuntimeException(error);\n    }", "code_tokens": ["public", "static", "RuntimeException", "wrapOrThrow", "(", "Throwable", "error", ")", "{", "if", "(", "error", "instanceof", "Error", ")", "{", "throw", "(", "Error", ")", "error", ";", "}", "if", "(", "error", "instanceof", "RuntimeException", ")", "{", "return", "(", "RuntimeException", ")", "error", ";", "}", "return", "new", "RuntimeException", "(", "error", ")", ";", "}"], "docstring": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "docstring_tokens": ["If", "the", "provided", "Throwable", "is", "an", "Error", "this", "method", "throws", "it", "otherwise", "returns", "a", "RuntimeException", "wrapping", "the", "error", "if", "that", "error", "is", "a", "checked", "exception", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/ExceptionHelper.java#L39-L47", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/ExceptionHelper.java", "func_name": "ExceptionHelper.flatten", "original_string": "public static List<Throwable> flatten(Throwable t) {\n        List<Throwable> list = new ArrayList<Throwable>();\n        ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>();\n        deque.offer(t);\n\n        while (!deque.isEmpty()) {\n            Throwable e = deque.removeFirst();\n            if (e instanceof CompositeException) {\n                CompositeException ce = (CompositeException) e;\n                List<Throwable> exceptions = ce.getExceptions();\n                for (int i = exceptions.size() - 1; i >= 0; i--) {\n                    deque.offerFirst(exceptions.get(i));\n                }\n            } else {\n                list.add(e);\n            }\n        }\n\n        return list;\n    }", "language": "java", "code": "public static List<Throwable> flatten(Throwable t) {\n        List<Throwable> list = new ArrayList<Throwable>();\n        ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>();\n        deque.offer(t);\n\n        while (!deque.isEmpty()) {\n            Throwable e = deque.removeFirst();\n            if (e instanceof CompositeException) {\n                CompositeException ce = (CompositeException) e;\n                List<Throwable> exceptions = ce.getExceptions();\n                for (int i = exceptions.size() - 1; i >= 0; i--) {\n                    deque.offerFirst(exceptions.get(i));\n                }\n            } else {\n                list.add(e);\n            }\n        }\n\n        return list;\n    }", "code_tokens": ["public", "static", "List", "<", "Throwable", ">", "flatten", "(", "Throwable", "t", ")", "{", "List", "<", "Throwable", ">", "list", "=", "new", "ArrayList", "<", "Throwable", ">", "(", ")", ";", "ArrayDeque", "<", "Throwable", ">", "deque", "=", "new", "ArrayDeque", "<", "Throwable", ">", "(", ")", ";", "deque", ".", "offer", "(", "t", ")", ";", "while", "(", "!", "deque", ".", "isEmpty", "(", ")", ")", "{", "Throwable", "e", "=", "deque", ".", "removeFirst", "(", ")", ";", "if", "(", "e", "instanceof", "CompositeException", ")", "{", "CompositeException", "ce", "=", "(", "CompositeException", ")", "e", ";", "List", "<", "Throwable", ">", "exceptions", "=", "ce", ".", "getExceptions", "(", ")", ";", "for", "(", "int", "i", "=", "exceptions", ".", "size", "(", ")", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "deque", ".", "offerFirst", "(", "exceptions", ".", "get", "(", "i", ")", ")", ";", "}", "}", "else", "{", "list", ".", "add", "(", "e", ")", ";", "}", "}", "return", "list", ";", "}"], "docstring": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "docstring_tokens": ["Returns", "a", "flattened", "list", "of", "Throwables", "from", "tree", "-", "like", "CompositeException", "chain", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/ExceptionHelper.java#L89-L108", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/ExceptionHelper.java", "func_name": "ExceptionHelper.throwIfThrowable", "original_string": "@SuppressWarnings(\"unchecked\")\n    public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {\n        if (e instanceof Exception) {\n            return (Exception)e;\n        }\n        throw (E)e;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {\n        if (e instanceof Exception) {\n            return (Exception)e;\n        }\n        throw (E)e;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "<", "E", "extends", "Throwable", ">", "Exception", "throwIfThrowable", "(", "Throwable", "e", ")", "throws", "E", "{", "if", "(", "e", "instanceof", "Exception", ")", "{", "return", "(", "Exception", ")", "e", ";", "}", "throw", "(", "E", ")", "e", ";", "}"], "docstring": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param <E> the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "docstring_tokens": ["Workaround", "for", "Java", "6", "not", "supporting", "throwing", "a", "final", "Throwable", "from", "a", "catch", "block", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/ExceptionHelper.java#L117-L123", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/disposables/CompositeDisposable.java", "func_name": "CompositeDisposable.clear", "original_string": "public void clear() {\n        if (disposed) {\n            return;\n        }\n        OpenHashSet<Disposable> set;\n        synchronized (this) {\n            if (disposed) {\n                return;\n            }\n\n            set = resources;\n            resources = null;\n        }\n\n        dispose(set);\n    }", "language": "java", "code": "public void clear() {\n        if (disposed) {\n            return;\n        }\n        OpenHashSet<Disposable> set;\n        synchronized (this) {\n            if (disposed) {\n                return;\n            }\n\n            set = resources;\n            resources = null;\n        }\n\n        dispose(set);\n    }", "code_tokens": ["public", "void", "clear", "(", ")", "{", "if", "(", "disposed", ")", "{", "return", ";", "}", "OpenHashSet", "<", "Disposable", ">", "set", ";", "synchronized", "(", "this", ")", "{", "if", "(", "disposed", ")", "{", "return", ";", "}", "set", "=", "resources", ";", "resources", "=", "null", ";", "}", "dispose", "(", "set", ")", ";", "}"], "docstring": "Atomically clears the container, then disposes all the previously contained Disposables.", "docstring_tokens": ["Atomically", "clears", "the", "container", "then", "disposes", "all", "the", "previously", "contained", "Disposables", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/disposables/CompositeDisposable.java#L192-L207", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/disposables/CompositeDisposable.java", "func_name": "CompositeDisposable.size", "original_string": "public int size() {\n        if (disposed) {\n            return 0;\n        }\n        synchronized (this) {\n            if (disposed) {\n                return 0;\n            }\n            OpenHashSet<Disposable> set = resources;\n            return set != null ? set.size() : 0;\n        }\n    }", "language": "java", "code": "public int size() {\n        if (disposed) {\n            return 0;\n        }\n        synchronized (this) {\n            if (disposed) {\n                return 0;\n            }\n            OpenHashSet<Disposable> set = resources;\n            return set != null ? set.size() : 0;\n        }\n    }", "code_tokens": ["public", "int", "size", "(", ")", "{", "if", "(", "disposed", ")", "{", "return", "0", ";", "}", "synchronized", "(", "this", ")", "{", "if", "(", "disposed", ")", "{", "return", "0", ";", "}", "OpenHashSet", "<", "Disposable", ">", "set", "=", "resources", ";", "return", "set", "!=", "null", "?", "set", ".", "size", "(", ")", ":", "0", ";", "}", "}"], "docstring": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "docstring_tokens": ["Returns", "the", "number", "of", "currently", "held", "Disposables", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/disposables/CompositeDisposable.java#L213-L224", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java", "func_name": "ObservableScalarXMap.tryScalarXMapSubscribe", "original_string": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,\n            Observer<? super R> observer,\n            Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (t == null) {\n                EmptyDisposable.complete(observer);\n                return true;\n            }\n\n            ObservableSource<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptyDisposable.error(ex, observer);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptyDisposable.complete(observer);\n                    return true;\n                }\n                ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u);\n                observer.onSubscribe(sd);\n                sd.run();\n            } else {\n                r.subscribe(observer);\n            }\n\n            return true;\n        }\n        return false;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,\n            Observer<? super R> observer,\n            Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (t == null) {\n                EmptyDisposable.complete(observer);\n                return true;\n            }\n\n            ObservableSource<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptyDisposable.error(ex, observer);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptyDisposable.complete(observer);\n                    return true;\n                }\n                ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u);\n                observer.onSubscribe(sd);\n                sd.run();\n            } else {\n                r.subscribe(observer);\n            }\n\n            return true;\n        }\n        return false;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "<", "T", ",", "R", ">", "boolean", "tryScalarXMapSubscribe", "(", "ObservableSource", "<", "T", ">", "source", ",", "Observer", "<", "?", "super", "R", ">", "observer", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "ObservableSource", "<", "?", "extends", "R", ">", ">", "mapper", ")", "{", "if", "(", "source", "instanceof", "Callable", ")", "{", "T", "t", ";", "try", "{", "t", "=", "(", "(", "Callable", "<", "T", ">", ")", "source", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptyDisposable", ".", "error", "(", "ex", ",", "observer", ")", ";", "return", "true", ";", "}", "if", "(", "t", "==", "null", ")", "{", "EmptyDisposable", ".", "complete", "(", "observer", ")", ";", "return", "true", ";", "}", "ObservableSource", "<", "?", "extends", "R", ">", "r", ";", "try", "{", "r", "=", "ObjectHelper", ".", "requireNonNull", "(", "mapper", ".", "apply", "(", "t", ")", ",", "\"The mapper returned a null ObservableSource\"", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptyDisposable", ".", "error", "(", "ex", ",", "observer", ")", ";", "return", "true", ";", "}", "if", "(", "r", "instanceof", "Callable", ")", "{", "R", "u", ";", "try", "{", "u", "=", "(", "(", "Callable", "<", "R", ">", ")", "r", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptyDisposable", ".", "error", "(", "ex", ",", "observer", ")", ";", "return", "true", ";", "}", "if", "(", "u", "==", "null", ")", "{", "EmptyDisposable", ".", "complete", "(", "observer", ")", ";", "return", "true", ";", "}", "ScalarDisposable", "<", "R", ">", "sd", "=", "new", "ScalarDisposable", "<", "R", ">", "(", "observer", ",", "u", ")", ";", "observer", ".", "onSubscribe", "(", "sd", ")", ";", "sd", ".", "run", "(", ")", ";", "}", "else", "{", "r", ".", "subscribe", "(", "observer", ")", ";", "}", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param <T> the input value type\n@param <R> the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "docstring_tokens": ["Tries", "to", "subscribe", "to", "a", "possibly", "Callable", "source", "s", "mapped", "ObservableSource", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java#L47-L102", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java", "func_name": "ObservableScalarXMap.scalarXMap", "original_string": "public static <T, U> Observable<U> scalarXMap(T value,\n            Function<? super T, ? extends ObservableSource<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper));\n    }", "language": "java", "code": "public static <T, U> Observable<U> scalarXMap(T value,\n            Function<? super T, ? extends ObservableSource<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper));\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "Observable", "<", "U", ">", "scalarXMap", "(", "T", "value", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "ObservableSource", "<", "?", "extends", "U", ">", ">", "mapper", ")", "{", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "ScalarXMapObservable", "<", "T", ",", "U", ">", "(", "value", ",", "mapper", ")", ")", ";", "}"], "docstring": "Maps a scalar value into an Observable and emits its values.\n\n@param <T> the scalar value type\n@param <U> the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "docstring_tokens": ["Maps", "a", "scalar", "value", "into", "an", "Observable", "and", "emits", "its", "values", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java#L114-L117", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java", "func_name": "AppendOnlyLinkedArrayList.accept", "original_string": "public <U> boolean accept(Subscriber<? super U> subscriber) {\n        Object[] a = head;\n        final int c = capacity;\n        while (a != null) {\n            for (int i = 0; i < c; i++) {\n                Object o = a[i];\n                if (o == null) {\n                    break;\n                }\n\n                if (NotificationLite.acceptFull(o, subscriber)) {\n                    return true;\n                }\n            }\n            a = (Object[])a[c];\n        }\n        return false;\n    }", "language": "java", "code": "public <U> boolean accept(Subscriber<? super U> subscriber) {\n        Object[] a = head;\n        final int c = capacity;\n        while (a != null) {\n            for (int i = 0; i < c; i++) {\n                Object o = a[i];\n                if (o == null) {\n                    break;\n                }\n\n                if (NotificationLite.acceptFull(o, subscriber)) {\n                    return true;\n                }\n            }\n            a = (Object[])a[c];\n        }\n        return false;\n    }", "code_tokens": ["public", "<", "U", ">", "boolean", "accept", "(", "Subscriber", "<", "?", "super", "U", ">", "subscriber", ")", "{", "Object", "[", "]", "a", "=", "head", ";", "final", "int", "c", "=", "capacity", ";", "while", "(", "a", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "c", ";", "i", "++", ")", "{", "Object", "o", "=", "a", "[", "i", "]", ";", "if", "(", "o", "==", "null", ")", "{", "break", ";", "}", "if", "(", "NotificationLite", ".", "acceptFull", "(", "o", ",", "subscriber", ")", ")", "{", "return", "true", ";", "}", "}", "a", "=", "(", "Object", "[", "]", ")", "a", "[", "c", "]", ";", "}", "return", "false", ";", "}"], "docstring": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param <U> the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "docstring_tokens": ["Interprets", "the", "contents", "as", "NotificationLite", "objects", "and", "calls", "the", "appropriate", "Subscriber", "method", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java#L109-L126", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java", "func_name": "AppendOnlyLinkedArrayList.accept", "original_string": "public <U> boolean accept(Observer<? super U> observer) {\n        Object[] a = head;\n        final int c = capacity;\n        while (a != null) {\n            for (int i = 0; i < c; i++) {\n                Object o = a[i];\n                if (o == null) {\n                    break;\n                }\n\n                if (NotificationLite.acceptFull(o, observer)) {\n                    return true;\n                }\n            }\n            a = (Object[])a[c];\n        }\n        return false;\n    }", "language": "java", "code": "public <U> boolean accept(Observer<? super U> observer) {\n        Object[] a = head;\n        final int c = capacity;\n        while (a != null) {\n            for (int i = 0; i < c; i++) {\n                Object o = a[i];\n                if (o == null) {\n                    break;\n                }\n\n                if (NotificationLite.acceptFull(o, observer)) {\n                    return true;\n                }\n            }\n            a = (Object[])a[c];\n        }\n        return false;\n    }", "code_tokens": ["public", "<", "U", ">", "boolean", "accept", "(", "Observer", "<", "?", "super", "U", ">", "observer", ")", "{", "Object", "[", "]", "a", "=", "head", ";", "final", "int", "c", "=", "capacity", ";", "while", "(", "a", "!=", "null", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "c", ";", "i", "++", ")", "{", "Object", "o", "=", "a", "[", "i", "]", ";", "if", "(", "o", "==", "null", ")", "{", "break", ";", "}", "if", "(", "NotificationLite", ".", "acceptFull", "(", "o", ",", "observer", ")", ")", "{", "return", "true", ";", "}", "}", "a", "=", "(", "Object", "[", "]", ")", "a", "[", "c", "]", ";", "}", "return", "false", ";", "}"], "docstring": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param <U> the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "docstring_tokens": ["Interprets", "the", "contents", "as", "NotificationLite", "objects", "and", "calls", "the", "appropriate", "Observer", "method", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java#L136-L153", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/MulticastProcessor.java", "func_name": "MulticastProcessor.start", "original_string": "public void start() {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscArrayQueue<T>(bufferSize);\n        }\n    }", "language": "java", "code": "public void start() {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscArrayQueue<T>(bufferSize);\n        }\n    }", "code_tokens": ["public", "void", "start", "(", ")", "{", "if", "(", "SubscriptionHelper", ".", "setOnce", "(", "upstream", ",", "EmptySubscription", ".", "INSTANCE", ")", ")", "{", "queue", "=", "new", "SpscArrayQueue", "<", "T", ">", "(", "bufferSize", ")", ";", "}", "}"], "docstring": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "docstring_tokens": ["Initializes", "this", "Processor", "by", "setting", "an", "upstream", "Subscription", "that", "ignores", "request", "amounts", "uses", "a", "fixed", "buffer", "and", "allows", "using", "the", "onXXX", "and", "offer", "methods", "afterwards", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/MulticastProcessor.java#L241-L245", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/MulticastProcessor.java", "func_name": "MulticastProcessor.startUnbounded", "original_string": "public void startUnbounded() {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscLinkedArrayQueue<T>(bufferSize);\n        }\n    }", "language": "java", "code": "public void startUnbounded() {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscLinkedArrayQueue<T>(bufferSize);\n        }\n    }", "code_tokens": ["public", "void", "startUnbounded", "(", ")", "{", "if", "(", "SubscriptionHelper", ".", "setOnce", "(", "upstream", ",", "EmptySubscription", ".", "INSTANCE", ")", ")", "{", "queue", "=", "new", "SpscLinkedArrayQueue", "<", "T", ">", "(", "bufferSize", ")", ";", "}", "}"], "docstring": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "docstring_tokens": ["Initializes", "this", "Processor", "by", "setting", "an", "upstream", "Subscription", "that", "ignores", "request", "amounts", "uses", "an", "unbounded", "buffer", "and", "allows", "using", "the", "onXXX", "and", "offer", "methods", "afterwards", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/MulticastProcessor.java#L253-L257", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/MulticastProcessor.java", "func_name": "MulticastProcessor.offer", "original_string": "public boolean offer(T t) {\n        if (once.get()) {\n            return false;\n        }\n        ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\");\n        if (fusionMode == QueueSubscription.NONE) {\n            if (queue.offer(t)) {\n                drain();\n                return true;\n            }\n        }\n        return false;\n    }", "language": "java", "code": "public boolean offer(T t) {\n        if (once.get()) {\n            return false;\n        }\n        ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\");\n        if (fusionMode == QueueSubscription.NONE) {\n            if (queue.offer(t)) {\n                drain();\n                return true;\n            }\n        }\n        return false;\n    }", "code_tokens": ["public", "boolean", "offer", "(", "T", "t", ")", "{", "if", "(", "once", ".", "get", "(", ")", ")", "{", "return", "false", ";", "}", "ObjectHelper", ".", "requireNonNull", "(", "t", ",", "\"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"", ")", ";", "if", "(", "fusionMode", "==", "QueueSubscription", ".", "NONE", ")", "{", "if", "(", "queue", ".", "offer", "(", "t", ")", ")", "{", "drain", "(", ")", ";", "return", "true", ";", "}", "}", "return", "false", ";", "}"], "docstring": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "docstring_tokens": ["Tries", "to", "offer", "an", "item", "into", "the", "internal", "queue", "and", "returns", "false", "if", "the", "queue", "is", "full", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/MulticastProcessor.java#L311-L323", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/disposables/SerialDisposable.java", "func_name": "SerialDisposable.get", "original_string": "@Nullable\n    public Disposable get() {\n        Disposable d = resource.get();\n        if (d == DisposableHelper.DISPOSED) {\n            return Disposables.disposed();\n        }\n        return d;\n    }", "language": "java", "code": "@Nullable\n    public Disposable get() {\n        Disposable d = resource.get();\n        if (d == DisposableHelper.DISPOSED) {\n            return Disposables.disposed();\n        }\n        return d;\n    }", "code_tokens": ["@", "Nullable", "public", "Disposable", "get", "(", ")", "{", "Disposable", "d", "=", "resource", ".", "get", "(", ")", ";", "if", "(", "d", "==", "DisposableHelper", ".", "DISPOSED", ")", "{", "return", "Disposables", ".", "disposed", "(", ")", ";", "}", "return", "d", ";", "}"], "docstring": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "docstring_tokens": ["Returns", "the", "currently", "contained", "Disposable", "or", "null", "if", "this", "container", "is", "empty", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/disposables/SerialDisposable.java#L70-L77", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java", "func_name": "DeferredScalarDisposable.complete", "original_string": "public final void complete(T value) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        Observer<? super T> a = downstream;\n        if (state == FUSED_EMPTY) {\n            this.value = value;\n            lazySet(FUSED_READY);\n            a.onNext(null);\n        } else {\n            lazySet(TERMINATED);\n            a.onNext(value);\n        }\n        if (get() != DISPOSED) {\n            a.onComplete();\n        }\n    }", "language": "java", "code": "public final void complete(T value) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        Observer<? super T> a = downstream;\n        if (state == FUSED_EMPTY) {\n            this.value = value;\n            lazySet(FUSED_READY);\n            a.onNext(null);\n        } else {\n            lazySet(TERMINATED);\n            a.onNext(value);\n        }\n        if (get() != DISPOSED) {\n            a.onComplete();\n        }\n    }", "code_tokens": ["public", "final", "void", "complete", "(", "T", "value", ")", "{", "int", "state", "=", "get", "(", ")", ";", "if", "(", "(", "state", "&", "(", "FUSED_READY", "|", "FUSED_CONSUMED", "|", "TERMINATED", "|", "DISPOSED", ")", ")", "!=", "0", ")", "{", "return", ";", "}", "Observer", "<", "?", "super", "T", ">", "a", "=", "downstream", ";", "if", "(", "state", "==", "FUSED_EMPTY", ")", "{", "this", ".", "value", "=", "value", ";", "lazySet", "(", "FUSED_READY", ")", ";", "a", ".", "onNext", "(", "null", ")", ";", "}", "else", "{", "lazySet", "(", "TERMINATED", ")", ";", "a", ".", "onNext", "(", "value", ")", ";", "}", "if", "(", "get", "(", ")", "!=", "DISPOSED", ")", "{", "a", ".", "onComplete", "(", ")", ";", "}", "}"], "docstring": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "docstring_tokens": ["Complete", "the", "target", "with", "a", "single", "value", "or", "indicate", "there", "is", "a", "value", "available", "in", "fusion", "mode", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java#L70-L87", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java", "func_name": "DeferredScalarDisposable.error", "original_string": "public final void error(Throwable t) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            RxJavaPlugins.onError(t);\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onError(t);\n    }", "language": "java", "code": "public final void error(Throwable t) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            RxJavaPlugins.onError(t);\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onError(t);\n    }", "code_tokens": ["public", "final", "void", "error", "(", "Throwable", "t", ")", "{", "int", "state", "=", "get", "(", ")", ";", "if", "(", "(", "state", "&", "(", "FUSED_READY", "|", "FUSED_CONSUMED", "|", "TERMINATED", "|", "DISPOSED", ")", ")", "!=", "0", ")", "{", "RxJavaPlugins", ".", "onError", "(", "t", ")", ";", "return", ";", "}", "lazySet", "(", "TERMINATED", ")", ";", "downstream", ".", "onError", "(", "t", ")", ";", "}"], "docstring": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "docstring_tokens": ["Complete", "the", "target", "with", "an", "error", "signal", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java#L93-L101", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java", "func_name": "DeferredScalarDisposable.complete", "original_string": "public final void complete() {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onComplete();\n    }", "language": "java", "code": "public final void complete() {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onComplete();\n    }", "code_tokens": ["public", "final", "void", "complete", "(", ")", "{", "int", "state", "=", "get", "(", ")", ";", "if", "(", "(", "state", "&", "(", "FUSED_READY", "|", "FUSED_CONSUMED", "|", "TERMINATED", "|", "DISPOSED", ")", ")", "!=", "0", ")", "{", "return", ";", "}", "lazySet", "(", "TERMINATED", ")", ";", "downstream", ".", "onComplete", "(", ")", ";", "}"], "docstring": "Complete the target without any value.", "docstring_tokens": ["Complete", "the", "target", "without", "any", "value", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java#L106-L113", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Flowable.java", "func_name": "Flowable.concatMapDelayError", "original_string": "@CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }", "language": "java", "code": "@CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        return concatMapDelayError(mapper, 2, true);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "<", "R", ">", "Flowable", "<", "R", ">", "concatMapDelayError", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "Publisher", "<", "?", "extends", "R", ">", ">", "mapper", ")", "{", "return", "concatMapDelayError", "(", "mapper", ",", "2", ",", "true", ")", ";", "}"], "docstring": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that <em>may</em> throw an {@code IllegalStateException} when that\n{@code Publisher} completes.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <R> the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "docstring_tokens": ["Maps", "each", "of", "the", "items", "into", "a", "Publisher", "subscribes", "to", "them", "one", "after", "the", "other", "one", "at", "a", "time", "and", "emits", "their", "values", "in", "order", "while", "delaying", "any", "error", "from", "either", "this", "or", "any", "of", "the", "inner", "Publishers", "till", "all", "of", "them", "terminate", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Flowable.java#L7421-L7426", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Flowable.java", "func_name": "Flowable.concatMapIterable", "original_string": "@CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }", "language": "java", "code": "@CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "<", "U", ">", "Flowable", "<", "U", ">", "concatMapIterable", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "Iterable", "<", "?", "extends", "U", ">", ">", "mapper", ")", "{", "return", "concatMapIterable", "(", "mapper", ",", "2", ")", ";", "}"], "docstring": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <U>\nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>", "docstring_tokens": ["Returns", "a", "Flowable", "that", "concatenate", "each", "item", "emitted", "by", "the", "source", "Publisher", "with", "the", "values", "in", "an", "Iterable", "corresponding", "to", "that", "item", "that", "is", "generated", "by", "a", "selector", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Flowable.java#L7626-L7631", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Flowable.java", "func_name": "Flowable.sorted", "original_string": "@CheckReturnValue\n    @NonNull\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction\");\n        return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Flowable", "<", "T", ">", "sorted", "(", "Comparator", "<", "?", "super", "T", ">", "sortFunction", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sortFunction", ",", "\"sortFunction\"", ")", ";", "return", "toList", "(", ")", ".", "toFlowable", "(", ")", ".", "map", "(", "Functions", ".", "listSorter", "(", "sortFunction", ")", ")", ".", "flatMapIterable", "(", "Functions", ".", "<", "List", "<", "T", ">", ">", "identity", "(", ")", ")", ";", "}"], "docstring": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\n<p>Note that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "docstring_tokens": ["Returns", "a", "Flowable", "that", "emits", "the", "events", "emitted", "by", "source", "Publisher", "in", "a", "sorted", "order", "based", "on", "a", "specified", "comparison", "function", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Flowable.java#L14471-L14478", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/jmh/java/io/reactivex/PerfAsyncConsumer.java", "func_name": "PerfAsyncConsumer.await", "original_string": "public PerfAsyncConsumer await(int count) {\n        if (count <= 1000) {\n            while (getCount() != 0) { }\n        } else {\n            try {\n                await();\n            } catch (InterruptedException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return this;\n    }", "language": "java", "code": "public PerfAsyncConsumer await(int count) {\n        if (count <= 1000) {\n            while (getCount() != 0) { }\n        } else {\n            try {\n                await();\n            } catch (InterruptedException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n        return this;\n    }", "code_tokens": ["public", "PerfAsyncConsumer", "await", "(", "int", "count", ")", "{", "if", "(", "count", "<=", "1000", ")", "{", "while", "(", "getCount", "(", ")", "!=", "0", ")", "{", "}", "}", "else", "{", "try", "{", "await", "(", ")", ";", "}", "catch", "(", "InterruptedException", "ex", ")", "{", "throw", "new", "RuntimeException", "(", "ex", ")", ";", "}", "}", "return", "this", ";", "}"], "docstring": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "docstring_tokens": ["Wait", "for", "the", "terminal", "signal", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/jmh/java/io/reactivex/PerfAsyncConsumer.java#L73-L84", "partition": "test"}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/subscribers/DefaultSubscriber.java", "func_name": "DefaultSubscriber.request", "original_string": "protected final void request(long n) {\n        Subscription s = this.upstream;\n        if (s != null) {\n            s.request(n);\n        }\n    }", "language": "java", "code": "protected final void request(long n) {\n        Subscription s = this.upstream;\n        if (s != null) {\n            s.request(n);\n        }\n    }", "code_tokens": ["protected", "final", "void", "request", "(", "long", "n", ")", "{", "Subscription", "s", "=", "this", ".", "upstream", ";", "if", "(", "s", "!=", "null", ")", "{", "s", ".", "request", "(", "n", ")", ";", "}", "}"], "docstring": "Requests from the upstream Subscription.\n@param n the request amount, positive", "docstring_tokens": ["Requests", "from", "the", "upstream", "Subscription", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/subscribers/DefaultSubscriber.java#L91-L96", "partition": "test"}
