{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.copyTo", "original_string": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "public", "long", "copyTo", "(", "CharSink", "sink", ")", "throws", "IOException", "{", "checkNotNull", "(", "sink", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "Writer", "writer", "=", "closer", ".", "register", "(", "sink", ".", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "copy", "(", "reader", ",", "writer", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Copies the contents of this source to the given sink.\n\n@return the number of characters copied\n@throws IOException if an I/O error occurs while reading from this source or writing to {@code\nsink}", "docstring_tokens": ["Copies", "the", "contents", "of", "this", "source", "to", "the", "given", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L208-L222", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.read", "original_string": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "String", "read", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "toString", "(", "reader", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads the contents of this source as a string.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "the", "contents", "of", "this", "source", "as", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L229-L239", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.readLines", "original_string": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "ImmutableList", "<", "String", ">", "readLines", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "BufferedReader", "reader", "=", "closer", ".", "register", "(", "openBufferedStream", "(", ")", ")", ";", "List", "<", "String", ">", "result", "=", "Lists", ".", "newArrayList", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "add", "(", "line", ")", ";", "}", "return", "ImmutableList", ".", "copyOf", "(", "result", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads all the lines of this source as a list of strings. The returned list will be empty if\nthis source is empty.\n\n<p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of\ntext that is terminated by (but does not include) one of {@code \\r\\n}, {@code \\r} or {@code\n\\n}. If the source's content does not end in a line termination sequence, it is treated as if\nit does.\n\n@throws IOException if an I/O error occurs while reading from this source", "docstring_tokens": ["Reads", "all", "the", "lines", "of", "this", "source", "as", "a", "list", "of", "strings", ".", "The", "returned", "list", "will", "be", "empty", "if", "this", "source", "is", "empty", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L275-L290", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.read", "original_string": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "language": "java", "code": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "code_tokens": ["@", "Override", "public", "int", "read", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Obey InputStream contract.", "checkPositionIndexes", "(", "off", ",", "off", "+", "len", ",", "b", ".", "length", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "// The rest of this method implements the process described by the CharsetEncoder javadoc.", "int", "totalBytesRead", "=", "0", ";", "boolean", "doneEncoding", "=", "endOfInput", ";", "DRAINING", ":", "while", "(", "true", ")", "{", "// We stay in draining mode until there are no bytes left in the output buffer. Then we go", "// back to encoding/flushing.", "if", "(", "draining", ")", "{", "totalBytesRead", "+=", "drain", "(", "b", ",", "off", "+", "totalBytesRead", ",", "len", "-", "totalBytesRead", ")", ";", "if", "(", "totalBytesRead", "==", "len", "||", "doneFlushing", ")", "{", "return", "(", "totalBytesRead", ">", "0", ")", "?", "totalBytesRead", ":", "-", "1", ";", "}", "draining", "=", "false", ";", "byteBuffer", ".", "clear", "(", ")", ";", "}", "while", "(", "true", ")", "{", "// We call encode until there is no more input. The last call to encode will have endOfInput", "// == true. Then there is a final call to flush.", "CoderResult", "result", ";", "if", "(", "doneFlushing", ")", "{", "result", "=", "CoderResult", ".", "UNDERFLOW", ";", "}", "else", "if", "(", "doneEncoding", ")", "{", "result", "=", "encoder", ".", "flush", "(", "byteBuffer", ")", ";", "}", "else", "{", "result", "=", "encoder", ".", "encode", "(", "charBuffer", ",", "byteBuffer", ",", "endOfInput", ")", ";", "}", "if", "(", "result", ".", "isOverflow", "(", ")", ")", "{", "// Not enough room in output buffer--drain it, creating a bigger buffer if necessary.", "startDraining", "(", "true", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "result", ".", "isUnderflow", "(", ")", ")", "{", "// If encoder underflows, it means either:", "// a) the final flush() succeeded; next drain (then done)", "// b) we encoded all of the input; next flush", "// c) we ran of out input to encode; next read more input", "if", "(", "doneEncoding", ")", "{", "// (a)", "doneFlushing", "=", "true", ";", "startDraining", "(", "false", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "endOfInput", ")", "{", "// (b)", "doneEncoding", "=", "true", ";", "}", "else", "{", "// (c)", "readMoreChars", "(", ")", ";", "}", "}", "else", "if", "(", "result", ".", "isError", "(", ")", ")", "{", "// Only reach here if a CharsetEncoder with non-REPLACE settings is used.", "result", ".", "throwException", "(", ")", ";", "return", "0", ";", "// Not called.", "}", "}", "}", "}"], "docstring": "buffer when possible.", "docstring_tokens": ["buffer", "when", "possible", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L124-L186", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.grow", "original_string": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "language": "java", "code": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "code_tokens": ["private", "static", "CharBuffer", "grow", "(", "CharBuffer", "buf", ")", "{", "char", "[", "]", "copy", "=", "Arrays", ".", "copyOf", "(", "buf", ".", "array", "(", ")", ",", "buf", ".", "capacity", "(", ")", "*", "2", ")", ";", "CharBuffer", "bigger", "=", "CharBuffer", ".", "wrap", "(", "copy", ")", ";", "bigger", ".", "position", "(", "buf", ".", "position", "(", ")", ")", ";", "bigger", ".", "limit", "(", "buf", ".", "limit", "(", ")", ")", ";", "return", "bigger", ";", "}"], "docstring": "Returns a new CharBuffer identical to buf, except twice the capacity.", "docstring_tokens": ["Returns", "a", "new", "CharBuffer", "identical", "to", "buf", "except", "twice", "the", "capacity", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L189-L195", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.readMoreChars", "original_string": "private void readMoreChars() throws IOException {\n    // Possibilities:\n    // 1) array has space available on right hand side (between limit and capacity)\n    // 2) array has space available on left hand side (before position)\n    // 3) array has no space available\n    //\n    // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n    // array, then they both become case 1.\n\n    if (availableCapacity(charBuffer) == 0) {\n      if (charBuffer.position() > 0) {\n        // (2) There is room in the buffer. Move existing bytes to the beginning.\n        charBuffer.compact().flip();\n      } else {\n        // (3) Entire buffer is full, need bigger buffer.\n        charBuffer = grow(charBuffer);\n      }\n    }\n\n    // (1) Read more characters into free space at end of array.\n    int limit = charBuffer.limit();\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n    if (numChars == -1) {\n      endOfInput = true;\n    } else {\n      charBuffer.limit(limit + numChars);\n    }\n  }", "language": "java", "code": "private void readMoreChars() throws IOException {\n    // Possibilities:\n    // 1) array has space available on right hand side (between limit and capacity)\n    // 2) array has space available on left hand side (before position)\n    // 3) array has no space available\n    //\n    // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n    // array, then they both become case 1.\n\n    if (availableCapacity(charBuffer) == 0) {\n      if (charBuffer.position() > 0) {\n        // (2) There is room in the buffer. Move existing bytes to the beginning.\n        charBuffer.compact().flip();\n      } else {\n        // (3) Entire buffer is full, need bigger buffer.\n        charBuffer = grow(charBuffer);\n      }\n    }\n\n    // (1) Read more characters into free space at end of array.\n    int limit = charBuffer.limit();\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n    if (numChars == -1) {\n      endOfInput = true;\n    } else {\n      charBuffer.limit(limit + numChars);\n    }\n  }", "code_tokens": ["private", "void", "readMoreChars", "(", ")", "throws", "IOException", "{", "// Possibilities:", "// 1) array has space available on right hand side (between limit and capacity)", "// 2) array has space available on left hand side (before position)", "// 3) array has no space available", "//", "// In case 2 we shift the existing chars to the left, and in case 3 we create a bigger", "// array, then they both become case 1.", "if", "(", "availableCapacity", "(", "charBuffer", ")", "==", "0", ")", "{", "if", "(", "charBuffer", ".", "position", "(", ")", ">", "0", ")", "{", "// (2) There is room in the buffer. Move existing bytes to the beginning.", "charBuffer", ".", "compact", "(", ")", ".", "flip", "(", ")", ";", "}", "else", "{", "// (3) Entire buffer is full, need bigger buffer.", "charBuffer", "=", "grow", "(", "charBuffer", ")", ";", "}", "}", "// (1) Read more characters into free space at end of array.", "int", "limit", "=", "charBuffer", ".", "limit", "(", ")", ";", "int", "numChars", "=", "reader", ".", "read", "(", "charBuffer", ".", "array", "(", ")", ",", "limit", ",", "availableCapacity", "(", "charBuffer", ")", ")", ";", "if", "(", "numChars", "==", "-", "1", ")", "{", "endOfInput", "=", "true", ";", "}", "else", "{", "charBuffer", ".", "limit", "(", "limit", "+", "numChars", ")", ";", "}", "}"], "docstring": "Handle the case of underflow caused by needing more input characters.", "docstring_tokens": ["Handle", "the", "case", "of", "underflow", "caused", "by", "needing", "more", "input", "characters", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L198-L225", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.startDraining", "original_string": "private void startDraining(boolean overflow) {\n    byteBuffer.flip();\n    if (overflow && byteBuffer.remaining() == 0) {\n      byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n    } else {\n      draining = true;\n    }\n  }", "language": "java", "code": "private void startDraining(boolean overflow) {\n    byteBuffer.flip();\n    if (overflow && byteBuffer.remaining() == 0) {\n      byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n    } else {\n      draining = true;\n    }\n  }", "code_tokens": ["private", "void", "startDraining", "(", "boolean", "overflow", ")", "{", "byteBuffer", ".", "flip", "(", ")", ";", "if", "(", "overflow", "&&", "byteBuffer", ".", "remaining", "(", ")", "==", "0", ")", "{", "byteBuffer", "=", "ByteBuffer", ".", "allocate", "(", "byteBuffer", ".", "capacity", "(", ")", "*", "2", ")", ";", "}", "else", "{", "draining", "=", "true", ";", "}", "}"], "docstring": "Flips the buffer output buffer so we can start reading bytes from it. If we are starting to\ndrain because there was overflow, and there aren't actually any characters to drain, then the\noverflow must be due to a small output buffer.", "docstring_tokens": ["Flips", "the", "buffer", "output", "buffer", "so", "we", "can", "start", "reading", "bytes", "from", "it", ".", "If", "we", "are", "starting", "to", "drain", "because", "there", "was", "overflow", "and", "there", "aren", "t", "actually", "any", "characters", "to", "drain", "then", "the", "overflow", "must", "be", "due", "to", "a", "small", "output", "buffer", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L237-L244", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toArray", "original_string": "@GwtIncompatible // Array.newInstance(Class, int)\n  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {\n    return toArray(iterable, ObjectArrays.newArray(type, 0));\n  }", "language": "java", "code": "@GwtIncompatible // Array.newInstance(Class, int)\n  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {\n    return toArray(iterable, ObjectArrays.newArray(type, 0));\n  }", "code_tokens": ["@", "GwtIncompatible", "// Array.newInstance(Class, int)", "public", "static", "<", "T", ">", "T", "[", "]", "toArray", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "Class", "<", "T", ">", "type", ")", "{", "return", "toArray", "(", "iterable", ",", "ObjectArrays", ".", "newArray", "(", "type", ",", "0", ")", ")", ";", "}"], "docstring": "Copies an iterable's elements into an array.\n\n@param iterable the iterable to copy\n@param type the type of the elements\n@return a newly-allocated array into which all the elements of the iterable have been copied", "docstring_tokens": ["Copies", "an", "iterable", "s", "elements", "into", "an", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L316-L319", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.isEmpty", "original_string": "public static boolean isEmpty(Iterable<?> iterable) {\n    if (iterable instanceof Collection) {\n      return ((Collection<?>) iterable).isEmpty();\n    }\n    return !iterable.iterator().hasNext();\n  }", "language": "java", "code": "public static boolean isEmpty(Iterable<?> iterable) {\n    if (iterable instanceof Collection) {\n      return ((Collection<?>) iterable).isEmpty();\n    }\n    return !iterable.iterator().hasNext();\n  }", "code_tokens": ["public", "static", "boolean", "isEmpty", "(", "Iterable", "<", "?", ">", "iterable", ")", "{", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "isEmpty", "(", ")", ";", "}", "return", "!", "iterable", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ";", "}"], "docstring": "Determines if the given iterable contains no elements.\n\n<p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an\niterator whether it has any elements <i>remaining</i> (which one does using {@link\nIterator#hasNext}).\n\n<p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}\n\n@return {@code true} if the iterable contains no elements", "docstring_tokens": ["Determines", "if", "the", "given", "iterable", "contains", "no", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L980-L985", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toIterator", "original_string": "static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n      @Override\n      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n        return iterable.iterator();\n      }\n    };\n  }", "language": "java", "code": "static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n      @Override\n      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n        return iterable.iterator();\n      }\n    };\n  }", "code_tokens": ["static", "<", "T", ">", "Function", "<", "Iterable", "<", "?", "extends", "T", ">", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "toIterator", "(", ")", "{", "return", "new", "Function", "<", "Iterable", "<", "?", "extends", "T", ">", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "(", ")", "{", "@", "Override", "public", "Iterator", "<", "?", "extends", "T", ">", "apply", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ")", "{", "return", "iterable", ".", "iterator", "(", ")", ";", "}", "}", ";", "}"], "docstring": "Useful as a public method?", "docstring_tokens": ["Useful", "as", "a", "public", "method?"], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L1018-L1025", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.consumingForArray", "original_string": "private static <T> Iterator<T> consumingForArray(final T... elements) {\n    return new UnmodifiableIterator<T>() {\n      int index = 0;\n\n      @Override\n      public boolean hasNext() {\n        return index < elements.length;\n      }\n\n      @Override\n      public T next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        T result = elements[index];\n        elements[index] = null;\n        index++;\n        return result;\n      }\n    };\n  }", "language": "java", "code": "private static <T> Iterator<T> consumingForArray(final T... elements) {\n    return new UnmodifiableIterator<T>() {\n      int index = 0;\n\n      @Override\n      public boolean hasNext() {\n        return index < elements.length;\n      }\n\n      @Override\n      public T next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        T result = elements[index];\n        elements[index] = null;\n        index++;\n        return result;\n      }\n    };\n  }", "code_tokens": ["private", "static", "<", "T", ">", "Iterator", "<", "T", ">", "consumingForArray", "(", "final", "T", "...", "elements", ")", "{", "return", "new", "UnmodifiableIterator", "<", "T", ">", "(", ")", "{", "int", "index", "=", "0", ";", "@", "Override", "public", "boolean", "hasNext", "(", ")", "{", "return", "index", "<", "elements", ".", "length", ";", "}", "@", "Override", "public", "T", "next", "(", ")", "{", "if", "(", "!", "hasNext", "(", ")", ")", "{", "throw", "new", "NoSuchElementException", "(", ")", ";", "}", "T", "result", "=", "elements", "[", "index", "]", ";", "elements", "[", "index", "]", "=", "null", ";", "index", "++", ";", "return", "result", ";", "}", "}", ";", "}"], "docstring": "Returns an Iterator that walks the specified array, nulling out elements behind it. This can\navoid memory leaks when an element is no longer necessary.\n\n<p>This is mainly just to avoid the intermediate ArrayDeque in ConsumingQueueIterator.", "docstring_tokens": ["Returns", "an", "Iterator", "that", "walks", "the", "specified", "array", "nulling", "out", "elements", "behind", "it", ".", "This", "can", "avoid", "memory", "leaks", "when", "an", "element", "is", "no", "longer", "necessary", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L449-L469", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.concatNoDefensiveCopy", "original_string": "static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs) {\n    for (Iterator<? extends T> input : checkNotNull(inputs)) {\n      checkNotNull(input);\n    }\n    return concat(consumingForArray(inputs));\n  }", "language": "java", "code": "static <T> Iterator<T> concatNoDefensiveCopy(Iterator<? extends T>... inputs) {\n    for (Iterator<? extends T> input : checkNotNull(inputs)) {\n      checkNotNull(input);\n    }\n    return concat(consumingForArray(inputs));\n  }", "code_tokens": ["static", "<", "T", ">", "Iterator", "<", "T", ">", "concatNoDefensiveCopy", "(", "Iterator", "<", "?", "extends", "T", ">", "...", "inputs", ")", "{", "for", "(", "Iterator", "<", "?", "extends", "T", ">", "input", ":", "checkNotNull", "(", "inputs", ")", ")", "{", "checkNotNull", "(", "input", ")", ";", "}", "return", "concat", "(", "consumingForArray", "(", "inputs", ")", ")", ";", "}"], "docstring": "Concats a varargs array of iterators without making a defensive copy of the array.", "docstring_tokens": ["Concats", "a", "varargs", "array", "of", "iterators", "without", "making", "a", "defensive", "copy", "of", "the", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L550-L555", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterators.java", "func_name": "Iterators.clear", "original_string": "static void clear(Iterator<?> iterator) {\n    checkNotNull(iterator);\n    while (iterator.hasNext()) {\n      iterator.next();\n      iterator.remove();\n    }\n  }", "language": "java", "code": "static void clear(Iterator<?> iterator) {\n    checkNotNull(iterator);\n    while (iterator.hasNext()) {\n      iterator.next();\n      iterator.remove();\n    }\n  }", "code_tokens": ["static", "void", "clear", "(", "Iterator", "<", "?", ">", "iterator", ")", "{", "checkNotNull", "(", "iterator", ")", ";", "while", "(", "iterator", ".", "hasNext", "(", ")", ")", "{", "iterator", ".", "next", "(", ")", ";", "iterator", ".", "remove", "(", ")", ";", "}", "}"], "docstring": "Clears the iterator using its remove method.", "docstring_tokens": ["Clears", "the", "iterator", "using", "its", "remove", "method", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterators.java#L988-L994", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ByteSink.java", "func_name": "ByteSink.write", "original_string": "public void write(byte[] bytes) throws IOException {\n    checkNotNull(bytes);\n\n    Closer closer = Closer.create();\n    try {\n      OutputStream out = closer.register(openStream());\n      out.write(bytes);\n      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public void write(byte[] bytes) throws IOException {\n    checkNotNull(bytes);\n\n    Closer closer = Closer.create();\n    try {\n      OutputStream out = closer.register(openStream());\n      out.write(bytes);\n      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "void", "write", "(", "byte", "[", "]", "bytes", ")", "throws", "IOException", "{", "checkNotNull", "(", "bytes", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "OutputStream", "out", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "out", ".", "write", "(", "bytes", ")", ";", "out", ".", "flush", "(", ")", ";", "// https://code.google.com/p/guava-libraries/issues/detail?id=1330", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Writes all the given bytes to this sink.\n\n@throws IOException if an I/O occurs while writing to this sink", "docstring_tokens": ["Writes", "all", "the", "given", "bytes", "to", "this", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ByteSink.java#L96-L109", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilderSpec.java", "func_name": "CacheBuilderSpec.parse", "original_string": "public static CacheBuilderSpec parse(String cacheBuilderSpecification) {\n    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n    if (!cacheBuilderSpecification.isEmpty()) {\n      for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n        List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));\n        checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");\n        checkArgument(\n            keyAndValue.size() <= 2,\n            \"key-value pair %s with more than one equals sign\",\n            keyValuePair);\n\n        // Find the ValueParser for the current key.\n        String key = keyAndValue.get(0);\n        ValueParser valueParser = VALUE_PARSERS.get(key);\n        checkArgument(valueParser != null, \"unknown key %s\", key);\n\n        String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);\n        valueParser.parse(spec, key, value);\n      }\n    }\n\n    return spec;\n  }", "language": "java", "code": "public static CacheBuilderSpec parse(String cacheBuilderSpecification) {\n    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n    if (!cacheBuilderSpecification.isEmpty()) {\n      for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n        List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));\n        checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");\n        checkArgument(\n            keyAndValue.size() <= 2,\n            \"key-value pair %s with more than one equals sign\",\n            keyValuePair);\n\n        // Find the ValueParser for the current key.\n        String key = keyAndValue.get(0);\n        ValueParser valueParser = VALUE_PARSERS.get(key);\n        checkArgument(valueParser != null, \"unknown key %s\", key);\n\n        String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);\n        valueParser.parse(spec, key, value);\n      }\n    }\n\n    return spec;\n  }", "code_tokens": ["public", "static", "CacheBuilderSpec", "parse", "(", "String", "cacheBuilderSpecification", ")", "{", "CacheBuilderSpec", "spec", "=", "new", "CacheBuilderSpec", "(", "cacheBuilderSpecification", ")", ";", "if", "(", "!", "cacheBuilderSpecification", ".", "isEmpty", "(", ")", ")", "{", "for", "(", "String", "keyValuePair", ":", "KEYS_SPLITTER", ".", "split", "(", "cacheBuilderSpecification", ")", ")", "{", "List", "<", "String", ">", "keyAndValue", "=", "ImmutableList", ".", "copyOf", "(", "KEY_VALUE_SPLITTER", ".", "split", "(", "keyValuePair", ")", ")", ";", "checkArgument", "(", "!", "keyAndValue", ".", "isEmpty", "(", ")", ",", "\"blank key-value pair\"", ")", ";", "checkArgument", "(", "keyAndValue", ".", "size", "(", ")", "<=", "2", ",", "\"key-value pair %s with more than one equals sign\"", ",", "keyValuePair", ")", ";", "// Find the ValueParser for the current key.", "String", "key", "=", "keyAndValue", ".", "get", "(", "0", ")", ";", "ValueParser", "valueParser", "=", "VALUE_PARSERS", ".", "get", "(", "key", ")", ";", "checkArgument", "(", "valueParser", "!=", "null", ",", "\"unknown key %s\"", ",", "key", ")", ";", "String", "value", "=", "keyAndValue", ".", "size", "(", ")", "==", "1", "?", "null", ":", "keyAndValue", ".", "get", "(", "1", ")", ";", "valueParser", ".", "parse", "(", "spec", ",", "key", ",", "value", ")", ";", "}", "}", "return", "spec", ";", "}"], "docstring": "Creates a CacheBuilderSpec from a string.\n\n@param cacheBuilderSpecification the string form", "docstring_tokens": ["Creates", "a", "CacheBuilderSpec", "from", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilderSpec.java#L136-L158", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/cache/CacheBuilderSpec.java", "func_name": "CacheBuilderSpec.toCacheBuilder", "original_string": "CacheBuilder<Object, Object> toCacheBuilder() {\n    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n    if (initialCapacity != null) {\n      builder.initialCapacity(initialCapacity);\n    }\n    if (maximumSize != null) {\n      builder.maximumSize(maximumSize);\n    }\n    if (maximumWeight != null) {\n      builder.maximumWeight(maximumWeight);\n    }\n    if (concurrencyLevel != null) {\n      builder.concurrencyLevel(concurrencyLevel);\n    }\n    if (keyStrength != null) {\n      switch (keyStrength) {\n        case WEAK:\n          builder.weakKeys();\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    if (valueStrength != null) {\n      switch (valueStrength) {\n        case SOFT:\n          builder.softValues();\n          break;\n        case WEAK:\n          builder.weakValues();\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    if (recordStats != null && recordStats) {\n      builder.recordStats();\n    }\n    if (writeExpirationTimeUnit != null) {\n      builder.expireAfterWrite(writeExpirationDuration, writeExpirationTimeUnit);\n    }\n    if (accessExpirationTimeUnit != null) {\n      builder.expireAfterAccess(accessExpirationDuration, accessExpirationTimeUnit);\n    }\n    if (refreshTimeUnit != null) {\n      builder.refreshAfterWrite(refreshDuration, refreshTimeUnit);\n    }\n\n    return builder;\n  }", "language": "java", "code": "CacheBuilder<Object, Object> toCacheBuilder() {\n    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n    if (initialCapacity != null) {\n      builder.initialCapacity(initialCapacity);\n    }\n    if (maximumSize != null) {\n      builder.maximumSize(maximumSize);\n    }\n    if (maximumWeight != null) {\n      builder.maximumWeight(maximumWeight);\n    }\n    if (concurrencyLevel != null) {\n      builder.concurrencyLevel(concurrencyLevel);\n    }\n    if (keyStrength != null) {\n      switch (keyStrength) {\n        case WEAK:\n          builder.weakKeys();\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    if (valueStrength != null) {\n      switch (valueStrength) {\n        case SOFT:\n          builder.softValues();\n          break;\n        case WEAK:\n          builder.weakValues();\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    if (recordStats != null && recordStats) {\n      builder.recordStats();\n    }\n    if (writeExpirationTimeUnit != null) {\n      builder.expireAfterWrite(writeExpirationDuration, writeExpirationTimeUnit);\n    }\n    if (accessExpirationTimeUnit != null) {\n      builder.expireAfterAccess(accessExpirationDuration, accessExpirationTimeUnit);\n    }\n    if (refreshTimeUnit != null) {\n      builder.refreshAfterWrite(refreshDuration, refreshTimeUnit);\n    }\n\n    return builder;\n  }", "code_tokens": ["CacheBuilder", "<", "Object", ",", "Object", ">", "toCacheBuilder", "(", ")", "{", "CacheBuilder", "<", "Object", ",", "Object", ">", "builder", "=", "CacheBuilder", ".", "newBuilder", "(", ")", ";", "if", "(", "initialCapacity", "!=", "null", ")", "{", "builder", ".", "initialCapacity", "(", "initialCapacity", ")", ";", "}", "if", "(", "maximumSize", "!=", "null", ")", "{", "builder", ".", "maximumSize", "(", "maximumSize", ")", ";", "}", "if", "(", "maximumWeight", "!=", "null", ")", "{", "builder", ".", "maximumWeight", "(", "maximumWeight", ")", ";", "}", "if", "(", "concurrencyLevel", "!=", "null", ")", "{", "builder", ".", "concurrencyLevel", "(", "concurrencyLevel", ")", ";", "}", "if", "(", "keyStrength", "!=", "null", ")", "{", "switch", "(", "keyStrength", ")", "{", "case", "WEAK", ":", "builder", ".", "weakKeys", "(", ")", ";", "break", ";", "default", ":", "throw", "new", "AssertionError", "(", ")", ";", "}", "}", "if", "(", "valueStrength", "!=", "null", ")", "{", "switch", "(", "valueStrength", ")", "{", "case", "SOFT", ":", "builder", ".", "softValues", "(", ")", ";", "break", ";", "case", "WEAK", ":", "builder", ".", "weakValues", "(", ")", ";", "break", ";", "default", ":", "throw", "new", "AssertionError", "(", ")", ";", "}", "}", "if", "(", "recordStats", "!=", "null", "&&", "recordStats", ")", "{", "builder", ".", "recordStats", "(", ")", ";", "}", "if", "(", "writeExpirationTimeUnit", "!=", "null", ")", "{", "builder", ".", "expireAfterWrite", "(", "writeExpirationDuration", ",", "writeExpirationTimeUnit", ")", ";", "}", "if", "(", "accessExpirationTimeUnit", "!=", "null", ")", "{", "builder", ".", "expireAfterAccess", "(", "accessExpirationDuration", ",", "accessExpirationTimeUnit", ")", ";", "}", "if", "(", "refreshTimeUnit", "!=", "null", ")", "{", "builder", ".", "refreshAfterWrite", "(", "refreshDuration", ",", "refreshTimeUnit", ")", ";", "}", "return", "builder", ";", "}"], "docstring": "Returns a CacheBuilder configured according to this instance's specification.", "docstring_tokens": ["Returns", "a", "CacheBuilder", "configured", "according", "to", "this", "instance", "s", "specification", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/cache/CacheBuilderSpec.java#L167-L216", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/base/Joiner.java", "func_name": "Joiner.skipNulls", "original_string": "public Joiner skipNulls() {\n    return new Joiner(this) {\n      @Override\n      public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException {\n        checkNotNull(appendable, \"appendable\");\n        checkNotNull(parts, \"parts\");\n        while (parts.hasNext()) {\n          Object part = parts.next();\n          if (part != null) {\n            appendable.append(Joiner.this.toString(part));\n            break;\n          }\n        }\n        while (parts.hasNext()) {\n          Object part = parts.next();\n          if (part != null) {\n            appendable.append(separator);\n            appendable.append(Joiner.this.toString(part));\n          }\n        }\n        return appendable;\n      }\n\n      @Override\n      public Joiner useForNull(String nullText) {\n        throw new UnsupportedOperationException(\"already specified skipNulls\");\n      }\n\n      @Override\n      public MapJoiner withKeyValueSeparator(String kvs) {\n        throw new UnsupportedOperationException(\"can't use .skipNulls() with maps\");\n      }\n    };\n  }", "language": "java", "code": "public Joiner skipNulls() {\n    return new Joiner(this) {\n      @Override\n      public <A extends Appendable> A appendTo(A appendable, Iterator<?> parts) throws IOException {\n        checkNotNull(appendable, \"appendable\");\n        checkNotNull(parts, \"parts\");\n        while (parts.hasNext()) {\n          Object part = parts.next();\n          if (part != null) {\n            appendable.append(Joiner.this.toString(part));\n            break;\n          }\n        }\n        while (parts.hasNext()) {\n          Object part = parts.next();\n          if (part != null) {\n            appendable.append(separator);\n            appendable.append(Joiner.this.toString(part));\n          }\n        }\n        return appendable;\n      }\n\n      @Override\n      public Joiner useForNull(String nullText) {\n        throw new UnsupportedOperationException(\"already specified skipNulls\");\n      }\n\n      @Override\n      public MapJoiner withKeyValueSeparator(String kvs) {\n        throw new UnsupportedOperationException(\"can't use .skipNulls() with maps\");\n      }\n    };\n  }", "code_tokens": ["public", "Joiner", "skipNulls", "(", ")", "{", "return", "new", "Joiner", "(", "this", ")", "{", "@", "Override", "public", "<", "A", "extends", "Appendable", ">", "A", "appendTo", "(", "A", "appendable", ",", "Iterator", "<", "?", ">", "parts", ")", "throws", "IOException", "{", "checkNotNull", "(", "appendable", ",", "\"appendable\"", ")", ";", "checkNotNull", "(", "parts", ",", "\"parts\"", ")", ";", "while", "(", "parts", ".", "hasNext", "(", ")", ")", "{", "Object", "part", "=", "parts", ".", "next", "(", ")", ";", "if", "(", "part", "!=", "null", ")", "{", "appendable", ".", "append", "(", "Joiner", ".", "this", ".", "toString", "(", "part", ")", ")", ";", "break", ";", "}", "}", "while", "(", "parts", ".", "hasNext", "(", ")", ")", "{", "Object", "part", "=", "parts", ".", "next", "(", ")", ";", "if", "(", "part", "!=", "null", ")", "{", "appendable", ".", "append", "(", "separator", ")", ";", "appendable", ".", "append", "(", "Joiner", ".", "this", ".", "toString", "(", "part", ")", ")", ";", "}", "}", "return", "appendable", ";", "}", "@", "Override", "public", "Joiner", "useForNull", "(", "String", "nullText", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "\"already specified skipNulls\"", ")", ";", "}", "@", "Override", "public", "MapJoiner", "withKeyValueSeparator", "(", "String", "kvs", ")", "{", "throw", "new", "UnsupportedOperationException", "(", "\"can't use .skipNulls() with maps\"", ")", ";", "}", "}", ";", "}"], "docstring": "Returns a joiner with the same behavior as this joiner, except automatically skipping over any\nprovided null elements.", "docstring_tokens": ["Returns", "a", "joiner", "with", "the", "same", "behavior", "as", "this", "joiner", "except", "automatically", "skipping", "over", "any", "provided", "null", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/base/Joiner.java#L242-L275", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/primitives/ImmutableIntArray.java", "func_name": "ImmutableIntArray.of", "original_string": "public static ImmutableIntArray of(int first, int... rest) {\n    checkArgument(\n        rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n    int[] array = new int[rest.length + 1];\n    array[0] = first;\n    System.arraycopy(rest, 0, array, 1, rest.length);\n    return new ImmutableIntArray(array);\n  }", "language": "java", "code": "public static ImmutableIntArray of(int first, int... rest) {\n    checkArgument(\n        rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n    int[] array = new int[rest.length + 1];\n    array[0] = first;\n    System.arraycopy(rest, 0, array, 1, rest.length);\n    return new ImmutableIntArray(array);\n  }", "code_tokens": ["public", "static", "ImmutableIntArray", "of", "(", "int", "first", ",", "int", "...", "rest", ")", "{", "checkArgument", "(", "rest", ".", "length", "<=", "Integer", ".", "MAX_VALUE", "-", "1", ",", "\"the total number of elements must fit in an int\"", ")", ";", "int", "[", "]", "array", "=", "new", "int", "[", "rest", ".", "length", "+", "1", "]", ";", "array", "[", "0", "]", "=", "first", ";", "System", ".", "arraycopy", "(", "rest", ",", "0", ",", "array", ",", "1", ",", "rest", ".", "length", ")", ";", "return", "new", "ImmutableIntArray", "(", "array", ")", ";", "}"], "docstring": "okay since we have to copy the just-created array anyway.", "docstring_tokens": ["okay", "since", "we", "have", "to", "copy", "the", "just", "-", "created", "array", "anyway", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/primitives/ImmutableIntArray.java#L138-L145", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/primitives/ImmutableIntArray.java", "func_name": "ImmutableIntArray.subArray", "original_string": "public ImmutableIntArray subArray(int startIndex, int endIndex) {\n    Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n    return startIndex == endIndex\n        ? EMPTY\n        : new ImmutableIntArray(array, start + startIndex, start + endIndex);\n  }", "language": "java", "code": "public ImmutableIntArray subArray(int startIndex, int endIndex) {\n    Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n    return startIndex == endIndex\n        ? EMPTY\n        : new ImmutableIntArray(array, start + startIndex, start + endIndex);\n  }", "code_tokens": ["public", "ImmutableIntArray", "subArray", "(", "int", "startIndex", ",", "int", "endIndex", ")", "{", "Preconditions", ".", "checkPositionIndexes", "(", "startIndex", ",", "endIndex", ",", "length", "(", ")", ")", ";", "return", "startIndex", "==", "endIndex", "?", "EMPTY", ":", "new", "ImmutableIntArray", "(", "array", ",", "start", "+", "startIndex", ",", "start", "+", "endIndex", ")", ";", "}"], "docstring": "Returns a new immutable array containing the values in the specified range.\n\n<p><b>Performance note:</b> The returned array has the same full memory footprint as this one\ndoes (no actual copying is performed). To reduce memory usage, use {@code subArray(start,\nend).trimmed()}.", "docstring_tokens": ["Returns", "a", "new", "immutable", "array", "containing", "the", "values", "in", "the", "specified", "range", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/primitives/ImmutableIntArray.java#L436-L441", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/HashingInputStream.java", "func_name": "HashingInputStream.read", "original_string": "@Override\n  @CanIgnoreReturnValue\n  public int read() throws IOException {\n    int b = in.read();\n    if (b != -1) {\n      hasher.putByte((byte) b);\n    }\n    return b;\n  }", "language": "java", "code": "@Override\n  @CanIgnoreReturnValue\n  public int read() throws IOException {\n    int b = in.read();\n    if (b != -1) {\n      hasher.putByte((byte) b);\n    }\n    return b;\n  }", "code_tokens": ["@", "Override", "@", "CanIgnoreReturnValue", "public", "int", "read", "(", ")", "throws", "IOException", "{", "int", "b", "=", "in", ".", "read", "(", ")", ";", "if", "(", "b", "!=", "-", "1", ")", "{", "hasher", ".", "putByte", "(", "(", "byte", ")", "b", ")", ";", "}", "return", "b", ";", "}"], "docstring": "Reads the next byte of data from the underlying input stream and updates the hasher with the\nbyte read.", "docstring_tokens": ["Reads", "the", "next", "byte", "of", "data", "from", "the", "underlying", "input", "stream", "and", "updates", "the", "hasher", "with", "the", "byte", "read", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/HashingInputStream.java#L50-L58", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/HashingInputStream.java", "func_name": "HashingInputStream.read", "original_string": "@Override\n  @CanIgnoreReturnValue\n  public int read(byte[] bytes, int off, int len) throws IOException {\n    int numOfBytesRead = in.read(bytes, off, len);\n    if (numOfBytesRead != -1) {\n      hasher.putBytes(bytes, off, numOfBytesRead);\n    }\n    return numOfBytesRead;\n  }", "language": "java", "code": "@Override\n  @CanIgnoreReturnValue\n  public int read(byte[] bytes, int off, int len) throws IOException {\n    int numOfBytesRead = in.read(bytes, off, len);\n    if (numOfBytesRead != -1) {\n      hasher.putBytes(bytes, off, numOfBytesRead);\n    }\n    return numOfBytesRead;\n  }", "code_tokens": ["@", "Override", "@", "CanIgnoreReturnValue", "public", "int", "read", "(", "byte", "[", "]", "bytes", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "int", "numOfBytesRead", "=", "in", ".", "read", "(", "bytes", ",", "off", ",", "len", ")", ";", "if", "(", "numOfBytesRead", "!=", "-", "1", ")", "{", "hasher", ".", "putBytes", "(", "bytes", ",", "off", ",", "numOfBytesRead", ")", ";", "}", "return", "numOfBytesRead", ";", "}"], "docstring": "Reads the specified bytes of data from the underlying input stream and updates the hasher with\nthe bytes read.", "docstring_tokens": ["Reads", "the", "specified", "bytes", "of", "data", "from", "the", "underlying", "input", "stream", "and", "updates", "the", "hasher", "with", "the", "bytes", "read", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/HashingInputStream.java#L64-L72", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.writeMap", "original_string": "static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException {\n    stream.writeInt(map.size());\n    for (Map.Entry<K, V> entry : map.entrySet()) {\n      stream.writeObject(entry.getKey());\n      stream.writeObject(entry.getValue());\n    }\n  }", "language": "java", "code": "static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException {\n    stream.writeInt(map.size());\n    for (Map.Entry<K, V> entry : map.entrySet()) {\n      stream.writeObject(entry.getKey());\n      stream.writeObject(entry.getValue());\n    }\n  }", "code_tokens": ["static", "<", "K", ",", "V", ">", "void", "writeMap", "(", "Map", "<", "K", ",", "V", ">", "map", ",", "ObjectOutputStream", "stream", ")", "throws", "IOException", "{", "stream", ".", "writeInt", "(", "map", ".", "size", "(", ")", ")", ";", "for", "(", "Map", ".", "Entry", "<", "K", ",", "V", ">", "entry", ":", "map", ".", "entrySet", "(", ")", ")", "{", "stream", ".", "writeObject", "(", "entry", ".", "getKey", "(", ")", ")", ";", "stream", ".", "writeObject", "(", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}"], "docstring": "Stores the contents of a map in an output stream, as part of serialization. It does not support\nconcurrent maps whose content may change while the method is running.\n\n<p>The serialized output consists of the number of entries, first key, first value, second key,\nsecond value, and so on.", "docstring_tokens": ["Stores", "the", "contents", "of", "a", "map", "in", "an", "output", "stream", "as", "part", "of", "serialization", ".", "It", "does", "not", "support", "concurrent", "maps", "whose", "content", "may", "change", "while", "the", "method", "is", "running", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L57-L63", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.writeMultiset", "original_string": "static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n      throws IOException {\n    int entryCount = multiset.entrySet().size();\n    stream.writeInt(entryCount);\n    for (Multiset.Entry<E> entry : multiset.entrySet()) {\n      stream.writeObject(entry.getElement());\n      stream.writeInt(entry.getCount());\n    }\n  }", "language": "java", "code": "static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)\n      throws IOException {\n    int entryCount = multiset.entrySet().size();\n    stream.writeInt(entryCount);\n    for (Multiset.Entry<E> entry : multiset.entrySet()) {\n      stream.writeObject(entry.getElement());\n      stream.writeInt(entry.getCount());\n    }\n  }", "code_tokens": ["static", "<", "E", ">", "void", "writeMultiset", "(", "Multiset", "<", "E", ">", "multiset", ",", "ObjectOutputStream", "stream", ")", "throws", "IOException", "{", "int", "entryCount", "=", "multiset", ".", "entrySet", "(", ")", ".", "size", "(", ")", ";", "stream", ".", "writeInt", "(", "entryCount", ")", ";", "for", "(", "Multiset", ".", "Entry", "<", "E", ">", "entry", ":", "multiset", ".", "entrySet", "(", ")", ")", "{", "stream", ".", "writeObject", "(", "entry", ".", "getElement", "(", ")", ")", ";", "stream", ".", "writeInt", "(", "entry", ".", "getCount", "(", ")", ")", ";", "}", "}"], "docstring": "Stores the contents of a multiset in an output stream, as part of serialization. It does not\nsupport concurrent multisets whose content may change while the method is running.\n\n<p>The serialized output consists of the number of distinct elements, the first element, its\ncount, the second element, its count, and so on.", "docstring_tokens": ["Stores", "the", "contents", "of", "a", "multiset", "in", "an", "output", "stream", "as", "part", "of", "serialization", ".", "It", "does", "not", "support", "concurrent", "multisets", "whose", "content", "may", "change", "while", "the", "method", "is", "running", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L97-L105", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/Serialization.java", "func_name": "Serialization.getFieldSetter", "original_string": "static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {\n    try {\n      Field field = clazz.getDeclaredField(fieldName);\n      return new FieldSetter<T>(field);\n    } catch (NoSuchFieldException e) {\n      throw new AssertionError(e); // programmer error\n    }\n  }", "language": "java", "code": "static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {\n    try {\n      Field field = clazz.getDeclaredField(fieldName);\n      return new FieldSetter<T>(field);\n    } catch (NoSuchFieldException e) {\n      throw new AssertionError(e); // programmer error\n    }\n  }", "code_tokens": ["static", "<", "T", ">", "FieldSetter", "<", "T", ">", "getFieldSetter", "(", "final", "Class", "<", "T", ">", "clazz", ",", "String", "fieldName", ")", "{", "try", "{", "Field", "field", "=", "clazz", ".", "getDeclaredField", "(", "fieldName", ")", ";", "return", "new", "FieldSetter", "<", "T", ">", "(", "field", ")", ";", "}", "catch", "(", "NoSuchFieldException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "// programmer error", "}", "}"], "docstring": "Secret sauce for setting final fields; don't make it public.", "docstring_tokens": ["Secret", "sauce", "for", "setting", "final", "fields", ";", "don", "t", "make", "it", "public", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/Serialization.java#L185-L192", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/base/Stopwatch.java", "func_name": "Stopwatch.start", "original_string": "@CanIgnoreReturnValue\n  public Stopwatch start() {\n    checkState(!isRunning, \"This stopwatch is already running.\");\n    isRunning = true;\n    startTick = ticker.read();\n    return this;\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  public Stopwatch start() {\n    checkState(!isRunning, \"This stopwatch is already running.\");\n    isRunning = true;\n    startTick = ticker.read();\n    return this;\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "public", "Stopwatch", "start", "(", ")", "{", "checkState", "(", "!", "isRunning", ",", "\"This stopwatch is already running.\"", ")", ";", "isRunning", "=", "true", ";", "startTick", "=", "ticker", ".", "read", "(", ")", ";", "return", "this", ";", "}"], "docstring": "Starts the stopwatch.\n\n@return this {@code Stopwatch} instance\n@throws IllegalStateException if the stopwatch is already running.", "docstring_tokens": ["Starts", "the", "stopwatch", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/base/Stopwatch.java#L148-L154", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java", "func_name": "ConcurrentHashMultiset.add", "original_string": "@CanIgnoreReturnValue\n  @Override\n  public int add(E element, int occurrences) {\n    checkNotNull(element);\n    if (occurrences == 0) {\n      return count(element);\n    }\n    CollectPreconditions.checkPositive(occurrences, \"occurences\");\n\n    while (true) {\n      AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n      if (existingCounter == null) {\n        existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));\n        if (existingCounter == null) {\n          return 0;\n        }\n        // existingCounter != null: fall through to operate against the existing AtomicInteger\n      }\n\n      while (true) {\n        int oldValue = existingCounter.get();\n        if (oldValue != 0) {\n          try {\n            int newValue = IntMath.checkedAdd(oldValue, occurrences);\n            if (existingCounter.compareAndSet(oldValue, newValue)) {\n              // newValue can't == 0, so no need to check & remove\n              return oldValue;\n            }\n          } catch (ArithmeticException overflow) {\n            throw new IllegalArgumentException(\n                \"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);\n          }\n        } else {\n          // In the case of a concurrent remove, we might observe a zero value, which means another\n          // thread is about to remove (element, existingCounter) from the map. Rather than wait,\n          // we can just do that work here.\n          AtomicInteger newCounter = new AtomicInteger(occurrences);\n          if ((countMap.putIfAbsent(element, newCounter) == null)\n              || countMap.replace(element, existingCounter, newCounter)) {\n            return 0;\n          }\n          break;\n        }\n      }\n\n      // If we're still here, there was a race, so just try again.\n    }\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  @Override\n  public int add(E element, int occurrences) {\n    checkNotNull(element);\n    if (occurrences == 0) {\n      return count(element);\n    }\n    CollectPreconditions.checkPositive(occurrences, \"occurences\");\n\n    while (true) {\n      AtomicInteger existingCounter = Maps.safeGet(countMap, element);\n      if (existingCounter == null) {\n        existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));\n        if (existingCounter == null) {\n          return 0;\n        }\n        // existingCounter != null: fall through to operate against the existing AtomicInteger\n      }\n\n      while (true) {\n        int oldValue = existingCounter.get();\n        if (oldValue != 0) {\n          try {\n            int newValue = IntMath.checkedAdd(oldValue, occurrences);\n            if (existingCounter.compareAndSet(oldValue, newValue)) {\n              // newValue can't == 0, so no need to check & remove\n              return oldValue;\n            }\n          } catch (ArithmeticException overflow) {\n            throw new IllegalArgumentException(\n                \"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);\n          }\n        } else {\n          // In the case of a concurrent remove, we might observe a zero value, which means another\n          // thread is about to remove (element, existingCounter) from the map. Rather than wait,\n          // we can just do that work here.\n          AtomicInteger newCounter = new AtomicInteger(occurrences);\n          if ((countMap.putIfAbsent(element, newCounter) == null)\n              || countMap.replace(element, existingCounter, newCounter)) {\n            return 0;\n          }\n          break;\n        }\n      }\n\n      // If we're still here, there was a race, so just try again.\n    }\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "@", "Override", "public", "int", "add", "(", "E", "element", ",", "int", "occurrences", ")", "{", "checkNotNull", "(", "element", ")", ";", "if", "(", "occurrences", "==", "0", ")", "{", "return", "count", "(", "element", ")", ";", "}", "CollectPreconditions", ".", "checkPositive", "(", "occurrences", ",", "\"occurences\"", ")", ";", "while", "(", "true", ")", "{", "AtomicInteger", "existingCounter", "=", "Maps", ".", "safeGet", "(", "countMap", ",", "element", ")", ";", "if", "(", "existingCounter", "==", "null", ")", "{", "existingCounter", "=", "countMap", ".", "putIfAbsent", "(", "element", ",", "new", "AtomicInteger", "(", "occurrences", ")", ")", ";", "if", "(", "existingCounter", "==", "null", ")", "{", "return", "0", ";", "}", "// existingCounter != null: fall through to operate against the existing AtomicInteger", "}", "while", "(", "true", ")", "{", "int", "oldValue", "=", "existingCounter", ".", "get", "(", ")", ";", "if", "(", "oldValue", "!=", "0", ")", "{", "try", "{", "int", "newValue", "=", "IntMath", ".", "checkedAdd", "(", "oldValue", ",", "occurrences", ")", ";", "if", "(", "existingCounter", ".", "compareAndSet", "(", "oldValue", ",", "newValue", ")", ")", "{", "// newValue can't == 0, so no need to check & remove", "return", "oldValue", ";", "}", "}", "catch", "(", "ArithmeticException", "overflow", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Overflow adding \"", "+", "occurrences", "+", "\" occurrences to a count of \"", "+", "oldValue", ")", ";", "}", "}", "else", "{", "// In the case of a concurrent remove, we might observe a zero value, which means another", "// thread is about to remove (element, existingCounter) from the map. Rather than wait,", "// we can just do that work here.", "AtomicInteger", "newCounter", "=", "new", "AtomicInteger", "(", "occurrences", ")", ";", "if", "(", "(", "countMap", ".", "putIfAbsent", "(", "element", ",", "newCounter", ")", "==", "null", ")", "||", "countMap", ".", "replace", "(", "element", ",", "existingCounter", ",", "newCounter", ")", ")", "{", "return", "0", ";", "}", "break", ";", "}", "}", "// If we're still here, there was a race, so just try again.", "}", "}"], "docstring": "Adds a number of occurrences of the specified element to this multiset.\n\n@param element the element to add\n@param occurrences the number of occurrences to add\n@return the previous count of the element before the operation; possibly zero\n@throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount\nwould exceed {@link Integer#MAX_VALUE}", "docstring_tokens": ["Adds", "a", "number", "of", "occurrences", "of", "the", "specified", "element", "to", "this", "multiset", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java#L201-L248", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/CompactHashSet.java", "func_name": "CompactHashSet.resizeMeMaybe", "original_string": "private void resizeMeMaybe(int newSize) {\n    int entriesSize = entries.length;\n    if (newSize > entriesSize) {\n      int newCapacity = entriesSize + Math.max(1, entriesSize >>> 1);\n      if (newCapacity < 0) {\n        newCapacity = Integer.MAX_VALUE;\n      }\n      if (newCapacity != entriesSize) {\n        resizeEntries(newCapacity);\n      }\n    }\n  }", "language": "java", "code": "private void resizeMeMaybe(int newSize) {\n    int entriesSize = entries.length;\n    if (newSize > entriesSize) {\n      int newCapacity = entriesSize + Math.max(1, entriesSize >>> 1);\n      if (newCapacity < 0) {\n        newCapacity = Integer.MAX_VALUE;\n      }\n      if (newCapacity != entriesSize) {\n        resizeEntries(newCapacity);\n      }\n    }\n  }", "code_tokens": ["private", "void", "resizeMeMaybe", "(", "int", "newSize", ")", "{", "int", "entriesSize", "=", "entries", ".", "length", ";", "if", "(", "newSize", ">", "entriesSize", ")", "{", "int", "newCapacity", "=", "entriesSize", "+", "Math", ".", "max", "(", "1", ",", "entriesSize", ">>>", "1", ")", ";", "if", "(", "newCapacity", "<", "0", ")", "{", "newCapacity", "=", "Integer", ".", "MAX_VALUE", ";", "}", "if", "(", "newCapacity", "!=", "entriesSize", ")", "{", "resizeEntries", "(", "newCapacity", ")", ";", "}", "}", "}"], "docstring": "Resizes the entries storage if necessary.", "docstring_tokens": ["Resizes", "the", "entries", "storage", "if", "necessary", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/CompactHashSet.java#L283-L294", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.bytesToInetAddress", "original_string": "private static InetAddress bytesToInetAddress(byte[] addr) {\n    try {\n      return InetAddress.getByAddress(addr);\n    } catch (UnknownHostException e) {\n      throw new AssertionError(e);\n    }\n  }", "language": "java", "code": "private static InetAddress bytesToInetAddress(byte[] addr) {\n    try {\n      return InetAddress.getByAddress(addr);\n    } catch (UnknownHostException e) {\n      throw new AssertionError(e);\n    }\n  }", "code_tokens": ["private", "static", "InetAddress", "bytesToInetAddress", "(", "byte", "[", "]", "addr", ")", "{", "try", "{", "return", "InetAddress", ".", "getByAddress", "(", "addr", ")", ";", "}", "catch", "(", "UnknownHostException", "e", ")", "{", "throw", "new", "AssertionError", "(", "e", ")", ";", "}", "}"], "docstring": "Convert a byte array into an InetAddress.\n\n<p>{@link InetAddress#getByAddress} is documented as throwing a checked exception \"if IP\naddress is of illegal length.\" We replace it with an unchecked exception, for use by callers\nwho already know that addr is an array of length 4 or 16.\n\n@param addr the raw 4-byte or 16-byte IP address in big-endian order\n@return an InetAddress object created from the raw IP address", "docstring_tokens": ["Convert", "a", "byte", "array", "into", "an", "InetAddress", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L317-L323", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.compressLongestRunOfZeroes", "original_string": "private static void compressLongestRunOfZeroes(int[] hextets) {\n    int bestRunStart = -1;\n    int bestRunLength = -1;\n    int runStart = -1;\n    for (int i = 0; i < hextets.length + 1; i++) {\n      if (i < hextets.length && hextets[i] == 0) {\n        if (runStart < 0) {\n          runStart = i;\n        }\n      } else if (runStart >= 0) {\n        int runLength = i - runStart;\n        if (runLength > bestRunLength) {\n          bestRunStart = runStart;\n          bestRunLength = runLength;\n        }\n        runStart = -1;\n      }\n    }\n    if (bestRunLength >= 2) {\n      Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n    }\n  }", "language": "java", "code": "private static void compressLongestRunOfZeroes(int[] hextets) {\n    int bestRunStart = -1;\n    int bestRunLength = -1;\n    int runStart = -1;\n    for (int i = 0; i < hextets.length + 1; i++) {\n      if (i < hextets.length && hextets[i] == 0) {\n        if (runStart < 0) {\n          runStart = i;\n        }\n      } else if (runStart >= 0) {\n        int runLength = i - runStart;\n        if (runLength > bestRunLength) {\n          bestRunStart = runStart;\n          bestRunLength = runLength;\n        }\n        runStart = -1;\n      }\n    }\n    if (bestRunLength >= 2) {\n      Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n    }\n  }", "code_tokens": ["private", "static", "void", "compressLongestRunOfZeroes", "(", "int", "[", "]", "hextets", ")", "{", "int", "bestRunStart", "=", "-", "1", ";", "int", "bestRunLength", "=", "-", "1", ";", "int", "runStart", "=", "-", "1", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hextets", ".", "length", "+", "1", ";", "i", "++", ")", "{", "if", "(", "i", "<", "hextets", ".", "length", "&&", "hextets", "[", "i", "]", "==", "0", ")", "{", "if", "(", "runStart", "<", "0", ")", "{", "runStart", "=", "i", ";", "}", "}", "else", "if", "(", "runStart", ">=", "0", ")", "{", "int", "runLength", "=", "i", "-", "runStart", ";", "if", "(", "runLength", ">", "bestRunLength", ")", "{", "bestRunStart", "=", "runStart", ";", "bestRunLength", "=", "runLength", ";", "}", "runStart", "=", "-", "1", ";", "}", "}", "if", "(", "bestRunLength", ">=", "2", ")", "{", "Arrays", ".", "fill", "(", "hextets", ",", "bestRunStart", ",", "bestRunStart", "+", "bestRunLength", ",", "-", "1", ")", ";", "}", "}"], "docstring": "Identify and mark the longest run of zeroes in an IPv6 address.\n\n<p>Only runs of two or more hextets are considered. In case of a tie, the leftmost run wins. If\na qualifying run is found, its hextets are replaced by the sentinel value -1.\n\n@param hextets {@code int[]} mutable array of eight 16-bit hextets", "docstring_tokens": ["Identify", "and", "mark", "the", "longest", "run", "of", "zeroes", "in", "an", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L364-L385", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.hextetsToIPv6String", "original_string": "private static String hextetsToIPv6String(int[] hextets) {\n    // While scanning the array, handle these state transitions:\n    //   start->num => \"num\"     start->gap => \"::\"\n    //   num->num   => \":num\"    num->gap   => \"::\"\n    //   gap->num   => \"num\"     gap->gap   => \"\"\n    StringBuilder buf = new StringBuilder(39);\n    boolean lastWasNumber = false;\n    for (int i = 0; i < hextets.length; i++) {\n      boolean thisIsNumber = hextets[i] >= 0;\n      if (thisIsNumber) {\n        if (lastWasNumber) {\n          buf.append(':');\n        }\n        buf.append(Integer.toHexString(hextets[i]));\n      } else {\n        if (i == 0 || lastWasNumber) {\n          buf.append(\"::\");\n        }\n      }\n      lastWasNumber = thisIsNumber;\n    }\n    return buf.toString();\n  }", "language": "java", "code": "private static String hextetsToIPv6String(int[] hextets) {\n    // While scanning the array, handle these state transitions:\n    //   start->num => \"num\"     start->gap => \"::\"\n    //   num->num   => \":num\"    num->gap   => \"::\"\n    //   gap->num   => \"num\"     gap->gap   => \"\"\n    StringBuilder buf = new StringBuilder(39);\n    boolean lastWasNumber = false;\n    for (int i = 0; i < hextets.length; i++) {\n      boolean thisIsNumber = hextets[i] >= 0;\n      if (thisIsNumber) {\n        if (lastWasNumber) {\n          buf.append(':');\n        }\n        buf.append(Integer.toHexString(hextets[i]));\n      } else {\n        if (i == 0 || lastWasNumber) {\n          buf.append(\"::\");\n        }\n      }\n      lastWasNumber = thisIsNumber;\n    }\n    return buf.toString();\n  }", "code_tokens": ["private", "static", "String", "hextetsToIPv6String", "(", "int", "[", "]", "hextets", ")", "{", "// While scanning the array, handle these state transitions:", "//   start->num => \"num\"     start->gap => \"::\"", "//   num->num   => \":num\"    num->gap   => \"::\"", "//   gap->num   => \"num\"     gap->gap   => \"\"", "StringBuilder", "buf", "=", "new", "StringBuilder", "(", "39", ")", ";", "boolean", "lastWasNumber", "=", "false", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "hextets", ".", "length", ";", "i", "++", ")", "{", "boolean", "thisIsNumber", "=", "hextets", "[", "i", "]", ">=", "0", ";", "if", "(", "thisIsNumber", ")", "{", "if", "(", "lastWasNumber", ")", "{", "buf", ".", "append", "(", "'", "'", ")", ";", "}", "buf", ".", "append", "(", "Integer", ".", "toHexString", "(", "hextets", "[", "i", "]", ")", ")", ";", "}", "else", "{", "if", "(", "i", "==", "0", "||", "lastWasNumber", ")", "{", "buf", ".", "append", "(", "\"::\"", ")", ";", "}", "}", "lastWasNumber", "=", "thisIsNumber", ";", "}", "return", "buf", ".", "toString", "(", ")", ";", "}"], "docstring": "Convert a list of hextets into a human-readable IPv6 address.\n\n<p>In order for \"::\" compression to work, the input should contain negative sentinel values in\nplace of the elided zeroes.\n\n@param hextets {@code int[]} array of eight 16-bit hextets, or -1s", "docstring_tokens": ["Convert", "a", "list", "of", "hextets", "into", "a", "human", "-", "readable", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L395-L417", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.forUriString", "original_string": "public static InetAddress forUriString(String hostAddr) {\n    InetAddress addr = forUriStringNoThrow(hostAddr);\n    if (addr == null) {\n      throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n    }\n\n    return addr;\n  }", "language": "java", "code": "public static InetAddress forUriString(String hostAddr) {\n    InetAddress addr = forUriStringNoThrow(hostAddr);\n    if (addr == null) {\n      throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n    }\n\n    return addr;\n  }", "code_tokens": ["public", "static", "InetAddress", "forUriString", "(", "String", "hostAddr", ")", "{", "InetAddress", "addr", "=", "forUriStringNoThrow", "(", "hostAddr", ")", ";", "if", "(", "addr", "==", "null", ")", "{", "throw", "formatIllegalArgumentException", "(", "\"Not a valid URI IP literal: '%s'\"", ",", "hostAddr", ")", ";", "}", "return", "addr", ";", "}"], "docstring": "Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in\nthe format specified by RFC 3986 section 3.2.2.\n\n<p>This function is similar to {@link InetAddresses#forString(String)}, however, it requires\nthat IPv6 addresses are surrounded by square brackets.\n\n<p>This function is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.\n\n@param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address\n@return an InetAddress representing the address in {@code hostAddr}\n@throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6\naddress surrounded by square brackets", "docstring_tokens": ["Returns", "an", "InetAddress", "representing", "the", "literal", "IPv4", "or", "IPv6", "host", "portion", "of", "a", "URL", "encoded", "in", "the", "format", "specified", "by", "RFC", "3986", "section", "3", ".", "2", ".", "2", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L459-L466", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isCompatIPv4Address", "original_string": "public static boolean isCompatIPv4Address(Inet6Address ip) {\n    if (!ip.isIPv4CompatibleAddress()) {\n      return false;\n    }\n\n    byte[] bytes = ip.getAddress();\n    if ((bytes[12] == 0)\n        && (bytes[13] == 0)\n        && (bytes[14] == 0)\n        && ((bytes[15] == 0) || (bytes[15] == 1))) {\n      return false;\n    }\n\n    return true;\n  }", "language": "java", "code": "public static boolean isCompatIPv4Address(Inet6Address ip) {\n    if (!ip.isIPv4CompatibleAddress()) {\n      return false;\n    }\n\n    byte[] bytes = ip.getAddress();\n    if ((bytes[12] == 0)\n        && (bytes[13] == 0)\n        && (bytes[14] == 0)\n        && ((bytes[15] == 0) || (bytes[15] == 1))) {\n      return false;\n    }\n\n    return true;\n  }", "code_tokens": ["public", "static", "boolean", "isCompatIPv4Address", "(", "Inet6Address", "ip", ")", "{", "if", "(", "!", "ip", ".", "isIPv4CompatibleAddress", "(", ")", ")", "{", "return", "false", ";", "}", "byte", "[", "]", "bytes", "=", "ip", ".", "getAddress", "(", ")", ";", "if", "(", "(", "bytes", "[", "12", "]", "==", "0", ")", "&&", "(", "bytes", "[", "13", "]", "==", "0", ")", "&&", "(", "bytes", "[", "14", "]", "==", "0", ")", "&&", "(", "(", "bytes", "[", "15", "]", "==", "0", ")", "||", "(", "bytes", "[", "15", "]", "==", "1", ")", ")", ")", "{", "return", "false", ";", "}", "return", "true", ";", "}"], "docstring": "Evaluates whether the argument is an IPv6 \"compat\" address.\n\n<p>An \"IPv4 compatible\", or \"compat\", address is one with 96 leading bits of zero, with the\nremaining 32 bits interpreted as an IPv4 address. These are conventionally represented in\nstring literals as {@code \"::192.168.0.1\"}, though {@code \"::c0a8:1\"} is also considered an\nIPv4 compatible address (and equivalent to {@code \"::192.168.0.1\"}).\n\n<p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.1\">RFC 4291</a>.\n\n<p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it\nmore correctly classifies {@code \"::\"} and {@code \"::1\"} as proper IPv6 addresses (which they\nare), NOT IPv4 compatible addresses (which they are generally NOT considered to be).\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format\n@return {@code true} if the argument is a valid \"compat\" address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "IPv6", "compat", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L521-L535", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getCompatIPv4Address", "original_string": "public static Inet4Address getCompatIPv4Address(Inet6Address ip) {\n    checkArgument(\n        isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n  }", "language": "java", "code": "public static Inet4Address getCompatIPv4Address(Inet6Address ip) {\n    checkArgument(\n        isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n  }", "code_tokens": ["public", "static", "Inet4Address", "getCompatIPv4Address", "(", "Inet6Address", "ip", ")", "{", "checkArgument", "(", "isCompatIPv4Address", "(", "ip", ")", ",", "\"Address '%s' is not IPv4-compatible.\"", ",", "toAddrString", "(", "ip", ")", ")", ";", "return", "getInet4Address", "(", "Arrays", ".", "copyOfRange", "(", "ip", ".", "getAddress", "(", ")", ",", "12", ",", "16", ")", ")", ";", "}"], "docstring": "Returns the IPv4 address embedded in an IPv4 compatible address.\n\n@param ip {@link Inet6Address} to be examined for an embedded IPv4 address\n@return {@link Inet4Address} of the embedded IPv4 address\n@throws IllegalArgumentException if the argument is not a valid IPv4 compatible address", "docstring_tokens": ["Returns", "the", "IPv4", "address", "embedded", "in", "an", "IPv4", "compatible", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L544-L549", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isTeredoAddress", "original_string": "public static boolean isTeredoAddress(Inet6Address ip) {\n    byte[] bytes = ip.getAddress();\n    return (bytes[0] == (byte) 0x20)\n        && (bytes[1] == (byte) 0x01)\n        && (bytes[2] == 0)\n        && (bytes[3] == 0);\n  }", "language": "java", "code": "public static boolean isTeredoAddress(Inet6Address ip) {\n    byte[] bytes = ip.getAddress();\n    return (bytes[0] == (byte) 0x20)\n        && (bytes[1] == (byte) 0x01)\n        && (bytes[2] == 0)\n        && (bytes[3] == 0);\n  }", "code_tokens": ["public", "static", "boolean", "isTeredoAddress", "(", "Inet6Address", "ip", ")", "{", "byte", "[", "]", "bytes", "=", "ip", ".", "getAddress", "(", ")", ";", "return", "(", "bytes", "[", "0", "]", "==", "(", "byte", ")", "0x20", ")", "&&", "(", "bytes", "[", "1", "]", "==", "(", "byte", ")", "0x01", ")", "&&", "(", "bytes", "[", "2", "]", "==", "0", ")", "&&", "(", "bytes", "[", "3", "]", "==", "0", ")", ";", "}"], "docstring": "Evaluates whether the argument is a Teredo address.\n\n<p>Teredo addresses begin with the {@code \"2001::/32\"} prefix.\n\n@param ip {@link Inet6Address} to be examined for Teredo address format\n@return {@code true} if the argument is a Teredo address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "a", "Teredo", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L651-L657", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isIsatapAddress", "original_string": "public static boolean isIsatapAddress(Inet6Address ip) {\n\n    // If it's a Teredo address with the right port (41217, or 0xa101)\n    // which would be encoded as 0x5efe then it can't be an ISATAP address.\n    if (isTeredoAddress(ip)) {\n      return false;\n    }\n\n    byte[] bytes = ip.getAddress();\n\n    if ((bytes[8] | (byte) 0x03) != (byte) 0x03) {\n\n      // Verify that high byte of the 64 bit identifier is zero, modulo\n      // the U/L and G bits, with which we are not concerned.\n      return false;\n    }\n\n    return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n  }", "language": "java", "code": "public static boolean isIsatapAddress(Inet6Address ip) {\n\n    // If it's a Teredo address with the right port (41217, or 0xa101)\n    // which would be encoded as 0x5efe then it can't be an ISATAP address.\n    if (isTeredoAddress(ip)) {\n      return false;\n    }\n\n    byte[] bytes = ip.getAddress();\n\n    if ((bytes[8] | (byte) 0x03) != (byte) 0x03) {\n\n      // Verify that high byte of the 64 bit identifier is zero, modulo\n      // the U/L and G bits, with which we are not concerned.\n      return false;\n    }\n\n    return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n  }", "code_tokens": ["public", "static", "boolean", "isIsatapAddress", "(", "Inet6Address", "ip", ")", "{", "// If it's a Teredo address with the right port (41217, or 0xa101)", "// which would be encoded as 0x5efe then it can't be an ISATAP address.", "if", "(", "isTeredoAddress", "(", "ip", ")", ")", "{", "return", "false", ";", "}", "byte", "[", "]", "bytes", "=", "ip", ".", "getAddress", "(", ")", ";", "if", "(", "(", "bytes", "[", "8", "]", "|", "(", "byte", ")", "0x03", ")", "!=", "(", "byte", ")", "0x03", ")", "{", "// Verify that high byte of the 64 bit identifier is zero, modulo", "// the U/L and G bits, with which we are not concerned.", "return", "false", ";", "}", "return", "(", "bytes", "[", "9", "]", "==", "(", "byte", ")", "0x00", ")", "&&", "(", "bytes", "[", "10", "]", "==", "(", "byte", ")", "0x5e", ")", "&&", "(", "bytes", "[", "11", "]", "==", "(", "byte", ")", "0xfe", ")", ";", "}"], "docstring": "Evaluates whether the argument is an ISATAP address.\n\n<p>From RFC 5214: \"ISATAP interface identifiers are constructed in Modified EUI-64 format [...]\nby concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit\nIPv4 address in network byte order [...]\"\n\n<p>For more on ISATAP addresses see section 6.1 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc5214#section-6.1\">RFC 5214</a>.\n\n@param ip {@link Inet6Address} to be examined for ISATAP address format\n@return {@code true} if the argument is an ISATAP address", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "ISATAP", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L700-L718", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getIsatapIPv4Address", "original_string": "public static Inet4Address getIsatapIPv4Address(Inet6Address ip) {\n    checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n  }", "language": "java", "code": "public static Inet4Address getIsatapIPv4Address(Inet6Address ip) {\n    checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n  }", "code_tokens": ["public", "static", "Inet4Address", "getIsatapIPv4Address", "(", "Inet6Address", "ip", ")", "{", "checkArgument", "(", "isIsatapAddress", "(", "ip", ")", ",", "\"Address '%s' is not an ISATAP address.\"", ",", "toAddrString", "(", "ip", ")", ")", ";", "return", "getInet4Address", "(", "Arrays", ".", "copyOfRange", "(", "ip", ".", "getAddress", "(", ")", ",", "12", ",", "16", ")", ")", ";", "}"], "docstring": "Returns the IPv4 address embedded in an ISATAP address.\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address\n@return {@link Inet4Address} of embedded IPv4 in an ISATAP address\n@throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address", "docstring_tokens": ["Returns", "the", "IPv4", "address", "embedded", "in", "an", "ISATAP", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L727-L731", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.getEmbeddedIPv4ClientAddress", "original_string": "public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip) {\n    if (isCompatIPv4Address(ip)) {\n      return getCompatIPv4Address(ip);\n    }\n\n    if (is6to4Address(ip)) {\n      return get6to4IPv4Address(ip);\n    }\n\n    if (isTeredoAddress(ip)) {\n      return getTeredoInfo(ip).getClient();\n    }\n\n    throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n  }", "language": "java", "code": "public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip) {\n    if (isCompatIPv4Address(ip)) {\n      return getCompatIPv4Address(ip);\n    }\n\n    if (is6to4Address(ip)) {\n      return get6to4IPv4Address(ip);\n    }\n\n    if (isTeredoAddress(ip)) {\n      return getTeredoInfo(ip).getClient();\n    }\n\n    throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n  }", "code_tokens": ["public", "static", "Inet4Address", "getEmbeddedIPv4ClientAddress", "(", "Inet6Address", "ip", ")", "{", "if", "(", "isCompatIPv4Address", "(", "ip", ")", ")", "{", "return", "getCompatIPv4Address", "(", "ip", ")", ";", "}", "if", "(", "is6to4Address", "(", "ip", ")", ")", "{", "return", "get6to4IPv4Address", "(", "ip", ")", ";", "}", "if", "(", "isTeredoAddress", "(", "ip", ")", ")", "{", "return", "getTeredoInfo", "(", "ip", ")", ".", "getClient", "(", ")", ";", "}", "throw", "formatIllegalArgumentException", "(", "\"'%s' has no embedded IPv4 address.\"", ",", "toAddrString", "(", "ip", ")", ")", ";", "}"], "docstring": "Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an\nIPv6 address of one of the specified address types that contain an embedded IPv4 address.\n\n<p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial\nspoofability. With other transition addresses spoofing involves (at least) infection of one's\nBGP routing table.\n\n@param ip {@link Inet6Address} to be examined for embedded IPv4 client address\n@return {@link Inet4Address} of embedded IPv4 client address\n@throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address", "docstring_tokens": ["Examines", "the", "Inet6Address", "to", "extract", "the", "embedded", "IPv4", "client", "address", "if", "the", "InetAddress", "is", "an", "IPv6", "address", "of", "one", "of", "the", "specified", "address", "types", "that", "contain", "an", "embedded", "IPv4", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L761-L775", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.isMappedIPv4Address", "original_string": "public static boolean isMappedIPv4Address(String ipString) {\n    byte[] bytes = ipStringToBytes(ipString);\n    if (bytes != null && bytes.length == 16) {\n      for (int i = 0; i < 10; i++) {\n        if (bytes[i] != 0) {\n          return false;\n        }\n      }\n      for (int i = 10; i < 12; i++) {\n        if (bytes[i] != (byte) 0xff) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "language": "java", "code": "public static boolean isMappedIPv4Address(String ipString) {\n    byte[] bytes = ipStringToBytes(ipString);\n    if (bytes != null && bytes.length == 16) {\n      for (int i = 0; i < 10; i++) {\n        if (bytes[i] != 0) {\n          return false;\n        }\n      }\n      for (int i = 10; i < 12; i++) {\n        if (bytes[i] != (byte) 0xff) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "code_tokens": ["public", "static", "boolean", "isMappedIPv4Address", "(", "String", "ipString", ")", "{", "byte", "[", "]", "bytes", "=", "ipStringToBytes", "(", "ipString", ")", ";", "if", "(", "bytes", "!=", "null", "&&", "bytes", ".", "length", "==", "16", ")", "{", "for", "(", "int", "i", "=", "0", ";", "i", "<", "10", ";", "i", "++", ")", "{", "if", "(", "bytes", "[", "i", "]", "!=", "0", ")", "{", "return", "false", ";", "}", "}", "for", "(", "int", "i", "=", "10", ";", "i", "<", "12", ";", "i", "++", ")", "{", "if", "(", "bytes", "[", "i", "]", "!=", "(", "byte", ")", "0xff", ")", "{", "return", "false", ";", "}", "}", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Evaluates whether the argument is an \"IPv4 mapped\" IPv6 address.\n\n<p>An \"IPv4 mapped\" address is anything in the range ::ffff:0:0/96 (sometimes written as\n::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.\n\n<p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target=\"_parent\"\nhref=\"http://tools.ietf.org/html/rfc4291#section-2.5.5.2\">RFC 4291</a>.\n\n<p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically\ncollapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the\nobscure {@link Inet6Address} methods, but it would be unwise to depend on such a\npoorly-documented feature.)\n\n@param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format\n@return {@code true} if the argument is a valid \"mapped\" address\n@since 10.0", "docstring_tokens": ["Evaluates", "whether", "the", "argument", "is", "an", "IPv4", "mapped", "IPv6", "address", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L795-L811", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/net/InetAddresses.java", "func_name": "InetAddresses.decrement", "original_string": "public static InetAddress decrement(InetAddress address) {\n    byte[] addr = address.getAddress();\n    int i = addr.length - 1;\n    while (i >= 0 && addr[i] == (byte) 0x00) {\n      addr[i] = (byte) 0xff;\n      i--;\n    }\n\n    checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n    addr[i]--;\n    return bytesToInetAddress(addr);\n  }", "language": "java", "code": "public static InetAddress decrement(InetAddress address) {\n    byte[] addr = address.getAddress();\n    int i = addr.length - 1;\n    while (i >= 0 && addr[i] == (byte) 0x00) {\n      addr[i] = (byte) 0xff;\n      i--;\n    }\n\n    checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n    addr[i]--;\n    return bytesToInetAddress(addr);\n  }", "code_tokens": ["public", "static", "InetAddress", "decrement", "(", "InetAddress", "address", ")", "{", "byte", "[", "]", "addr", "=", "address", ".", "getAddress", "(", ")", ";", "int", "i", "=", "addr", ".", "length", "-", "1", ";", "while", "(", "i", ">=", "0", "&&", "addr", "[", "i", "]", "==", "(", "byte", ")", "0x00", ")", "{", "addr", "[", "i", "]", "=", "(", "byte", ")", "0xff", ";", "i", "--", ";", "}", "checkArgument", "(", "i", ">=", "0", ",", "\"Decrementing %s would wrap.\"", ",", "address", ")", ";", "addr", "[", "i", "]", "--", ";", "return", "bytesToInetAddress", "(", "addr", ")", ";", "}"], "docstring": "Returns a new InetAddress that is one less than the passed in address. This method works for\nboth IPv4 and IPv6 addresses.\n\n@param address the InetAddress to decrement\n@return a new InetAddress that is one less than the passed in address\n@throws IllegalArgumentException if InetAddress is at the beginning of its range\n@since 18.0", "docstring_tokens": ["Returns", "a", "new", "InetAddress", "that", "is", "one", "less", "than", "the", "passed", "in", "address", ".", "This", "method", "works", "for", "both", "IPv4", "and", "IPv6", "addresses", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/net/InetAddresses.java#L935-L947", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.newReader", "original_string": "@Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }", "language": "java", "code": "@Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }", "code_tokens": ["@", "Beta", "public", "static", "BufferedReader", "newReader", "(", "File", "file", ",", "Charset", "charset", ")", "throws", "FileNotFoundException", "{", "checkNotNull", "(", "file", ")", ";", "checkNotNull", "(", "charset", ")", ";", "return", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "new", "FileInputStream", "(", "file", ")", ",", "charset", ")", ")", ";", "}"], "docstring": "Returns a buffered reader that reads from a file using the given character set.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n\n@param file the file to read from\n@param charset the charset used to decode the input stream; see {@link StandardCharsets} for\nhelpful predefined constants\n@return the buffered reader", "docstring_tokens": ["Returns", "a", "buffered", "reader", "that", "reads", "from", "a", "file", "using", "the", "given", "character", "set", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L85-L90", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.write", "original_string": "@Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }", "language": "java", "code": "@Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }", "code_tokens": ["@", "Beta", "public", "static", "void", "write", "(", "byte", "[", "]", "from", ",", "File", "to", ")", "throws", "IOException", "{", "asByteSink", "(", "to", ")", ".", "write", "(", "from", ")", ";", "}"], "docstring": "Overwrites a file with the contents of a byte array.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n\n@param from the bytes to write\n@param to the destination file\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Overwrites", "a", "file", "with", "the", "contents", "of", "a", "byte", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L267-L270", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.copy", "original_string": "@Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }", "language": "java", "code": "@Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }", "code_tokens": ["@", "Beta", "public", "static", "void", "copy", "(", "File", "from", ",", "OutputStream", "to", ")", "throws", "IOException", "{", "asByteSource", "(", "from", ")", ".", "copyTo", "(", "to", ")", ";", "}"], "docstring": "Copies all bytes from a file to an output stream.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n\n@param from the source file\n@param to the output stream\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Copies", "all", "bytes", "from", "a", "file", "to", "an", "output", "stream", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L299-L302", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.copy", "original_string": "@Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }", "language": "java", "code": "@Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }", "code_tokens": ["@", "Beta", "public", "static", "void", "copy", "(", "File", "from", ",", "File", "to", ")", "throws", "IOException", "{", "checkArgument", "(", "!", "from", ".", "equals", "(", "to", ")", ",", "\"Source %s and destination %s must be different\"", ",", "from", ",", "to", ")", ";", "asByteSource", "(", "from", ")", ".", "copyTo", "(", "asByteSink", "(", "to", ")", ")", ";", "}"], "docstring": "Copies all the bytes from one file to another.\n\n<p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\ntermination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\nneed to guard against those conditions, you should employ other file-level synchronization.\n\n<p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\nwith the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\nfile, the contents of that file will be deleted.\n\n<p><b>{@link java.nio.file.Path} equivalent:</b> {@link\njava.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n\n@param from the source file\n@param to the destination file\n@throws IOException if an I/O error occurs\n@throws IllegalArgumentException if {@code from.equals(to)}", "docstring_tokens": ["Copies", "all", "the", "bytes", "from", "one", "file", "to", "another", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L323-L327", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.touch", "original_string": "@Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }", "language": "java", "code": "@Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }", "code_tokens": ["@", "Beta", "@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// reading system time without TimeSource", "public", "static", "void", "touch", "(", "File", "file", ")", "throws", "IOException", "{", "checkNotNull", "(", "file", ")", ";", "if", "(", "!", "file", ".", "createNewFile", "(", ")", "&&", "!", "file", ".", "setLastModified", "(", "System", ".", "currentTimeMillis", "(", ")", ")", ")", "{", "throw", "new", "IOException", "(", "\"Unable to update modification time of \"", "+", "file", ")", ";", "}", "}"], "docstring": "Creates an empty file or updates the last updated timestamp on the same as the unix command of\nthe same name.\n\n@param file the file to create or update\n@throws IOException if an I/O error occurs", "docstring_tokens": ["Creates", "an", "empty", "file", "or", "updates", "the", "last", "updated", "timestamp", "on", "the", "same", "as", "the", "unix", "command", "of", "the", "same", "name", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L440-L447", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/io/Files.java", "func_name": "Files.readFirstLine", "original_string": "@Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }", "language": "java", "code": "@Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }", "code_tokens": ["@", "Beta", "@", "Deprecated", "public", "static", "String", "readFirstLine", "(", "File", "file", ",", "Charset", "charset", ")", "throws", "IOException", "{", "return", "asCharSource", "(", "file", ",", "charset", ")", ".", "readFirstLine", "(", ")", ";", "}"], "docstring": "Reads the first line from a file. The line does not include line-termination characters, but\ndoes include other leading and trailing whitespace.\n\n@param file the file to read from\n@param charset the charset used to decode the input stream; see {@link StandardCharsets} for\nhelpful predefined constants\n@return the first line, or null if the file is empty\n@throws IOException if an I/O error occurs\n@deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\nscheduled to be removed in January 2019.", "docstring_tokens": ["Reads", "the", "first", "line", "from", "a", "file", ".", "The", "line", "does", "not", "include", "line", "-", "termination", "characters", "but", "does", "include", "other", "leading", "and", "trailing", "whitespace", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/io/Files.java#L518-L523", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableBiMap.java", "func_name": "ImmutableBiMap.builderWithExpectedSize", "original_string": "@Beta\n  public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {\n    checkNonnegative(expectedSize, \"expectedSize\");\n    return new Builder<>(expectedSize);\n  }", "language": "java", "code": "@Beta\n  public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {\n    checkNonnegative(expectedSize, \"expectedSize\");\n    return new Builder<>(expectedSize);\n  }", "code_tokens": ["@", "Beta", "public", "static", "<", "K", ",", "V", ">", "Builder", "<", "K", ",", "V", ">", "builderWithExpectedSize", "(", "int", "expectedSize", ")", "{", "checkNonnegative", "(", "expectedSize", ",", "\"expectedSize\"", ")", ";", "return", "new", "Builder", "<>", "(", "expectedSize", ")", ";", "}"], "docstring": "Returns a new builder, expecting the specified number of entries to be added.\n\n<p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link\nBuilder#build} is called, the builder is likely to perform better than an unsized {@link\n#builder()} would have.\n\n<p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,\nbut not exactly, the number of entries added to the builder.\n\n@since 23.1", "docstring_tokens": ["Returns", "a", "new", "builder", "expecting", "the", "specified", "number", "of", "entries", "to", "be", "added", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableBiMap.java#L135-L139", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/ImmutableBiMap.java", "func_name": "ImmutableBiMap.forcePut", "original_string": "@CanIgnoreReturnValue\n  @Deprecated\n  @Override\n  public V forcePut(K key, V value) {\n    throw new UnsupportedOperationException();\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  @Deprecated\n  @Override\n  public V forcePut(K key, V value) {\n    throw new UnsupportedOperationException();\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "@", "Deprecated", "@", "Override", "public", "V", "forcePut", "(", "K", "key", ",", "V", "value", ")", "{", "throw", "new", "UnsupportedOperationException", "(", ")", ";", "}"], "docstring": "Guaranteed to throw an exception and leave the bimap unmodified.\n\n@throws UnsupportedOperationException always\n@deprecated Unsupported operation.", "docstring_tokens": ["Guaranteed", "to", "throw", "an", "exception", "and", "leave", "the", "bimap", "unmodified", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/ImmutableBiMap.java#L401-L406", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "func_name": "MinMaxPriorityQueue.create", "original_string": "public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(\n      Iterable<? extends E> initialContents) {\n    return new Builder<E>(Ordering.<E>natural()).create(initialContents);\n  }", "language": "java", "code": "public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(\n      Iterable<? extends E> initialContents) {\n    return new Builder<E>(Ordering.<E>natural()).create(initialContents);\n  }", "code_tokens": ["public", "static", "<", "E", "extends", "Comparable", "<", "E", ">", ">", "MinMaxPriorityQueue", "<", "E", ">", "create", "(", "Iterable", "<", "?", "extends", "E", ">", "initialContents", ")", "{", "return", "new", "Builder", "<", "E", ">", "(", "Ordering", ".", "<", "E", ">", "natural", "(", ")", ")", ".", "create", "(", "initialContents", ")", ";", "}"], "docstring": "Creates a new min-max priority queue using natural order, no maximum size, and initially\ncontaining the given elements.", "docstring_tokens": ["Creates", "a", "new", "min", "-", "max", "priority", "queue", "using", "natural", "order", "no", "maximum", "size", "and", "initially", "containing", "the", "given", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/MinMaxPriorityQueue.java#L116-L119", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/collect/MinMaxPriorityQueue.java", "func_name": "MinMaxPriorityQueue.calculateNewCapacity", "original_string": "private int calculateNewCapacity() {\n    int oldCapacity = queue.length;\n    int newCapacity =\n        (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n    return capAtMaximumSize(newCapacity, maximumSize);\n  }", "language": "java", "code": "private int calculateNewCapacity() {\n    int oldCapacity = queue.length;\n    int newCapacity =\n        (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n    return capAtMaximumSize(newCapacity, maximumSize);\n  }", "code_tokens": ["private", "int", "calculateNewCapacity", "(", ")", "{", "int", "oldCapacity", "=", "queue", ".", "length", ";", "int", "newCapacity", "=", "(", "oldCapacity", "<", "64", ")", "?", "(", "oldCapacity", "+", "1", ")", "*", "2", ":", "IntMath", ".", "checkedMultiply", "(", "oldCapacity", "/", "2", ",", "3", ")", ";", "return", "capAtMaximumSize", "(", "newCapacity", ",", "maximumSize", ")", ";", "}"], "docstring": "Returns ~2x the old capacity if small; ~1.5x otherwise.", "docstring_tokens": ["Returns", "~2x", "the", "old", "capacity", "if", "small", ";", "~1", ".", "5x", "otherwise", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/collect/MinMaxPriorityQueue.java#L945-L950", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/hash/Murmur3_32HashFunction.java", "func_name": "Murmur3_32HashFunction.fmix", "original_string": "private static HashCode fmix(int h1, int length) {\n    h1 ^= length;\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n    return HashCode.fromInt(h1);\n  }", "language": "java", "code": "private static HashCode fmix(int h1, int length) {\n    h1 ^= length;\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n    return HashCode.fromInt(h1);\n  }", "code_tokens": ["private", "static", "HashCode", "fmix", "(", "int", "h1", ",", "int", "length", ")", "{", "h1", "^=", "length", ";", "h1", "^=", "h1", ">>>", "16", ";", "h1", "*=", "0x85ebca6b", ";", "h1", "^=", "h1", ">>>", "13", ";", "h1", "*=", "0xc2b2ae35", ";", "h1", "^=", "h1", ">>>", "16", ";", "return", "HashCode", ".", "fromInt", "(", "h1", ")", ";", "}"], "docstring": "Finalization mix - force all bits of a hash block to avalanche", "docstring_tokens": ["Finalization", "mix", "-", "force", "all", "bits", "of", "a", "hash", "block", "to", "avalanche"], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/hash/Murmur3_32HashFunction.java#L249-L257", "partition": "valid"}
{"repo": "google/guava", "path": "guava/src/com/google/common/graph/ElementOrder.java", "func_name": "ElementOrder.natural", "original_string": "public static <S extends Comparable<? super S>> ElementOrder<S> natural() {\n    return new ElementOrder<S>(Type.SORTED, Ordering.<S>natural());\n  }", "language": "java", "code": "public static <S extends Comparable<? super S>> ElementOrder<S> natural() {\n    return new ElementOrder<S>(Type.SORTED, Ordering.<S>natural());\n  }", "code_tokens": ["public", "static", "<", "S", "extends", "Comparable", "<", "?", "super", "S", ">", ">", "ElementOrder", "<", "S", ">", "natural", "(", ")", "{", "return", "new", "ElementOrder", "<", "S", ">", "(", "Type", ".", "SORTED", ",", "Ordering", ".", "<", "S", ">", "natural", "(", ")", ")", ";", "}"], "docstring": "Returns an instance which specifies that the natural ordering of the elements is guaranteed.", "docstring_tokens": ["Returns", "an", "instance", "which", "specifies", "that", "the", "natural", "ordering", "of", "the", "elements", "is", "guaranteed", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/guava/src/com/google/common/graph/ElementOrder.java#L89-L91", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enter", "original_string": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enter(long time, TimeUnit unit) {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    final ReentrantLock lock = this.lock;\n    if (!fair && lock.tryLock()) {\n      return true;\n    }\n    boolean interrupted = Thread.interrupted();\n    try {\n      final long startTime = System.nanoTime();\n      for (long remainingNanos = timeoutNanos; ; ) {\n        try {\n          return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          remainingNanos = remainingNanos(startTime, timeoutNanos);\n        }\n      }\n    } finally {\n      if (interrupted) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }", "language": "java", "code": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enter(long time, TimeUnit unit) {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    final ReentrantLock lock = this.lock;\n    if (!fair && lock.tryLock()) {\n      return true;\n    }\n    boolean interrupted = Thread.interrupted();\n    try {\n      final long startTime = System.nanoTime();\n      for (long remainingNanos = timeoutNanos; ; ) {\n        try {\n          return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          remainingNanos = remainingNanos(startTime, timeoutNanos);\n        }\n      }\n    } finally {\n      if (interrupted) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// should accept a java.time.Duration", "public", "boolean", "enter", "(", "long", "time", ",", "TimeUnit", "unit", ")", "{", "final", "long", "timeoutNanos", "=", "toSafeNanos", "(", "time", ",", "unit", ")", ";", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "if", "(", "!", "fair", "&&", "lock", ".", "tryLock", "(", ")", ")", "{", "return", "true", ";", "}", "boolean", "interrupted", "=", "Thread", ".", "interrupted", "(", ")", ";", "try", "{", "final", "long", "startTime", "=", "System", ".", "nanoTime", "(", ")", ";", "for", "(", "long", "remainingNanos", "=", "timeoutNanos", ";", ";", ")", "{", "try", "{", "return", "lock", ".", "tryLock", "(", "remainingNanos", ",", "TimeUnit", ".", "NANOSECONDS", ")", ";", "}", "catch", "(", "InterruptedException", "interrupt", ")", "{", "interrupted", "=", "true", ";", "remainingNanos", "=", "remainingNanos", "(", "startTime", ",", "timeoutNanos", ")", ";", "}", "}", "}", "finally", "{", "if", "(", "interrupted", ")", "{", "Thread", ".", "currentThread", "(", ")", ".", "interrupt", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor. Blocks at most the given time.\n\n@return whether the monitor was entered", "docstring_tokens": ["Enters", "this", "monitor", ".", "Blocks", "at", "most", "the", "given", "time", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L371-L394", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterInterruptibly", "original_string": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {\n    return lock.tryLock(time, unit);\n  }", "language": "java", "code": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {\n    return lock.tryLock(time, unit);\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// should accept a java.time.Duration", "public", "boolean", "enterInterruptibly", "(", "long", "time", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", "{", "return", "lock", ".", "tryLock", "(", "time", ",", "unit", ")", ";", "}"], "docstring": "Enters this monitor. Blocks at most the given time, and may be interrupted.\n\n@return whether the monitor was entered\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", ".", "Blocks", "at", "most", "the", "given", "time", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L411-L414", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhen", "original_string": "public void enterWhen(Guard guard) throws InterruptedException {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n    lock.lockInterruptibly();\n\n    boolean satisfied = false;\n    try {\n      if (!guard.isSatisfied()) {\n        await(guard, signalBeforeWaiting);\n      }\n      satisfied = true;\n    } finally {\n      if (!satisfied) {\n        leave();\n      }\n    }\n  }", "language": "java", "code": "public void enterWhen(Guard guard) throws InterruptedException {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n    lock.lockInterruptibly();\n\n    boolean satisfied = false;\n    try {\n      if (!guard.isSatisfied()) {\n        await(guard, signalBeforeWaiting);\n      }\n      satisfied = true;\n    } finally {\n      if (!satisfied) {\n        leave();\n      }\n    }\n  }", "code_tokens": ["public", "void", "enterWhen", "(", "Guard", "guard", ")", "throws", "InterruptedException", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "boolean", "signalBeforeWaiting", "=", "lock", ".", "isHeldByCurrentThread", "(", ")", ";", "lock", ".", "lockInterruptibly", "(", ")", ";", "boolean", "satisfied", "=", "false", ";", "try", "{", "if", "(", "!", "guard", ".", "isSatisfied", "(", ")", ")", "{", "await", "(", "guard", ",", "signalBeforeWaiting", ")", ";", "}", "satisfied", "=", "true", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "leave", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.\n\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "but", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L432-L451", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhen", "original_string": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean reentrant = lock.isHeldByCurrentThread();\n    long startTime = 0L;\n\n    locked:\n    {\n      if (!fair) {\n        // Check interrupt status to get behavior consistent with fair case.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n        if (lock.tryLock()) {\n          break locked;\n        }\n      }\n      startTime = initNanoTime(timeoutNanos);\n      if (!lock.tryLock(time, unit)) {\n        return false;\n      }\n    }\n\n    boolean satisfied = false;\n    boolean threw = true;\n    try {\n      satisfied =\n          guard.isSatisfied()\n              || awaitNanos(\n                  guard,\n                  (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                  reentrant);\n      threw = false;\n      return satisfied;\n    } finally {\n      if (!satisfied) {\n        try {\n          // Don't need to signal if timed out, but do if interrupted\n          if (threw && !reentrant) {\n            signalNextWaiter();\n          }\n        } finally {\n          lock.unlock();\n        }\n      }\n    }\n  }", "language": "java", "code": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean reentrant = lock.isHeldByCurrentThread();\n    long startTime = 0L;\n\n    locked:\n    {\n      if (!fair) {\n        // Check interrupt status to get behavior consistent with fair case.\n        if (Thread.interrupted()) {\n          throw new InterruptedException();\n        }\n        if (lock.tryLock()) {\n          break locked;\n        }\n      }\n      startTime = initNanoTime(timeoutNanos);\n      if (!lock.tryLock(time, unit)) {\n        return false;\n      }\n    }\n\n    boolean satisfied = false;\n    boolean threw = true;\n    try {\n      satisfied =\n          guard.isSatisfied()\n              || awaitNanos(\n                  guard,\n                  (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                  reentrant);\n      threw = false;\n      return satisfied;\n    } finally {\n      if (!satisfied) {\n        try {\n          // Don't need to signal if timed out, but do if interrupted\n          if (threw && !reentrant) {\n            signalNextWaiter();\n          }\n        } finally {\n          lock.unlock();\n        }\n      }\n    }\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// should accept a java.time.Duration", "public", "boolean", "enterWhen", "(", "Guard", "guard", ",", "long", "time", ",", "TimeUnit", "unit", ")", "throws", "InterruptedException", "{", "final", "long", "timeoutNanos", "=", "toSafeNanos", "(", "time", ",", "unit", ")", ";", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "boolean", "reentrant", "=", "lock", ".", "isHeldByCurrentThread", "(", ")", ";", "long", "startTime", "=", "0L", ";", "locked", ":", "{", "if", "(", "!", "fair", ")", "{", "// Check interrupt status to get behavior consistent with fair case.", "if", "(", "Thread", ".", "interrupted", "(", ")", ")", "{", "throw", "new", "InterruptedException", "(", ")", ";", "}", "if", "(", "lock", ".", "tryLock", "(", ")", ")", "{", "break", "locked", ";", "}", "}", "startTime", "=", "initNanoTime", "(", "timeoutNanos", ")", ";", "if", "(", "!", "lock", ".", "tryLock", "(", "time", ",", "unit", ")", ")", "{", "return", "false", ";", "}", "}", "boolean", "satisfied", "=", "false", ";", "boolean", "threw", "=", "true", ";", "try", "{", "satisfied", "=", "guard", ".", "isSatisfied", "(", ")", "||", "awaitNanos", "(", "guard", ",", "(", "startTime", "==", "0L", ")", "?", "timeoutNanos", ":", "remainingNanos", "(", "startTime", ",", "timeoutNanos", ")", ",", "reentrant", ")", ";", "threw", "=", "false", ";", "return", "satisfied", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "try", "{", "// Don't need to signal if timed out, but do if interrupted", "if", "(", "threw", "&&", "!", "reentrant", ")", "{", "signalNextWaiter", "(", ")", ";", "}", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}", "}"], "docstring": "Enters this monitor when the guard is satisfied. Blocks at most the given time, including both\nthe time to acquire the lock and the time to wait for the guard to be satisfied, and may be\ninterrupted.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "at", "most", "the", "given", "time", "including", "both", "the", "time", "to", "acquire", "the", "lock", "and", "the", "time", "to", "wait", "for", "the", "guard", "to", "be", "satisfied", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L461-L511", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterWhenUninterruptibly", "original_string": "public void enterWhenUninterruptibly(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n    lock.lock();\n\n    boolean satisfied = false;\n    try {\n      if (!guard.isSatisfied()) {\n        awaitUninterruptibly(guard, signalBeforeWaiting);\n      }\n      satisfied = true;\n    } finally {\n      if (!satisfied) {\n        leave();\n      }\n    }\n  }", "language": "java", "code": "public void enterWhenUninterruptibly(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n    lock.lock();\n\n    boolean satisfied = false;\n    try {\n      if (!guard.isSatisfied()) {\n        awaitUninterruptibly(guard, signalBeforeWaiting);\n      }\n      satisfied = true;\n    } finally {\n      if (!satisfied) {\n        leave();\n      }\n    }\n  }", "code_tokens": ["public", "void", "enterWhenUninterruptibly", "(", "Guard", "guard", ")", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "boolean", "signalBeforeWaiting", "=", "lock", ".", "isHeldByCurrentThread", "(", ")", ";", "lock", ".", "lock", "(", ")", ";", "boolean", "satisfied", "=", "false", ";", "try", "{", "if", "(", "!", "guard", ".", "isSatisfied", "(", ")", ")", "{", "awaitUninterruptibly", "(", "guard", ",", "signalBeforeWaiting", ")", ";", "}", "satisfied", "=", "true", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "leave", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor when the guard is satisfied. Blocks indefinitely.", "docstring_tokens": ["Enters", "this", "monitor", "when", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L514-L533", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIf", "original_string": "public boolean enterIf(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "language": "java", "code": "public boolean enterIf(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "code_tokens": ["public", "boolean", "enterIf", "(", "Guard", "guard", ")", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "lock", ".", "lock", "(", ")", ";", "boolean", "satisfied", "=", "false", ";", "try", "{", "return", "satisfied", "=", "guard", ".", "isSatisfied", "(", ")", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\nnot wait for the guard to be satisfied.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L608-L623", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIf", "original_string": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterIf(Guard guard, long time, TimeUnit unit) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!enter(time, unit)) {\n      return false;\n    }\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "language": "java", "code": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean enterIf(Guard guard, long time, TimeUnit unit) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!enter(time, unit)) {\n      return false;\n    }\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// should accept a java.time.Duration", "public", "boolean", "enterIf", "(", "Guard", "guard", ",", "long", "time", ",", "TimeUnit", "unit", ")", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "if", "(", "!", "enter", "(", "time", ",", "unit", ")", ")", "{", "return", "false", ";", "}", "boolean", "satisfied", "=", "false", ";", "try", "{", "return", "satisfied", "=", "guard", ".", "isSatisfied", "(", ")", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the\nlock, but does not wait for the guard to be satisfied.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "at", "most", "the", "given", "time", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L631-L648", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.enterIfInterruptibly", "original_string": "public boolean enterIfInterruptibly(Guard guard) throws InterruptedException {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "language": "java", "code": "public boolean enterIfInterruptibly(Guard guard) throws InterruptedException {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "code_tokens": ["public", "boolean", "enterIfInterruptibly", "(", "Guard", "guard", ")", "throws", "InterruptedException", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "lock", ".", "lockInterruptibly", "(", ")", ";", "boolean", "satisfied", "=", "false", ";", "try", "{", "return", "satisfied", "=", "guard", ".", "isSatisfied", "(", ")", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does\nnot wait for the guard to be satisfied, and may be interrupted.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Enters", "this", "monitor", "if", "the", "guard", "is", "satisfied", ".", "Blocks", "indefinitely", "acquiring", "the", "lock", "but", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "and", "may", "be", "interrupted", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L657-L672", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.tryEnterIf", "original_string": "public boolean tryEnterIf(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    if (!lock.tryLock()) {\n      return false;\n    }\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "language": "java", "code": "public boolean tryEnterIf(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    final ReentrantLock lock = this.lock;\n    if (!lock.tryLock()) {\n      return false;\n    }\n\n    boolean satisfied = false;\n    try {\n      return satisfied = guard.isSatisfied();\n    } finally {\n      if (!satisfied) {\n        lock.unlock();\n      }\n    }\n  }", "code_tokens": ["public", "boolean", "tryEnterIf", "(", "Guard", "guard", ")", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "if", "(", "!", "lock", ".", "tryLock", "(", ")", ")", "{", "return", "false", ";", "}", "boolean", "satisfied", "=", "false", ";", "try", "{", "return", "satisfied", "=", "guard", ".", "isSatisfied", "(", ")", ";", "}", "finally", "{", "if", "(", "!", "satisfied", ")", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "}"], "docstring": "Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not\nblock acquiring the lock and does not wait for the guard to be satisfied.\n\n<p><b>Note:</b> This method disregards the fairness setting of this monitor.\n\n@return whether the monitor was entered, which guarantees that the guard is now satisfied", "docstring_tokens": ["Enters", "this", "monitor", "if", "it", "is", "possible", "to", "do", "so", "immediately", "and", "the", "guard", "is", "satisfied", ".", "Does", "not", "block", "acquiring", "the", "lock", "and", "does", "not", "wait", "for", "the", "guard", "to", "be", "satisfied", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L709-L726", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitFor", "original_string": "public void waitFor(Guard guard) throws InterruptedException {\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!guard.isSatisfied()) {\n      await(guard, true);\n    }\n  }", "language": "java", "code": "public void waitFor(Guard guard) throws InterruptedException {\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!guard.isSatisfied()) {\n      await(guard, true);\n    }\n  }", "code_tokens": ["public", "void", "waitFor", "(", "Guard", "guard", ")", "throws", "InterruptedException", "{", "if", "(", "!", "(", "(", "guard", ".", "monitor", "==", "this", ")", "&", "lock", ".", "isHeldByCurrentThread", "(", ")", ")", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "if", "(", "!", "guard", ".", "isSatisfied", "(", ")", ")", "{", "await", "(", "guard", ",", "true", ")", ";", "}", "}"], "docstring": "Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called\nonly by a thread currently occupying this monitor.\n\n@throws InterruptedException if interrupted while waiting", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "indefinitely", "but", "may", "be", "interrupted", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L734-L741", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitForUninterruptibly", "original_string": "public void waitForUninterruptibly(Guard guard) {\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!guard.isSatisfied()) {\n      awaitUninterruptibly(guard, true);\n    }\n  }", "language": "java", "code": "public void waitForUninterruptibly(Guard guard) {\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (!guard.isSatisfied()) {\n      awaitUninterruptibly(guard, true);\n    }\n  }", "code_tokens": ["public", "void", "waitForUninterruptibly", "(", "Guard", "guard", ")", "{", "if", "(", "!", "(", "(", "guard", ".", "monitor", "==", "this", ")", "&", "lock", ".", "isHeldByCurrentThread", "(", ")", ")", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "if", "(", "!", "guard", ".", "isSatisfied", "(", ")", ")", "{", "awaitUninterruptibly", "(", "guard", ",", "true", ")", ";", "}", "}"], "docstring": "Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread\ncurrently occupying this monitor.", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "indefinitely", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L769-L776", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.waitForUninterruptibly", "original_string": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (guard.isSatisfied()) {\n      return true;\n    }\n    boolean signalBeforeWaiting = true;\n    final long startTime = initNanoTime(timeoutNanos);\n    boolean interrupted = Thread.interrupted();\n    try {\n      for (long remainingNanos = timeoutNanos; ; ) {\n        try {\n          return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          if (guard.isSatisfied()) {\n            return true;\n          }\n          signalBeforeWaiting = false;\n          remainingNanos = remainingNanos(startTime, timeoutNanos);\n        }\n      }\n    } finally {\n      if (interrupted) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }", "language": "java", "code": "@SuppressWarnings(\"GoodTime\") // should accept a java.time.Duration\n  public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {\n    final long timeoutNanos = toSafeNanos(time, unit);\n    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {\n      throw new IllegalMonitorStateException();\n    }\n    if (guard.isSatisfied()) {\n      return true;\n    }\n    boolean signalBeforeWaiting = true;\n    final long startTime = initNanoTime(timeoutNanos);\n    boolean interrupted = Thread.interrupted();\n    try {\n      for (long remainingNanos = timeoutNanos; ; ) {\n        try {\n          return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          if (guard.isSatisfied()) {\n            return true;\n          }\n          signalBeforeWaiting = false;\n          remainingNanos = remainingNanos(startTime, timeoutNanos);\n        }\n      }\n    } finally {\n      if (interrupted) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }", "code_tokens": ["@", "SuppressWarnings", "(", "\"GoodTime\"", ")", "// should accept a java.time.Duration", "public", "boolean", "waitForUninterruptibly", "(", "Guard", "guard", ",", "long", "time", ",", "TimeUnit", "unit", ")", "{", "final", "long", "timeoutNanos", "=", "toSafeNanos", "(", "time", ",", "unit", ")", ";", "if", "(", "!", "(", "(", "guard", ".", "monitor", "==", "this", ")", "&", "lock", ".", "isHeldByCurrentThread", "(", ")", ")", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "if", "(", "guard", ".", "isSatisfied", "(", ")", ")", "{", "return", "true", ";", "}", "boolean", "signalBeforeWaiting", "=", "true", ";", "final", "long", "startTime", "=", "initNanoTime", "(", "timeoutNanos", ")", ";", "boolean", "interrupted", "=", "Thread", ".", "interrupted", "(", ")", ";", "try", "{", "for", "(", "long", "remainingNanos", "=", "timeoutNanos", ";", ";", ")", "{", "try", "{", "return", "awaitNanos", "(", "guard", ",", "remainingNanos", ",", "signalBeforeWaiting", ")", ";", "}", "catch", "(", "InterruptedException", "interrupt", ")", "{", "interrupted", "=", "true", ";", "if", "(", "guard", ".", "isSatisfied", "(", ")", ")", "{", "return", "true", ";", "}", "signalBeforeWaiting", "=", "false", ";", "remainingNanos", "=", "remainingNanos", "(", "startTime", ",", "timeoutNanos", ")", ";", "}", "}", "}", "finally", "{", "if", "(", "interrupted", ")", "{", "Thread", ".", "currentThread", "(", ")", ".", "interrupt", "(", ")", ";", "}", "}", "}"], "docstring": "Waits for the guard to be satisfied. Waits at most the given time. May be called only by a\nthread currently occupying this monitor.\n\n@return whether the guard is now satisfied", "docstring_tokens": ["Waits", "for", "the", "guard", "to", "be", "satisfied", ".", "Waits", "at", "most", "the", "given", "time", ".", "May", "be", "called", "only", "by", "a", "thread", "currently", "occupying", "this", "monitor", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L784-L814", "partition": "valid"}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/util/concurrent/Monitor.java", "func_name": "Monitor.getWaitQueueLength", "original_string": "public int getWaitQueueLength(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    lock.lock();\n    try {\n      return guard.waiterCount;\n    } finally {\n      lock.unlock();\n    }\n  }", "language": "java", "code": "public int getWaitQueueLength(Guard guard) {\n    if (guard.monitor != this) {\n      throw new IllegalMonitorStateException();\n    }\n    lock.lock();\n    try {\n      return guard.waiterCount;\n    } finally {\n      lock.unlock();\n    }\n  }", "code_tokens": ["public", "int", "getWaitQueueLength", "(", "Guard", "guard", ")", "{", "if", "(", "guard", ".", "monitor", "!=", "this", ")", "{", "throw", "new", "IllegalMonitorStateException", "(", ")", ";", "}", "lock", ".", "lock", "(", ")", ";", "try", "{", "return", "guard", ".", "waiterCount", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Returns an estimate of the number of threads waiting for the given guard to become satisfied.\nNote that because timeouts and interrupts may occur at any time, the estimate serves only as an\nupper bound on the actual number of waiters. This method is designed for use in monitoring of\nthe system state, not for synchronization control.", "docstring_tokens": ["Returns", "an", "estimate", "of", "the", "number", "of", "threads", "waiting", "for", "the", "given", "guard", "to", "become", "satisfied", ".", "Note", "that", "because", "timeouts", "and", "interrupts", "may", "occur", "at", "any", "time", "the", "estimate", "serves", "only", "as", "an", "upper", "bound", "on", "the", "actual", "number", "of", "waiters", ".", "This", "method", "is", "designed", "for", "use", "in", "monitoring", "of", "the", "system", "state", "not", "for", "synchronization", "control", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/util/concurrent/Monitor.java#L904-L914", "partition": "valid"}
