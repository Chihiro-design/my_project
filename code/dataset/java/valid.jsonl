{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.copyTo", "original_string": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "@CanIgnoreReturnValue\n  public long copyTo(CharSink sink) throws IOException {\n    checkNotNull(sink);\n\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      Writer writer = closer.register(sink.openStream());\n      return CharStreams.copy(reader, writer);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["@", "CanIgnoreReturnValue", "public", "long", "copyTo", "(", "CharSink", "sink", ")", "throws", "IOException", "{", "checkNotNull", "(", "sink", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "Writer", "writer", "=", "closer", ".", "register", "(", "sink", ".", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "copy", "(", "reader", ",", "writer", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Copies the contents of this source to the given sink .", "docstring_tokens": ["Copies", "the", "contents", "of", "this", "source", "to", "the", "given", "sink", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L208-L222", "partition": "valid", "similar_code": ["public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { Reader reader = closer . register ( openStream ( ) ) ; return reader . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { InputStream in = closer . register ( openStream ( ) ) ; return in . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public static RuntimeException closeAndRethrow ( Closer closer , Throwable t ) throws IOException { try { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "static Set < String > readServiceFile ( InputStream input ) throws IOException { HashSet < String > serviceClasses = new HashSet < String > ( ) ; Closer closer = Closer . create ( ) ; try { // TODO(gak): use CharStreams BufferedReader r = closer . register ( new BufferedReader ( new InputStreamReader ( input , UTF_8 ) ) ) ; String line ; while ( ( line = r . readLine ( ) ) != null ) { int commentStart = line . indexOf ( ' ' ) ; if ( commentStart >= 0 ) { line = line . substring ( 0 , commentStart ) ; } line = line . trim ( ) ; if ( ! line . isEmpty ( ) ) { serviceClasses . add ( line ) ; } } return serviceClasses ; } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "private void copyFile ( AlluxioURI srcPath , AlluxioURI dstPath ) throws AlluxioException , IOException { try ( Closer closer = Closer . create ( ) ) { FileInStream is = closer . register ( mFileSystem . openFile ( srcPath ) ) ; FileOutStream os = closer . register ( mFileSystem . createFile ( dstPath ) ) ; try { IOUtils . copy ( is , os ) ; } catch ( Exception e ) { os . cancel ( ) ; throw e ; } System . out . println ( String . format ( COPY_SUCCEED_MESSAGE , srcPath , dstPath ) ) ; } preserveAttributes ( srcPath , dstPath ) ; }"], "similar_code_tokens": [["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "reader", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "InputStream", "in", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "in", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "static", "RuntimeException", "closeAndRethrow", "(", "Closer", "closer", ",", "Throwable", "t", ")", "throws", "IOException", "{", "try", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["static", "Set", "<", "String", ">", "readServiceFile", "(", "InputStream", "input", ")", "throws", "IOException", "{", "HashSet", "<", "String", ">", "serviceClasses", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "// TODO(gak): use CharStreams", "BufferedReader", "r", "=", "closer", ".", "register", "(", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "input", ",", "UTF_8", ")", ")", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "r", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "int", "commentStart", "=", "line", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "commentStart", ">=", "0", ")", "{", "line", "=", "line", ".", "substring", "(", "0", ",", "commentStart", ")", ";", "}", "line", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "!", "line", ".", "isEmpty", "(", ")", ")", "{", "serviceClasses", ".", "add", "(", "line", ")", ";", "}", "}", "return", "serviceClasses", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["private", "void", "copyFile", "(", "AlluxioURI", "srcPath", ",", "AlluxioURI", "dstPath", ")", "throws", "AlluxioException", ",", "IOException", "{", "try", "(", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ")", "{", "FileInStream", "is", "=", "closer", ".", "register", "(", "mFileSystem", ".", "openFile", "(", "srcPath", ")", ")", ";", "FileOutStream", "os", "=", "closer", ".", "register", "(", "mFileSystem", ".", "createFile", "(", "dstPath", ")", ")", ";", "try", "{", "IOUtils", ".", "copy", "(", "is", ",", "os", ")", ";", "}", "catch", "(", "Exception", "e", ")", "{", "os", ".", "cancel", "(", ")", ";", "throw", "e", ";", "}", "System", ".", "out", ".", "println", "(", "String", ".", "format", "(", "COPY_SUCCEED_MESSAGE", ",", "srcPath", ",", "dstPath", ")", ")", ";", "}", "preserveAttributes", "(", "srcPath", ",", "dstPath", ")", ";", "}"]], "similar_docstring": ["Returns whether the source has zero chars . The default implementation is to open a stream and check for EOF .", "Returns whether the source has zero bytes . The default implementation is to open a stream and check for EOF .", "Closes the Closer and re - throws the Throwable . Any exceptions thrown while closing the Closer will be added as suppressed exceptions to the Throwable . This method always throws the given Throwable wrapping it in a RuntimeException if it s a non - IOException checked exception .", "Reads the set of service classes from a service file .", "Copies a file in the Alluxio filesystem ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.read", "original_string": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public String read() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      Reader reader = closer.register(openStream());\n      return CharStreams.toString(reader);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "String", "read", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "CharStreams", ".", "toString", "(", "reader", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads the contents of this source as a string .", "docstring_tokens": ["Reads", "the", "contents", "of", "this", "source", "as", "a", "string", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L229-L239", "partition": "valid", "similar_code": ["public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { Reader reader = closer . register ( openStream ( ) ) ; return reader . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { InputStream in = closer . register ( openStream ( ) ) ; return in . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public static RuntimeException closeAndRethrow ( Closer closer , Throwable t ) throws IOException { try { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "static Set < String > readServiceFile ( InputStream input ) throws IOException { HashSet < String > serviceClasses = new HashSet < String > ( ) ; Closer closer = Closer . create ( ) ; try { // TODO(gak): use CharStreams BufferedReader r = closer . register ( new BufferedReader ( new InputStreamReader ( input , UTF_8 ) ) ) ; String line ; while ( ( line = r . readLine ( ) ) != null ) { int commentStart = line . indexOf ( ' ' ) ; if ( commentStart >= 0 ) { line = line . substring ( 0 , commentStart ) ; } line = line . trim ( ) ; if ( ! line . isEmpty ( ) ) { serviceClasses . add ( line ) ; } } return serviceClasses ; } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "public static void writeHints ( File file , Map < String , List < Long > > hints ) throws IOException { Closer closer = Closer . create ( ) ; try { BufferedWriter w = closer . register ( Files . newWriter ( file , Charsets . UTF_8 ) ) ; if ( ! ( hints instanceof SortedMap ) ) { hints = new TreeMap < String , List < Long > > ( hints ) ; } Joiner joiner = Joiner . on ( ' ' ) ; for ( Map . Entry < String , List < Long > > e : hints . entrySet ( ) ) { w . write ( e . getKey ( ) ) ; w . write ( \"=\" ) ; joiner . appendTo ( w , e . getValue ( ) ) ; w . write ( \"\\n\" ) ; } } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }"], "similar_code_tokens": [["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "reader", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "InputStream", "in", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "in", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "static", "RuntimeException", "closeAndRethrow", "(", "Closer", "closer", ",", "Throwable", "t", ")", "throws", "IOException", "{", "try", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["static", "Set", "<", "String", ">", "readServiceFile", "(", "InputStream", "input", ")", "throws", "IOException", "{", "HashSet", "<", "String", ">", "serviceClasses", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "// TODO(gak): use CharStreams", "BufferedReader", "r", "=", "closer", ".", "register", "(", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "input", ",", "UTF_8", ")", ")", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "r", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "int", "commentStart", "=", "line", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "commentStart", ">=", "0", ")", "{", "line", "=", "line", ".", "substring", "(", "0", ",", "commentStart", ")", ";", "}", "line", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "!", "line", ".", "isEmpty", "(", ")", ")", "{", "serviceClasses", ".", "add", "(", "line", ")", ";", "}", "}", "return", "serviceClasses", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "static", "void", "writeHints", "(", "File", "file", ",", "Map", "<", "String", ",", "List", "<", "Long", ">", ">", "hints", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "BufferedWriter", "w", "=", "closer", ".", "register", "(", "Files", ".", "newWriter", "(", "file", ",", "Charsets", ".", "UTF_8", ")", ")", ";", "if", "(", "!", "(", "hints", "instanceof", "SortedMap", ")", ")", "{", "hints", "=", "new", "TreeMap", "<", "String", ",", "List", "<", "Long", ">", ">", "(", "hints", ")", ";", "}", "Joiner", "joiner", "=", "Joiner", ".", "on", "(", "'", "'", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "List", "<", "Long", ">", ">", "e", ":", "hints", ".", "entrySet", "(", ")", ")", "{", "w", ".", "write", "(", "e", ".", "getKey", "(", ")", ")", ";", "w", ".", "write", "(", "\"=\"", ")", ";", "joiner", ".", "appendTo", "(", "w", ",", "e", ".", "getValue", "(", ")", ")", ";", "w", ".", "write", "(", "\"\\n\"", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"]], "similar_docstring": ["Returns whether the source has zero chars . The default implementation is to open a stream and check for EOF .", "Returns whether the source has zero bytes . The default implementation is to open a stream and check for EOF .", "Closes the Closer and re - throws the Throwable . Any exceptions thrown while closing the Closer will be added as suppressed exceptions to the Throwable . This method always throws the given Throwable wrapping it in a RuntimeException if it s a non - IOException checked exception .", "Reads the set of service classes from a service file .", "Writes back hints file ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/CharSource.java", "func_name": "CharSource.readLines", "original_string": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "language": "java", "code": "public ImmutableList<String> readLines() throws IOException {\n    Closer closer = Closer.create();\n    try {\n      BufferedReader reader = closer.register(openBufferedStream());\n      List<String> result = Lists.newArrayList();\n      String line;\n      while ((line = reader.readLine()) != null) {\n        result.add(line);\n      }\n      return ImmutableList.copyOf(result);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }", "code_tokens": ["public", "ImmutableList", "<", "String", ">", "readLines", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "BufferedReader", "reader", "=", "closer", ".", "register", "(", "openBufferedStream", "(", ")", ")", ";", "List", "<", "String", ">", "result", "=", "Lists", ".", "newArrayList", "(", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "reader", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "result", ".", "add", "(", "line", ")", ";", "}", "return", "ImmutableList", ".", "copyOf", "(", "result", ")", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], "docstring": "Reads all the lines of this source as a list of strings . The returned list will be empty if this source is empty .", "docstring_tokens": ["Reads", "all", "the", "lines", "of", "this", "source", "as", "a", "list", "of", "strings", ".", "The", "returned", "list", "will", "be", "empty", "if", "this", "source", "is", "empty", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/CharSource.java#L275-L290", "partition": "valid", "similar_code": ["static Set < String > readServiceFile ( InputStream input ) throws IOException { HashSet < String > serviceClasses = new HashSet < String > ( ) ; Closer closer = Closer . create ( ) ; try { // TODO(gak): use CharStreams BufferedReader r = closer . register ( new BufferedReader ( new InputStreamReader ( input , UTF_8 ) ) ) ; String line ; while ( ( line = r . readLine ( ) ) != null ) { int commentStart = line . indexOf ( ' ' ) ; if ( commentStart >= 0 ) { line = line . substring ( 0 , commentStart ) ; } line = line . trim ( ) ; if ( ! line . isEmpty ( ) ) { serviceClasses . add ( line ) ; } } return serviceClasses ; } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { Reader reader = closer . register ( openStream ( ) ) ; return reader . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public boolean isEmpty ( ) throws IOException { Closer closer = Closer . create ( ) ; try { InputStream in = closer . register ( openStream ( ) ) ; return in . read ( ) == - 1 ; } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } }", "public static void writeHints ( File file , Map < String , List < Long > > hints ) throws IOException { Closer closer = Closer . create ( ) ; try { BufferedWriter w = closer . register ( Files . newWriter ( file , Charsets . UTF_8 ) ) ; if ( ! ( hints instanceof SortedMap ) ) { hints = new TreeMap < String , List < Long > > ( hints ) ; } Joiner joiner = Joiner . on ( ' ' ) ; for ( Map . Entry < String , List < Long > > e : hints . entrySet ( ) ) { w . write ( e . getKey ( ) ) ; w . write ( \"=\" ) ; joiner . appendTo ( w , e . getValue ( ) ) ; w . write ( \"\\n\" ) ; } } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }", "public static RuntimeException closeAndRethrow ( Closer closer , Throwable t ) throws IOException { try { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } }"], "similar_code_tokens": [["static", "Set", "<", "String", ">", "readServiceFile", "(", "InputStream", "input", ")", "throws", "IOException", "{", "HashSet", "<", "String", ">", "serviceClasses", "=", "new", "HashSet", "<", "String", ">", "(", ")", ";", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "// TODO(gak): use CharStreams", "BufferedReader", "r", "=", "closer", ".", "register", "(", "new", "BufferedReader", "(", "new", "InputStreamReader", "(", "input", ",", "UTF_8", ")", ")", ")", ";", "String", "line", ";", "while", "(", "(", "line", "=", "r", ".", "readLine", "(", ")", ")", "!=", "null", ")", "{", "int", "commentStart", "=", "line", ".", "indexOf", "(", "'", "'", ")", ";", "if", "(", "commentStart", ">=", "0", ")", "{", "line", "=", "line", ".", "substring", "(", "0", ",", "commentStart", ")", ";", "}", "line", "=", "line", ".", "trim", "(", ")", ";", "if", "(", "!", "line", ".", "isEmpty", "(", ")", ")", "{", "serviceClasses", ".", "add", "(", "line", ")", ";", "}", "}", "return", "serviceClasses", ";", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "Reader", "reader", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "reader", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "boolean", "isEmpty", "(", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "InputStream", "in", "=", "closer", ".", "register", "(", "openStream", "(", ")", ")", ";", "return", "in", ".", "read", "(", ")", "==", "-", "1", ";", "}", "catch", "(", "Throwable", "e", ")", "{", "throw", "closer", ".", "rethrow", "(", "e", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "static", "void", "writeHints", "(", "File", "file", ",", "Map", "<", "String", ",", "List", "<", "Long", ">", ">", "hints", ")", "throws", "IOException", "{", "Closer", "closer", "=", "Closer", ".", "create", "(", ")", ";", "try", "{", "BufferedWriter", "w", "=", "closer", ".", "register", "(", "Files", ".", "newWriter", "(", "file", ",", "Charsets", ".", "UTF_8", ")", ")", ";", "if", "(", "!", "(", "hints", "instanceof", "SortedMap", ")", ")", "{", "hints", "=", "new", "TreeMap", "<", "String", ",", "List", "<", "Long", ">", ">", "(", "hints", ")", ";", "}", "Joiner", "joiner", "=", "Joiner", ".", "on", "(", "'", "'", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "List", "<", "Long", ">", ">", "e", ":", "hints", ".", "entrySet", "(", ")", ")", "{", "w", ".", "write", "(", "e", ".", "getKey", "(", ")", ")", ";", "w", ".", "write", "(", "\"=\"", ")", ";", "joiner", ".", "appendTo", "(", "w", ",", "e", ".", "getValue", "(", ")", ")", ";", "w", ".", "write", "(", "\"\\n\"", ")", ";", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"], ["public", "static", "RuntimeException", "closeAndRethrow", "(", "Closer", "closer", ",", "Throwable", "t", ")", "throws", "IOException", "{", "try", "{", "throw", "closer", ".", "rethrow", "(", "t", ")", ";", "}", "finally", "{", "closer", ".", "close", "(", ")", ";", "}", "}"]], "similar_docstring": ["Reads the set of service classes from a service file .", "Returns whether the source has zero chars . The default implementation is to open a stream and check for EOF .", "Returns whether the source has zero bytes . The default implementation is to open a stream and check for EOF .", "Writes back hints file .", "Closes the Closer and re - throws the Throwable . Any exceptions thrown while closing the Closer will be added as suppressed exceptions to the Throwable . This method always throws the given Throwable wrapping it in a RuntimeException if it s a non - IOException checked exception ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.read", "original_string": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "language": "java", "code": "@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    // Obey InputStream contract.\n    checkPositionIndexes(off, off + len, b.length);\n    if (len == 0) {\n      return 0;\n    }\n\n    // The rest of this method implements the process described by the CharsetEncoder javadoc.\n    int totalBytesRead = 0;\n    boolean doneEncoding = endOfInput;\n\n    DRAINING:\n    while (true) {\n      // We stay in draining mode until there are no bytes left in the output buffer. Then we go\n      // back to encoding/flushing.\n      if (draining) {\n        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);\n        if (totalBytesRead == len || doneFlushing) {\n          return (totalBytesRead > 0) ? totalBytesRead : -1;\n        }\n        draining = false;\n        byteBuffer.clear();\n      }\n\n      while (true) {\n        // We call encode until there is no more input. The last call to encode will have endOfInput\n        // == true. Then there is a final call to flush.\n        CoderResult result;\n        if (doneFlushing) {\n          result = CoderResult.UNDERFLOW;\n        } else if (doneEncoding) {\n          result = encoder.flush(byteBuffer);\n        } else {\n          result = encoder.encode(charBuffer, byteBuffer, endOfInput);\n        }\n\n        if (result.isOverflow()) {\n          // Not enough room in output buffer--drain it, creating a bigger buffer if necessary.\n          startDraining(true);\n          continue DRAINING;\n        } else if (result.isUnderflow()) {\n          // If encoder underflows, it means either:\n          // a) the final flush() succeeded; next drain (then done)\n          // b) we encoded all of the input; next flush\n          // c) we ran of out input to encode; next read more input\n          if (doneEncoding) { // (a)\n            doneFlushing = true;\n            startDraining(false);\n            continue DRAINING;\n          } else if (endOfInput) { // (b)\n            doneEncoding = true;\n          } else { // (c)\n            readMoreChars();\n          }\n        } else if (result.isError()) {\n          // Only reach here if a CharsetEncoder with non-REPLACE settings is used.\n          result.throwException();\n          return 0; // Not called.\n        }\n      }\n    }\n  }", "code_tokens": ["@", "Override", "public", "int", "read", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Obey InputStream contract.", "checkPositionIndexes", "(", "off", ",", "off", "+", "len", ",", "b", ".", "length", ")", ";", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "// The rest of this method implements the process described by the CharsetEncoder javadoc.", "int", "totalBytesRead", "=", "0", ";", "boolean", "doneEncoding", "=", "endOfInput", ";", "DRAINING", ":", "while", "(", "true", ")", "{", "// We stay in draining mode until there are no bytes left in the output buffer. Then we go", "// back to encoding/flushing.", "if", "(", "draining", ")", "{", "totalBytesRead", "+=", "drain", "(", "b", ",", "off", "+", "totalBytesRead", ",", "len", "-", "totalBytesRead", ")", ";", "if", "(", "totalBytesRead", "==", "len", "||", "doneFlushing", ")", "{", "return", "(", "totalBytesRead", ">", "0", ")", "?", "totalBytesRead", ":", "-", "1", ";", "}", "draining", "=", "false", ";", "byteBuffer", ".", "clear", "(", ")", ";", "}", "while", "(", "true", ")", "{", "// We call encode until there is no more input. The last call to encode will have endOfInput", "// == true. Then there is a final call to flush.", "CoderResult", "result", ";", "if", "(", "doneFlushing", ")", "{", "result", "=", "CoderResult", ".", "UNDERFLOW", ";", "}", "else", "if", "(", "doneEncoding", ")", "{", "result", "=", "encoder", ".", "flush", "(", "byteBuffer", ")", ";", "}", "else", "{", "result", "=", "encoder", ".", "encode", "(", "charBuffer", ",", "byteBuffer", ",", "endOfInput", ")", ";", "}", "if", "(", "result", ".", "isOverflow", "(", ")", ")", "{", "// Not enough room in output buffer--drain it, creating a bigger buffer if necessary.", "startDraining", "(", "true", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "result", ".", "isUnderflow", "(", ")", ")", "{", "// If encoder underflows, it means either:", "// a) the final flush() succeeded; next drain (then done)", "// b) we encoded all of the input; next flush", "// c) we ran of out input to encode; next read more input", "if", "(", "doneEncoding", ")", "{", "// (a)", "doneFlushing", "=", "true", ";", "startDraining", "(", "false", ")", ";", "continue", "DRAINING", ";", "}", "else", "if", "(", "endOfInput", ")", "{", "// (b)", "doneEncoding", "=", "true", ";", "}", "else", "{", "// (c)", "readMoreChars", "(", ")", ";", "}", "}", "else", "if", "(", "result", ".", "isError", "(", ")", ")", "{", "// Only reach here if a CharsetEncoder with non-REPLACE settings is used.", "result", ".", "throwException", "(", ")", ";", "return", "0", ";", "// Not called.", "}", "}", "}", "}"], "docstring": "buffer when possible .", "docstring_tokens": ["buffer", "when", "possible", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L124-L186", "partition": "valid", "similar_code": ["public long readUnconsumedDecData ( ) { long totalBytesRead = 0L ; // Determine if data is left over from a former read request. if ( unconsumedDecData != null ) { // Left over data exists. Is there enough to satisfy the request? if ( getBuffer ( ) == null ) { // Caller needs us to allocate the buffer to return. if ( TraceComponent . isAnyTracingEnabled ( ) && tc . isDebugEnabled ( ) ) { Tr . debug ( tc , \"Caller needs buffer, unconsumed data: \" + SSLUtils . getBufferTraceInfo ( unconsumedDecData ) ) ; } // Note, data of unconsumedDecData buffer array should be starting // at position 0 in the first buffer. totalBytesRead = SSLUtils . lengthOf ( unconsumedDecData , 0 ) ; // First release any existing buffers in decryptedNetBuffers array. cleanupDecBuffers ( ) ; callerRequiredAllocation = true ; // Note, it is the responsibility of the calling channel to release this buffer. decryptedNetBuffers = unconsumedDecData ; // Set left over buffers to null to note that they are no longer in use. unconsumedDecData = null ; if ( ( decryptedNetLimitInfo == null ) || ( decryptedNetLimitInfo . length != decryptedNetBuffers . length ) ) { decryptedNetLimitInfo = new int [ decryptedNetBuffers . length ] ; } SSLUtils . getBufferLimits ( decryptedNetBuffers , decryptedNetLimitInfo ) ; } else { // Caller provided buffers for read. We need to copy the left over // data to those buffers. if ( TraceComponent . isAnyTracingEnabled ( ) && tc . isDebugEnabled ( ) ) { Tr . debug ( tc , \"Caller provided buffers, unconsumed data: \" + SSLUtils . getBufferTraceInfo ( unconsumedDecData ) ) ; } // First release any existing buffers in decryptedNetBuffers array. cleanupDecBuffers ( ) ; // The unconsumedDecData buffers have the data to copy to the user buffers. // The copyDataToCallerBuffers method copies from decryptedNetBuffers, so assign it. decryptedNetBuffers = unconsumedDecData ; // Copy the outputbuffer to the buffers provided by the caller. totalBytesRead = copyDataToCallerBuffers ( ) ; // Null out the reference to the overflow buffers. decryptedNetBuffers = null ; } } return totalBytesRead ; }", "public static CodedInputStream newInstance ( final byte [ ] buf , final int off , final int len ) { CodedInputStream result = new CodedInputStream ( buf , off , len ) ; try { // Some uses of CodedInputStream can be more efficient if they know // exactly how many bytes are available.  By pushing the end point of the // buffer as a limit, we allow them to get this information via // getBytesUntilLimit().  Pushing a limit that we know is at the end of // the stream can never hurt, since we can never past that point anyway. result . pushLimit ( len ) ; } catch ( InvalidProtocolBufferException ex ) { // The only reason pushLimit() might throw an exception here is if len // is negative. Normally pushLimit()'s parameter comes directly off the // wire, so it's important to catch exceptions in case of corrupt or // malicious data. However, in this case, we expect that len is not a // user-supplied value, so we can assume that it being negative indicates // a programming error. Therefore, throwing an unchecked exception is // appropriate. throw new IllegalArgumentException ( ex ) ; } return result ; }", "@ Override public synchronized int read ( byte buf [ ] , int off , int len ) throws IOException { dfsClient . checkOpen ( ) ; if ( closed ) { dfsClient . incReadExpCntToStats ( ) ; throw new IOException ( \"Stream closed\" ) ; } DFSClient . dfsInputStreamfailures . set ( 0 ) ; long start = System . currentTimeMillis ( ) ; if ( pos < getFileLength ( ) || ( pos == getFileLength ( ) && len == 0 ) ) { int retries = 2 ; while ( retries > 0 ) { try { // If position equals or is larger than the end position of the // block, we try to seek to the next block, unless: // 1. user tries to read 0 bytes (usually by available() call), AND // 2. there is at least a known block for the file (blockEnd != -1), AND // 3. pos is the end of the file, AND // 4. the end of the block is the end of the file //    (the current block is the known last block of the file) // For this case, we want to stay in the current block, as in the case // that it is the last block (which is almost always true given // len == 0), the current block is the under-construction block whose size // you want to update. // if ( len == 0 ) { // called by available() if ( blockEnd == - 1 // No current block selected || pos == getFileLength ( ) ) { // at the end of the file currentNode = blockSeekTo ( pos , false ) ; if ( currentNode == null ) { // In this case, user wants to know available information of // the file, but the file doesn't have any block created yet (it // is a 0 size file). Simply 0 should be returned. return 0 ; } } else { throw new IOException ( \"Try to read 0 bytes while current position is not the end of the file\" ) ; } } else if ( pos > blockEnd || ( this . isCurrentBlockUnderConstruction && blockReader != null && blockReader . eos && blockReader . available ( ) == 0 ) ) { currentNode = blockSeekTo ( pos , true ) ; } int realLen = ( int ) Math . min ( ( long ) len , ( blockEnd - pos + 1L ) ) ; int result = readBuffer ( buf , off , realLen ) ; if ( result >= 0 ) { pos += result ; } else if ( len != 0 ) { // got a EOS from reader though we expect more data on it. throw new IOException ( \"Unexpected EOS from the reader\" ) ; } if ( dfsClient . stats != null && result != - 1 ) { dfsClient . stats . incrementBytesRead ( result ) ; } long timeval = System . currentTimeMillis ( ) - start ; dfsClient . metrics . incReadTime ( timeval ) ; dfsClient . metrics . incReadSize ( result ) ; dfsClient . metrics . incReadOps ( ) ; return ( result >= 0 ) ? result : 0 ; } catch ( InterruptedIOException iie ) { throw iie ; } catch ( ChecksumException ce ) { dfsClient . incReadExpCntToStats ( ) ; throw ce ; } catch ( IOException e ) { dfsClient . incReadExpCntToStats ( ) ; if ( retries == 1 ) { DFSClient . LOG . warn ( \"DFS Read: \" + StringUtils . stringifyException ( e ) ) ; } blockEnd = - 1 ; if ( currentNode != null ) { addToDeadNodes ( currentNode ) ; } if ( -- retries == 0 ) { if ( len != 0 ) { throw e ; } else { // When called by available(). No need to fail the query. In that case // available() value might not be updated, but it's OK. return 0 ; } } } } } return - 1 ; }", "public int read ( byte [ ] b , int off , int len ) throws IOException { // Sanity checks ensureOpen ( ) ; if ( b == null ) { throw new NullPointerException ( \"Null buffer for read\" ) ; } else if ( off < 0 || len < 0 || len > b . length - off ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return 0 ; } // Read and compress (deflate) input data bytes int cnt = 0 ; while ( len > 0 && ! def . finished ( ) ) { int n ; // Read data from the input stream if ( def . needsInput ( ) ) { n = in . read ( buf , 0 , buf . length ) ; if ( n < 0 ) { // End of the input stream reached def . finish ( ) ; } else if ( n > 0 ) { def . setInput ( buf , 0 , n ) ; } } // Compress the input data, filling the read buffer n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } // Android-changed: set reachEOF eagerly (not just when the number of bytes is zero). // so that available is more accurate. if ( def . finished ( ) ) { reachEOF = true ; if ( cnt == 0 ) { cnt = - 1 ; } } return cnt ; }", "private int readBytes ( byte [ ] b , int offs , int len ) throws BitstreamException { int totalBytesRead = 0 ; try { while ( len > 0 ) { int bytesread = source . read ( b , offs , len ) ; if ( bytesread == - 1 ) { break ; } totalBytesRead += bytesread ; offs += bytesread ; len -= bytesread ; } } catch ( IOException ex ) { throw newBitstreamException ( STREAM_ERROR , ex ) ; } return totalBytesRead ; }"], "similar_code_tokens": [["public", "long", "readUnconsumedDecData", "(", ")", "{", "long", "totalBytesRead", "=", "0L", ";", "// Determine if data is left over from a former read request.", "if", "(", "unconsumedDecData", "!=", "null", ")", "{", "// Left over data exists. Is there enough to satisfy the request?", "if", "(", "getBuffer", "(", ")", "==", "null", ")", "{", "// Caller needs us to allocate the buffer to return.", "if", "(", "TraceComponent", ".", "isAnyTracingEnabled", "(", ")", "&&", "tc", ".", "isDebugEnabled", "(", ")", ")", "{", "Tr", ".", "debug", "(", "tc", ",", "\"Caller needs buffer, unconsumed data: \"", "+", "SSLUtils", ".", "getBufferTraceInfo", "(", "unconsumedDecData", ")", ")", ";", "}", "// Note, data of unconsumedDecData buffer array should be starting", "// at position 0 in the first buffer.", "totalBytesRead", "=", "SSLUtils", ".", "lengthOf", "(", "unconsumedDecData", ",", "0", ")", ";", "// First release any existing buffers in decryptedNetBuffers array.", "cleanupDecBuffers", "(", ")", ";", "callerRequiredAllocation", "=", "true", ";", "// Note, it is the responsibility of the calling channel to release this buffer.", "decryptedNetBuffers", "=", "unconsumedDecData", ";", "// Set left over buffers to null to note that they are no longer in use.", "unconsumedDecData", "=", "null", ";", "if", "(", "(", "decryptedNetLimitInfo", "==", "null", ")", "||", "(", "decryptedNetLimitInfo", ".", "length", "!=", "decryptedNetBuffers", ".", "length", ")", ")", "{", "decryptedNetLimitInfo", "=", "new", "int", "[", "decryptedNetBuffers", ".", "length", "]", ";", "}", "SSLUtils", ".", "getBufferLimits", "(", "decryptedNetBuffers", ",", "decryptedNetLimitInfo", ")", ";", "}", "else", "{", "// Caller provided buffers for read. We need to copy the left over", "// data to those buffers.", "if", "(", "TraceComponent", ".", "isAnyTracingEnabled", "(", ")", "&&", "tc", ".", "isDebugEnabled", "(", ")", ")", "{", "Tr", ".", "debug", "(", "tc", ",", "\"Caller provided buffers, unconsumed data: \"", "+", "SSLUtils", ".", "getBufferTraceInfo", "(", "unconsumedDecData", ")", ")", ";", "}", "// First release any existing buffers in decryptedNetBuffers array.", "cleanupDecBuffers", "(", ")", ";", "// The unconsumedDecData buffers have the data to copy to the user buffers.", "// The copyDataToCallerBuffers method copies from decryptedNetBuffers, so assign it.", "decryptedNetBuffers", "=", "unconsumedDecData", ";", "// Copy the outputbuffer to the buffers provided by the caller.", "totalBytesRead", "=", "copyDataToCallerBuffers", "(", ")", ";", "// Null out the reference to the overflow buffers.", "decryptedNetBuffers", "=", "null", ";", "}", "}", "return", "totalBytesRead", ";", "}"], ["public", "static", "CodedInputStream", "newInstance", "(", "final", "byte", "[", "]", "buf", ",", "final", "int", "off", ",", "final", "int", "len", ")", "{", "CodedInputStream", "result", "=", "new", "CodedInputStream", "(", "buf", ",", "off", ",", "len", ")", ";", "try", "{", "// Some uses of CodedInputStream can be more efficient if they know", "// exactly how many bytes are available.  By pushing the end point of the", "// buffer as a limit, we allow them to get this information via", "// getBytesUntilLimit().  Pushing a limit that we know is at the end of", "// the stream can never hurt, since we can never past that point anyway.", "result", ".", "pushLimit", "(", "len", ")", ";", "}", "catch", "(", "InvalidProtocolBufferException", "ex", ")", "{", "// The only reason pushLimit() might throw an exception here is if len", "// is negative. Normally pushLimit()'s parameter comes directly off the", "// wire, so it's important to catch exceptions in case of corrupt or", "// malicious data. However, in this case, we expect that len is not a", "// user-supplied value, so we can assume that it being negative indicates", "// a programming error. Therefore, throwing an unchecked exception is", "// appropriate.", "throw", "new", "IllegalArgumentException", "(", "ex", ")", ";", "}", "return", "result", ";", "}"], ["@", "Override", "public", "synchronized", "int", "read", "(", "byte", "buf", "[", "]", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "dfsClient", ".", "checkOpen", "(", ")", ";", "if", "(", "closed", ")", "{", "dfsClient", ".", "incReadExpCntToStats", "(", ")", ";", "throw", "new", "IOException", "(", "\"Stream closed\"", ")", ";", "}", "DFSClient", ".", "dfsInputStreamfailures", ".", "set", "(", "0", ")", ";", "long", "start", "=", "System", ".", "currentTimeMillis", "(", ")", ";", "if", "(", "pos", "<", "getFileLength", "(", ")", "||", "(", "pos", "==", "getFileLength", "(", ")", "&&", "len", "==", "0", ")", ")", "{", "int", "retries", "=", "2", ";", "while", "(", "retries", ">", "0", ")", "{", "try", "{", "// If position equals or is larger than the end position of the", "// block, we try to seek to the next block, unless:", "// 1. user tries to read 0 bytes (usually by available() call), AND", "// 2. there is at least a known block for the file (blockEnd != -1), AND", "// 3. pos is the end of the file, AND", "// 4. the end of the block is the end of the file", "//    (the current block is the known last block of the file)", "// For this case, we want to stay in the current block, as in the case", "// that it is the last block (which is almost always true given", "// len == 0), the current block is the under-construction block whose size", "// you want to update.", "//", "if", "(", "len", "==", "0", ")", "{", "// called by available()", "if", "(", "blockEnd", "==", "-", "1", "// No current block selected", "||", "pos", "==", "getFileLength", "(", ")", ")", "{", "// at the end of the file", "currentNode", "=", "blockSeekTo", "(", "pos", ",", "false", ")", ";", "if", "(", "currentNode", "==", "null", ")", "{", "// In this case, user wants to know available information of", "// the file, but the file doesn't have any block created yet (it", "// is a 0 size file). Simply 0 should be returned.", "return", "0", ";", "}", "}", "else", "{", "throw", "new", "IOException", "(", "\"Try to read 0 bytes while current position is not the end of the file\"", ")", ";", "}", "}", "else", "if", "(", "pos", ">", "blockEnd", "||", "(", "this", ".", "isCurrentBlockUnderConstruction", "&&", "blockReader", "!=", "null", "&&", "blockReader", ".", "eos", "&&", "blockReader", ".", "available", "(", ")", "==", "0", ")", ")", "{", "currentNode", "=", "blockSeekTo", "(", "pos", ",", "true", ")", ";", "}", "int", "realLen", "=", "(", "int", ")", "Math", ".", "min", "(", "(", "long", ")", "len", ",", "(", "blockEnd", "-", "pos", "+", "1L", ")", ")", ";", "int", "result", "=", "readBuffer", "(", "buf", ",", "off", ",", "realLen", ")", ";", "if", "(", "result", ">=", "0", ")", "{", "pos", "+=", "result", ";", "}", "else", "if", "(", "len", "!=", "0", ")", "{", "// got a EOS from reader though we expect more data on it.", "throw", "new", "IOException", "(", "\"Unexpected EOS from the reader\"", ")", ";", "}", "if", "(", "dfsClient", ".", "stats", "!=", "null", "&&", "result", "!=", "-", "1", ")", "{", "dfsClient", ".", "stats", ".", "incrementBytesRead", "(", "result", ")", ";", "}", "long", "timeval", "=", "System", ".", "currentTimeMillis", "(", ")", "-", "start", ";", "dfsClient", ".", "metrics", ".", "incReadTime", "(", "timeval", ")", ";", "dfsClient", ".", "metrics", ".", "incReadSize", "(", "result", ")", ";", "dfsClient", ".", "metrics", ".", "incReadOps", "(", ")", ";", "return", "(", "result", ">=", "0", ")", "?", "result", ":", "0", ";", "}", "catch", "(", "InterruptedIOException", "iie", ")", "{", "throw", "iie", ";", "}", "catch", "(", "ChecksumException", "ce", ")", "{", "dfsClient", ".", "incReadExpCntToStats", "(", ")", ";", "throw", "ce", ";", "}", "catch", "(", "IOException", "e", ")", "{", "dfsClient", ".", "incReadExpCntToStats", "(", ")", ";", "if", "(", "retries", "==", "1", ")", "{", "DFSClient", ".", "LOG", ".", "warn", "(", "\"DFS Read: \"", "+", "StringUtils", ".", "stringifyException", "(", "e", ")", ")", ";", "}", "blockEnd", "=", "-", "1", ";", "if", "(", "currentNode", "!=", "null", ")", "{", "addToDeadNodes", "(", "currentNode", ")", ";", "}", "if", "(", "--", "retries", "==", "0", ")", "{", "if", "(", "len", "!=", "0", ")", "{", "throw", "e", ";", "}", "else", "{", "// When called by available(). No need to fail the query. In that case", "// available() value might not be updated, but it's OK.", "return", "0", ";", "}", "}", "}", "}", "}", "return", "-", "1", ";", "}"], ["public", "int", "read", "(", "byte", "[", "]", "b", ",", "int", "off", ",", "int", "len", ")", "throws", "IOException", "{", "// Sanity checks", "ensureOpen", "(", ")", ";", "if", "(", "b", "==", "null", ")", "{", "throw", "new", "NullPointerException", "(", "\"Null buffer for read\"", ")", ";", "}", "else", "if", "(", "off", "<", "0", "||", "len", "<", "0", "||", "len", ">", "b", ".", "length", "-", "off", ")", "{", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "}", "else", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "// Read and compress (deflate) input data bytes", "int", "cnt", "=", "0", ";", "while", "(", "len", ">", "0", "&&", "!", "def", ".", "finished", "(", ")", ")", "{", "int", "n", ";", "// Read data from the input stream", "if", "(", "def", ".", "needsInput", "(", ")", ")", "{", "n", "=", "in", ".", "read", "(", "buf", ",", "0", ",", "buf", ".", "length", ")", ";", "if", "(", "n", "<", "0", ")", "{", "// End of the input stream reached", "def", ".", "finish", "(", ")", ";", "}", "else", "if", "(", "n", ">", "0", ")", "{", "def", ".", "setInput", "(", "buf", ",", "0", ",", "n", ")", ";", "}", "}", "// Compress the input data, filling the read buffer", "n", "=", "def", ".", "deflate", "(", "b", ",", "off", ",", "len", ")", ";", "cnt", "+=", "n", ";", "off", "+=", "n", ";", "len", "-=", "n", ";", "}", "// Android-changed: set reachEOF eagerly (not just when the number of bytes is zero).", "// so that available is more accurate.", "if", "(", "def", ".", "finished", "(", ")", ")", "{", "reachEOF", "=", "true", ";", "if", "(", "cnt", "==", "0", ")", "{", "cnt", "=", "-", "1", ";", "}", "}", "return", "cnt", ";", "}"], ["private", "int", "readBytes", "(", "byte", "[", "]", "b", ",", "int", "offs", ",", "int", "len", ")", "throws", "BitstreamException", "{", "int", "totalBytesRead", "=", "0", ";", "try", "{", "while", "(", "len", ">", "0", ")", "{", "int", "bytesread", "=", "source", ".", "read", "(", "b", ",", "offs", ",", "len", ")", ";", "if", "(", "bytesread", "==", "-", "1", ")", "{", "break", ";", "}", "totalBytesRead", "+=", "bytesread", ";", "offs", "+=", "bytesread", ";", "len", "-=", "bytesread", ";", "}", "}", "catch", "(", "IOException", "ex", ")", "{", "throw", "newBitstreamException", "(", "STREAM_ERROR", ",", "ex", ")", ";", "}", "return", "totalBytesRead", ";", "}"]], "similar_docstring": ["This method is called when a read is requested . It checks to see if any data is left over from the previous read but there wasn t space in the buffers to store the result .", "Create a new CodedInputStream wrapping the given byte array slice .", "Read the entire buffer .", "Reads compressed data into a byte array . This method will block until some input can be read and compressed .", "Simlar to readFully but doesn t throw exception when EOF is reached ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.grow", "original_string": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "language": "java", "code": "private static CharBuffer grow(CharBuffer buf) {\n    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n    CharBuffer bigger = CharBuffer.wrap(copy);\n    bigger.position(buf.position());\n    bigger.limit(buf.limit());\n    return bigger;\n  }", "code_tokens": ["private", "static", "CharBuffer", "grow", "(", "CharBuffer", "buf", ")", "{", "char", "[", "]", "copy", "=", "Arrays", ".", "copyOf", "(", "buf", ".", "array", "(", ")", ",", "buf", ".", "capacity", "(", ")", "*", "2", ")", ";", "CharBuffer", "bigger", "=", "CharBuffer", ".", "wrap", "(", "copy", ")", ";", "bigger", ".", "position", "(", "buf", ".", "position", "(", ")", ")", ";", "bigger", ".", "limit", "(", "buf", ".", "limit", "(", ")", ")", ";", "return", "bigger", ";", "}"], "docstring": "Returns a new CharBuffer identical to buf except twice the capacity .", "docstring_tokens": ["Returns", "a", "new", "CharBuffer", "identical", "to", "buf", "except", "twice", "the", "capacity", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L189-L195", "partition": "valid", "similar_code": ["private boolean makeSpace ( ) { clearCaches ( ) ; int offset = savedScannerPosition == - 1 ? position : savedScannerPosition ; buf . position ( offset ) ; // Gain space by compacting buffer if ( offset > 0 ) { buf . compact ( ) ; translateSavedIndexes ( offset ) ; position -= offset ; buf . flip ( ) ; return true ; } // Gain space by growing buffer int newSize = buf . capacity ( ) * 2 ; CharBuffer newBuf = CharBuffer . allocate ( newSize ) ; newBuf . put ( buf ) ; newBuf . flip ( ) ; translateSavedIndexes ( offset ) ; position -= offset ; buf = newBuf ; matcher . reset ( buf ) ; return true ; }", "private byte [ ] toByteArray ( char [ ] chars , Charset charset ) { assert chars != null ; CharBuffer charBuffer = CharBuffer . wrap ( chars ) ; ByteBuffer byteBuffer = charset . encode ( charBuffer ) ; byte [ ] bytes = Arrays . copyOfRange ( byteBuffer . array ( ) , byteBuffer . position ( ) , byteBuffer . limit ( ) ) ; Arrays . fill ( byteBuffer . array ( ) , ( byte ) 0 ) ; // clear sensitive data return bytes ; }", "public static byte [ ] toBytes ( char [ ] chars ) { final CharBuffer charBuffer = CharBuffer . wrap ( chars ) ; final ByteBuffer byteBuffer = Charset . forName ( \"UTF-8\" ) . encode ( charBuffer ) ; final byte [ ] bytes = Arrays . copyOfRange ( byteBuffer . array ( ) , byteBuffer . position ( ) , byteBuffer . limit ( ) ) ; Arrays . fill ( charBuffer . array ( ) , ' ' ) ; // clear sensitive data Arrays . fill ( byteBuffer . array ( ) , ( byte ) 0 ) ; // clear sensitive data return bytes ; }", "private void readInput ( ) { if ( buf . limit ( ) == buf . capacity ( ) ) makeSpace ( ) ; // Prepare to receive data int p = buf . position ( ) ; buf . position ( buf . limit ( ) ) ; buf . limit ( buf . capacity ( ) ) ; int n = 0 ; try { n = source . read ( buf ) ; } catch ( IOException ioe ) { lastException = ioe ; n = - 1 ; } if ( n == - 1 ) { sourceClosed = true ; needInput = false ; } if ( n > 0 ) needInput = false ; // Restore current position and limit for reading buf . limit ( buf . position ( ) ) ; buf . position ( p ) ; // Android-changed: The matcher implementation eagerly calls toString() so we'll have // to update its input whenever the buffer limit, position etc. changes. matcher . reset ( buf ) ; }", "public int read ( CharBuffer buf , int length ) throws IOException { int len = buf . length ( ) ; buf . length ( len + length ) ; int readLength = read ( buf . buffer ( ) , len , length ) ; if ( readLength < 0 ) { buf . length ( len ) ; } else if ( readLength < length ) { buf . length ( len + readLength ) ; } return length ; }"], "similar_code_tokens": [["private", "boolean", "makeSpace", "(", ")", "{", "clearCaches", "(", ")", ";", "int", "offset", "=", "savedScannerPosition", "==", "-", "1", "?", "position", ":", "savedScannerPosition", ";", "buf", ".", "position", "(", "offset", ")", ";", "// Gain space by compacting buffer", "if", "(", "offset", ">", "0", ")", "{", "buf", ".", "compact", "(", ")", ";", "translateSavedIndexes", "(", "offset", ")", ";", "position", "-=", "offset", ";", "buf", ".", "flip", "(", ")", ";", "return", "true", ";", "}", "// Gain space by growing buffer", "int", "newSize", "=", "buf", ".", "capacity", "(", ")", "*", "2", ";", "CharBuffer", "newBuf", "=", "CharBuffer", ".", "allocate", "(", "newSize", ")", ";", "newBuf", ".", "put", "(", "buf", ")", ";", "newBuf", ".", "flip", "(", ")", ";", "translateSavedIndexes", "(", "offset", ")", ";", "position", "-=", "offset", ";", "buf", "=", "newBuf", ";", "matcher", ".", "reset", "(", "buf", ")", ";", "return", "true", ";", "}"], ["private", "byte", "[", "]", "toByteArray", "(", "char", "[", "]", "chars", ",", "Charset", "charset", ")", "{", "assert", "chars", "!=", "null", ";", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "chars", ")", ";", "ByteBuffer", "byteBuffer", "=", "charset", ".", "encode", "(", "charBuffer", ")", ";", "byte", "[", "]", "bytes", "=", "Arrays", ".", "copyOfRange", "(", "byteBuffer", ".", "array", "(", ")", ",", "byteBuffer", ".", "position", "(", ")", ",", "byteBuffer", ".", "limit", "(", ")", ")", ";", "Arrays", ".", "fill", "(", "byteBuffer", ".", "array", "(", ")", ",", "(", "byte", ")", "0", ")", ";", "// clear sensitive data", "return", "bytes", ";", "}"], ["public", "static", "byte", "[", "]", "toBytes", "(", "char", "[", "]", "chars", ")", "{", "final", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "chars", ")", ";", "final", "ByteBuffer", "byteBuffer", "=", "Charset", ".", "forName", "(", "\"UTF-8\"", ")", ".", "encode", "(", "charBuffer", ")", ";", "final", "byte", "[", "]", "bytes", "=", "Arrays", ".", "copyOfRange", "(", "byteBuffer", ".", "array", "(", ")", ",", "byteBuffer", ".", "position", "(", ")", ",", "byteBuffer", ".", "limit", "(", ")", ")", ";", "Arrays", ".", "fill", "(", "charBuffer", ".", "array", "(", ")", ",", "'", "'", ")", ";", "// clear sensitive data", "Arrays", ".", "fill", "(", "byteBuffer", ".", "array", "(", ")", ",", "(", "byte", ")", "0", ")", ";", "// clear sensitive data", "return", "bytes", ";", "}"], ["private", "void", "readInput", "(", ")", "{", "if", "(", "buf", ".", "limit", "(", ")", "==", "buf", ".", "capacity", "(", ")", ")", "makeSpace", "(", ")", ";", "// Prepare to receive data", "int", "p", "=", "buf", ".", "position", "(", ")", ";", "buf", ".", "position", "(", "buf", ".", "limit", "(", ")", ")", ";", "buf", ".", "limit", "(", "buf", ".", "capacity", "(", ")", ")", ";", "int", "n", "=", "0", ";", "try", "{", "n", "=", "source", ".", "read", "(", "buf", ")", ";", "}", "catch", "(", "IOException", "ioe", ")", "{", "lastException", "=", "ioe", ";", "n", "=", "-", "1", ";", "}", "if", "(", "n", "==", "-", "1", ")", "{", "sourceClosed", "=", "true", ";", "needInput", "=", "false", ";", "}", "if", "(", "n", ">", "0", ")", "needInput", "=", "false", ";", "// Restore current position and limit for reading", "buf", ".", "limit", "(", "buf", ".", "position", "(", ")", ")", ";", "buf", ".", "position", "(", "p", ")", ";", "// Android-changed: The matcher implementation eagerly calls toString() so we'll have", "// to update its input whenever the buffer limit, position etc. changes.", "matcher", ".", "reset", "(", "buf", ")", ";", "}"], ["public", "int", "read", "(", "CharBuffer", "buf", ",", "int", "length", ")", "throws", "IOException", "{", "int", "len", "=", "buf", ".", "length", "(", ")", ";", "buf", ".", "length", "(", "len", "+", "length", ")", ";", "int", "readLength", "=", "read", "(", "buf", ".", "buffer", "(", ")", ",", "len", ",", "length", ")", ";", "if", "(", "readLength", "<", "0", ")", "{", "buf", ".", "length", "(", "len", ")", ";", "}", "else", "if", "(", "readLength", "<", "length", ")", "{", "buf", ".", "length", "(", "len", "+", "readLength", ")", ";", "}", "return", "length", ";", "}"]], "similar_docstring": ["or else there will be space in the buffer", "Converts the given char array to a UTF - 8 encoded byte array .", "Converts a char array to a byte array without the use of Strings .", "Tries to read more input . May block .", "Reads characters from the stream appending to the character buffer ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.readMoreChars", "original_string": "private void readMoreChars() throws IOException {\n    // Possibilities:\n    // 1) array has space available on right hand side (between limit and capacity)\n    // 2) array has space available on left hand side (before position)\n    // 3) array has no space available\n    //\n    // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n    // array, then they both become case 1.\n\n    if (availableCapacity(charBuffer) == 0) {\n      if (charBuffer.position() > 0) {\n        // (2) There is room in the buffer. Move existing bytes to the beginning.\n        charBuffer.compact().flip();\n      } else {\n        // (3) Entire buffer is full, need bigger buffer.\n        charBuffer = grow(charBuffer);\n      }\n    }\n\n    // (1) Read more characters into free space at end of array.\n    int limit = charBuffer.limit();\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n    if (numChars == -1) {\n      endOfInput = true;\n    } else {\n      charBuffer.limit(limit + numChars);\n    }\n  }", "language": "java", "code": "private void readMoreChars() throws IOException {\n    // Possibilities:\n    // 1) array has space available on right hand side (between limit and capacity)\n    // 2) array has space available on left hand side (before position)\n    // 3) array has no space available\n    //\n    // In case 2 we shift the existing chars to the left, and in case 3 we create a bigger\n    // array, then they both become case 1.\n\n    if (availableCapacity(charBuffer) == 0) {\n      if (charBuffer.position() > 0) {\n        // (2) There is room in the buffer. Move existing bytes to the beginning.\n        charBuffer.compact().flip();\n      } else {\n        // (3) Entire buffer is full, need bigger buffer.\n        charBuffer = grow(charBuffer);\n      }\n    }\n\n    // (1) Read more characters into free space at end of array.\n    int limit = charBuffer.limit();\n    int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n    if (numChars == -1) {\n      endOfInput = true;\n    } else {\n      charBuffer.limit(limit + numChars);\n    }\n  }", "code_tokens": ["private", "void", "readMoreChars", "(", ")", "throws", "IOException", "{", "// Possibilities:", "// 1) array has space available on right hand side (between limit and capacity)", "// 2) array has space available on left hand side (before position)", "// 3) array has no space available", "//", "// In case 2 we shift the existing chars to the left, and in case 3 we create a bigger", "// array, then they both become case 1.", "if", "(", "availableCapacity", "(", "charBuffer", ")", "==", "0", ")", "{", "if", "(", "charBuffer", ".", "position", "(", ")", ">", "0", ")", "{", "// (2) There is room in the buffer. Move existing bytes to the beginning.", "charBuffer", ".", "compact", "(", ")", ".", "flip", "(", ")", ";", "}", "else", "{", "// (3) Entire buffer is full, need bigger buffer.", "charBuffer", "=", "grow", "(", "charBuffer", ")", ";", "}", "}", "// (1) Read more characters into free space at end of array.", "int", "limit", "=", "charBuffer", ".", "limit", "(", ")", ";", "int", "numChars", "=", "reader", ".", "read", "(", "charBuffer", ".", "array", "(", ")", ",", "limit", ",", "availableCapacity", "(", "charBuffer", ")", ")", ";", "if", "(", "numChars", "==", "-", "1", ")", "{", "endOfInput", "=", "true", ";", "}", "else", "{", "charBuffer", ".", "limit", "(", "limit", "+", "numChars", ")", ";", "}", "}"], "docstring": "Handle the case of underflow caused by needing more input characters .", "docstring_tokens": ["Handle", "the", "case", "of", "underflow", "caused", "by", "needing", "more", "input", "characters", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L198-L225", "partition": "valid", "similar_code": ["public static byte [ ] toBytes ( char [ ] chars ) { final CharBuffer charBuffer = CharBuffer . wrap ( chars ) ; final ByteBuffer byteBuffer = Charset . forName ( \"UTF-8\" ) . encode ( charBuffer ) ; final byte [ ] bytes = Arrays . copyOfRange ( byteBuffer . array ( ) , byteBuffer . position ( ) , byteBuffer . limit ( ) ) ; Arrays . fill ( charBuffer . array ( ) , ' ' ) ; // clear sensitive data Arrays . fill ( byteBuffer . array ( ) , ( byte ) 0 ) ; // clear sensitive data return bytes ; }", "private byte [ ] toByteArray ( char [ ] chars , Charset charset ) { assert chars != null ; CharBuffer charBuffer = CharBuffer . wrap ( chars ) ; ByteBuffer byteBuffer = charset . encode ( charBuffer ) ; byte [ ] bytes = Arrays . copyOfRange ( byteBuffer . array ( ) , byteBuffer . position ( ) , byteBuffer . limit ( ) ) ; Arrays . fill ( byteBuffer . array ( ) , ( byte ) 0 ) ; // clear sensitive data return bytes ; }", "protected String read ( SocketChannel sc ) throws IOException { sc . read ( buffer ) ; buffer . flip ( ) ; decoder . decode ( buffer , charBuffer , true ) ; charBuffer . flip ( ) ; String result = charBuffer . toString ( ) ; // Clear out buffers buffer . clear ( ) ; charBuffer . clear ( ) ; decoder . reset ( ) ; return result ; }", "public static String getText ( BufferedReader reader ) throws IOException { StringBuilder answer = new StringBuilder ( ) ; // reading the content of the file within a char buffer // allow to keep the correct line endings char [ ] charBuffer = new char [ 8192 ] ; int nbCharRead /* = 0*/ ; try { while ( ( nbCharRead = reader . read ( charBuffer ) ) != - 1 ) { // appends buffer answer . append ( charBuffer , 0 , nbCharRead ) ; } Reader temp = reader ; reader = null ; temp . close ( ) ; } finally { closeWithWarning ( reader ) ; } return answer . toString ( ) ; }", "@ Blocking public static String readText ( BufferedReader reader ) throws IOException { StringBuilder answer = new StringBuilder ( ) ; if ( reader == null ) { return answer . toString ( ) ; } // reading the content of the file within a char buffer // allow to keep the correct line endings char [ ] charBuffer = new char [ BUFFER_MAX ] ; int nbCharRead /* = 0*/ ; try { while ( ( nbCharRead = reader . read ( charBuffer ) ) != - 1 ) { // appends buffer answer . append ( charBuffer , 0 , nbCharRead ) ; } Reader temp = reader ; reader = null ; temp . close ( ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch ( IOException e ) { if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( \"Failed to close reader: \" + e . getMessage ( ) , e ) ; } } } return answer . toString ( ) ; }"], "similar_code_tokens": [["public", "static", "byte", "[", "]", "toBytes", "(", "char", "[", "]", "chars", ")", "{", "final", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "chars", ")", ";", "final", "ByteBuffer", "byteBuffer", "=", "Charset", ".", "forName", "(", "\"UTF-8\"", ")", ".", "encode", "(", "charBuffer", ")", ";", "final", "byte", "[", "]", "bytes", "=", "Arrays", ".", "copyOfRange", "(", "byteBuffer", ".", "array", "(", ")", ",", "byteBuffer", ".", "position", "(", ")", ",", "byteBuffer", ".", "limit", "(", ")", ")", ";", "Arrays", ".", "fill", "(", "charBuffer", ".", "array", "(", ")", ",", "'", "'", ")", ";", "// clear sensitive data", "Arrays", ".", "fill", "(", "byteBuffer", ".", "array", "(", ")", ",", "(", "byte", ")", "0", ")", ";", "// clear sensitive data", "return", "bytes", ";", "}"], ["private", "byte", "[", "]", "toByteArray", "(", "char", "[", "]", "chars", ",", "Charset", "charset", ")", "{", "assert", "chars", "!=", "null", ";", "CharBuffer", "charBuffer", "=", "CharBuffer", ".", "wrap", "(", "chars", ")", ";", "ByteBuffer", "byteBuffer", "=", "charset", ".", "encode", "(", "charBuffer", ")", ";", "byte", "[", "]", "bytes", "=", "Arrays", ".", "copyOfRange", "(", "byteBuffer", ".", "array", "(", ")", ",", "byteBuffer", ".", "position", "(", ")", ",", "byteBuffer", ".", "limit", "(", ")", ")", ";", "Arrays", ".", "fill", "(", "byteBuffer", ".", "array", "(", ")", ",", "(", "byte", ")", "0", ")", ";", "// clear sensitive data", "return", "bytes", ";", "}"], ["protected", "String", "read", "(", "SocketChannel", "sc", ")", "throws", "IOException", "{", "sc", ".", "read", "(", "buffer", ")", ";", "buffer", ".", "flip", "(", ")", ";", "decoder", ".", "decode", "(", "buffer", ",", "charBuffer", ",", "true", ")", ";", "charBuffer", ".", "flip", "(", ")", ";", "String", "result", "=", "charBuffer", ".", "toString", "(", ")", ";", "// Clear out buffers", "buffer", ".", "clear", "(", ")", ";", "charBuffer", ".", "clear", "(", ")", ";", "decoder", ".", "reset", "(", ")", ";", "return", "result", ";", "}"], ["public", "static", "String", "getText", "(", "BufferedReader", "reader", ")", "throws", "IOException", "{", "StringBuilder", "answer", "=", "new", "StringBuilder", "(", ")", ";", "// reading the content of the file within a char buffer", "// allow to keep the correct line endings", "char", "[", "]", "charBuffer", "=", "new", "char", "[", "8192", "]", ";", "int", "nbCharRead", "/* = 0*/", ";", "try", "{", "while", "(", "(", "nbCharRead", "=", "reader", ".", "read", "(", "charBuffer", ")", ")", "!=", "-", "1", ")", "{", "// appends buffer", "answer", ".", "append", "(", "charBuffer", ",", "0", ",", "nbCharRead", ")", ";", "}", "Reader", "temp", "=", "reader", ";", "reader", "=", "null", ";", "temp", ".", "close", "(", ")", ";", "}", "finally", "{", "closeWithWarning", "(", "reader", ")", ";", "}", "return", "answer", ".", "toString", "(", ")", ";", "}"], ["@", "Blocking", "public", "static", "String", "readText", "(", "BufferedReader", "reader", ")", "throws", "IOException", "{", "StringBuilder", "answer", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "reader", "==", "null", ")", "{", "return", "answer", ".", "toString", "(", ")", ";", "}", "// reading the content of the file within a char buffer", "// allow to keep the correct line endings", "char", "[", "]", "charBuffer", "=", "new", "char", "[", "BUFFER_MAX", "]", ";", "int", "nbCharRead", "/* = 0*/", ";", "try", "{", "while", "(", "(", "nbCharRead", "=", "reader", ".", "read", "(", "charBuffer", ")", ")", "!=", "-", "1", ")", "{", "// appends buffer", "answer", ".", "append", "(", "charBuffer", ",", "0", ",", "nbCharRead", ")", ";", "}", "Reader", "temp", "=", "reader", ";", "reader", "=", "null", ";", "temp", ".", "close", "(", ")", ";", "}", "finally", "{", "try", "{", "if", "(", "reader", "!=", "null", ")", "{", "reader", ".", "close", "(", ")", ";", "}", "}", "catch", "(", "IOException", "e", ")", "{", "if", "(", "LOG", ".", "isWarnEnabled", "(", ")", ")", "{", "LOG", ".", "warn", "(", "\"Failed to close reader: \"", "+", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "}", "}", "}", "return", "answer", ".", "toString", "(", ")", ";", "}"]], "similar_docstring": ["Converts a char array to a byte array without the use of Strings .", "Converts the given char array to a UTF - 8 encoded byte array .", "Reads a command or command response from a socket channel .", "Read the content of the BufferedReader and return it as a String . The BufferedReader is closed afterwards .", "Read the content of the BufferedReader and return it as a String in a blocking manner . The BufferedReader is closed afterwards ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/io/ReaderInputStream.java", "func_name": "ReaderInputStream.startDraining", "original_string": "private void startDraining(boolean overflow) {\n    byteBuffer.flip();\n    if (overflow && byteBuffer.remaining() == 0) {\n      byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n    } else {\n      draining = true;\n    }\n  }", "language": "java", "code": "private void startDraining(boolean overflow) {\n    byteBuffer.flip();\n    if (overflow && byteBuffer.remaining() == 0) {\n      byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n    } else {\n      draining = true;\n    }\n  }", "code_tokens": ["private", "void", "startDraining", "(", "boolean", "overflow", ")", "{", "byteBuffer", ".", "flip", "(", ")", ";", "if", "(", "overflow", "&&", "byteBuffer", ".", "remaining", "(", ")", "==", "0", ")", "{", "byteBuffer", "=", "ByteBuffer", ".", "allocate", "(", "byteBuffer", ".", "capacity", "(", ")", "*", "2", ")", ";", "}", "else", "{", "draining", "=", "true", ";", "}", "}"], "docstring": "Flips the buffer output buffer so we can start reading bytes from it . If we are starting to drain because there was overflow and there aren t actually any characters to drain then the overflow must be due to a small output buffer .", "docstring_tokens": ["Flips", "the", "buffer", "output", "buffer", "so", "we", "can", "start", "reading", "bytes", "from", "it", ".", "If", "we", "are", "starting", "to", "drain", "because", "there", "was", "overflow", "and", "there", "aren", "t", "actually", "any", "characters", "to", "drain", "then", "the", "overflow", "must", "be", "due", "to", "a", "small", "output", "buffer", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/io/ReaderInputStream.java#L237-L244", "partition": "valid", "similar_code": ["private double bytesToDouble ( byte [ ] bytes ) { ByteBuffer original = byteArrayToByteBuffer ( bytes ) ; if ( bytes . length < BYTES_IN_DOUBLE ) { ByteBuffer byteBuffer = ByteBuffer . allocate ( BYTES_IN_DOUBLE ) ; if ( sasFileProperties . getEndianness ( ) == 1 ) { byteBuffer . position ( BYTES_IN_DOUBLE - bytes . length ) ; } byteBuffer . put ( original ) ; byteBuffer . order ( original . order ( ) ) ; byteBuffer . position ( 0 ) ; original = byteBuffer ; } return original . getDouble ( ) ; }", "private boolean refill ( ) throws IOException { if ( ! byteBuffer . hasRemaining ( ) ) { byteBuffer . clear ( ) ; int nRead = 0 ; while ( nRead == 0 ) { nRead = fileChannel . read ( byteBuffer ) ; } if ( nRead < 0 ) { return false ; } byteBuffer . flip ( ) ; } return true ; }", "public static @ Nullable Pair < Integer , Integer > decodeDimensions ( InputStream is ) { Preconditions . checkNotNull ( is ) ; ByteBuffer byteBuffer = DECODE_BUFFERS . acquire ( ) ; if ( byteBuffer == null ) { byteBuffer = ByteBuffer . allocate ( DECODE_BUFFER_SIZE ) ; } BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; try { options . inTempStorage = byteBuffer . array ( ) ; BitmapFactory . decodeStream ( is , null , options ) ; return ( options . outWidth == - 1 || options . outHeight == - 1 ) ? null : new Pair <> ( options . outWidth , options . outHeight ) ; } finally { DECODE_BUFFERS . release ( byteBuffer ) ; } }", "private int read ( final int off , final int len ) throws IOException { if ( len == 0 ) { return 0 ; } if ( inputStream != null ) { // Wrapped InputStream return inputStream . read ( buf , off , len ) ; } else { // Wrapped ByteBuffer final int bytesRemainingInBuf = byteBuffer != null ? byteBuffer . remaining ( ) : buf . length - off ; final int bytesRead = Math . max ( 0 , Math . min ( len , bytesRemainingInBuf ) ) ; if ( bytesRead == 0 ) { // Return -1, as per InputStream#read() contract return - 1 ; } if ( byteBuffer != null ) { // Copy from the ByteBuffer into the byte array final int byteBufPositionBefore = byteBuffer . position ( ) ; try { byteBuffer . get ( buf , off , bytesRead ) ; } catch ( final BufferUnderflowException e ) { // Should not happen throw new IOException ( \"Buffer underflow\" , e ) ; } return byteBuffer . position ( ) - byteBufPositionBefore ; } else { // Nothing to read, since ByteBuffer is backed with an array return bytesRead ; } } }", "private final void serializeCommonFields ( final ByteBuffer byteBuffer , final int index ) { byteBuffer . position ( index ) ; byte b = 0 ; if ( senseKeySpecificDataValid ) b = BitManip . getByteWithBitSet ( b , 7 , true ) ; // set MSB to 1\r byteBuffer . put ( b ) ; }"], "similar_code_tokens": [["private", "double", "bytesToDouble", "(", "byte", "[", "]", "bytes", ")", "{", "ByteBuffer", "original", "=", "byteArrayToByteBuffer", "(", "bytes", ")", ";", "if", "(", "bytes", ".", "length", "<", "BYTES_IN_DOUBLE", ")", "{", "ByteBuffer", "byteBuffer", "=", "ByteBuffer", ".", "allocate", "(", "BYTES_IN_DOUBLE", ")", ";", "if", "(", "sasFileProperties", ".", "getEndianness", "(", ")", "==", "1", ")", "{", "byteBuffer", ".", "position", "(", "BYTES_IN_DOUBLE", "-", "bytes", ".", "length", ")", ";", "}", "byteBuffer", ".", "put", "(", "original", ")", ";", "byteBuffer", ".", "order", "(", "original", ".", "order", "(", ")", ")", ";", "byteBuffer", ".", "position", "(", "0", ")", ";", "original", "=", "byteBuffer", ";", "}", "return", "original", ".", "getDouble", "(", ")", ";", "}"], ["private", "boolean", "refill", "(", ")", "throws", "IOException", "{", "if", "(", "!", "byteBuffer", ".", "hasRemaining", "(", ")", ")", "{", "byteBuffer", ".", "clear", "(", ")", ";", "int", "nRead", "=", "0", ";", "while", "(", "nRead", "==", "0", ")", "{", "nRead", "=", "fileChannel", ".", "read", "(", "byteBuffer", ")", ";", "}", "if", "(", "nRead", "<", "0", ")", "{", "return", "false", ";", "}", "byteBuffer", ".", "flip", "(", ")", ";", "}", "return", "true", ";", "}"], ["public", "static", "@", "Nullable", "Pair", "<", "Integer", ",", "Integer", ">", "decodeDimensions", "(", "InputStream", "is", ")", "{", "Preconditions", ".", "checkNotNull", "(", "is", ")", ";", "ByteBuffer", "byteBuffer", "=", "DECODE_BUFFERS", ".", "acquire", "(", ")", ";", "if", "(", "byteBuffer", "==", "null", ")", "{", "byteBuffer", "=", "ByteBuffer", ".", "allocate", "(", "DECODE_BUFFER_SIZE", ")", ";", "}", "BitmapFactory", ".", "Options", "options", "=", "new", "BitmapFactory", ".", "Options", "(", ")", ";", "options", ".", "inJustDecodeBounds", "=", "true", ";", "try", "{", "options", ".", "inTempStorage", "=", "byteBuffer", ".", "array", "(", ")", ";", "BitmapFactory", ".", "decodeStream", "(", "is", ",", "null", ",", "options", ")", ";", "return", "(", "options", ".", "outWidth", "==", "-", "1", "||", "options", ".", "outHeight", "==", "-", "1", ")", "?", "null", ":", "new", "Pair", "<>", "(", "options", ".", "outWidth", ",", "options", ".", "outHeight", ")", ";", "}", "finally", "{", "DECODE_BUFFERS", ".", "release", "(", "byteBuffer", ")", ";", "}", "}"], ["private", "int", "read", "(", "final", "int", "off", ",", "final", "int", "len", ")", "throws", "IOException", "{", "if", "(", "len", "==", "0", ")", "{", "return", "0", ";", "}", "if", "(", "inputStream", "!=", "null", ")", "{", "// Wrapped InputStream", "return", "inputStream", ".", "read", "(", "buf", ",", "off", ",", "len", ")", ";", "}", "else", "{", "// Wrapped ByteBuffer", "final", "int", "bytesRemainingInBuf", "=", "byteBuffer", "!=", "null", "?", "byteBuffer", ".", "remaining", "(", ")", ":", "buf", ".", "length", "-", "off", ";", "final", "int", "bytesRead", "=", "Math", ".", "max", "(", "0", ",", "Math", ".", "min", "(", "len", ",", "bytesRemainingInBuf", ")", ")", ";", "if", "(", "bytesRead", "==", "0", ")", "{", "// Return -1, as per InputStream#read() contract", "return", "-", "1", ";", "}", "if", "(", "byteBuffer", "!=", "null", ")", "{", "// Copy from the ByteBuffer into the byte array", "final", "int", "byteBufPositionBefore", "=", "byteBuffer", ".", "position", "(", ")", ";", "try", "{", "byteBuffer", ".", "get", "(", "buf", ",", "off", ",", "bytesRead", ")", ";", "}", "catch", "(", "final", "BufferUnderflowException", "e", ")", "{", "// Should not happen", "throw", "new", "IOException", "(", "\"Buffer underflow\"", ",", "e", ")", ";", "}", "return", "byteBuffer", ".", "position", "(", ")", "-", "byteBufPositionBefore", ";", "}", "else", "{", "// Nothing to read, since ByteBuffer is backed with an array", "return", "bytesRead", ";", "}", "}", "}"], ["private", "final", "void", "serializeCommonFields", "(", "final", "ByteBuffer", "byteBuffer", ",", "final", "int", "index", ")", "{", "byteBuffer", ".", "position", "(", "index", ")", ";", "byte", "b", "=", "0", ";", "if", "(", "senseKeySpecificDataValid", ")", "b", "=", "BitManip", ".", "getByteWithBitSet", "(", "b", ",", "7", ",", "true", ")", ";", "// set MSB to 1\r", "byteBuffer", ".", "put", "(", "b", ")", ";", "}"]], "similar_docstring": ["The function to convert an array of bytes into a double number .", "Checks weather data is left to be read from the input stream .", "Decodes the bounds of an image and returns its width and height or null if the size can t be determined", "Copy up to len bytes into buf starting at the given offset .", "Serializes the fields common to all sense - key - specific data ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toArray", "original_string": "@GwtIncompatible // Array.newInstance(Class, int)\n  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {\n    return toArray(iterable, ObjectArrays.newArray(type, 0));\n  }", "language": "java", "code": "@GwtIncompatible // Array.newInstance(Class, int)\n  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {\n    return toArray(iterable, ObjectArrays.newArray(type, 0));\n  }", "code_tokens": ["@", "GwtIncompatible", "// Array.newInstance(Class, int)", "public", "static", "<", "T", ">", "T", "[", "]", "toArray", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "Class", "<", "T", ">", "type", ")", "{", "return", "toArray", "(", "iterable", ",", "ObjectArrays", ".", "newArray", "(", "type", ",", "0", ")", ")", ";", "}"], "docstring": "Copies an iterable s elements into an array .", "docstring_tokens": ["Copies", "an", "iterable", "s", "elements", "into", "an", "array", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L316-L319", "partition": "valid", "similar_code": ["@ GwtIncompatible ( \"Array.newInstance(Class, int)\" ) public static < T > T [ ] toArray ( Iterable < ? extends T > iterable , Class < T > type ) { Collection < ? extends T > collection = toCollection ( iterable ) ; T [ ] array = ObjectArrays . newArray ( type , collection . size ( ) ) ; return collection . toArray ( array ) ; }", "public static < T > T [ ] toArray ( Iterable < ? extends T > iterable , T [ ] target ) { if ( iterable instanceof Collection ) { return ( ( Collection < T > ) iterable ) . toArray ( target ) ; } if ( iterable instanceof RichIterable ) { return ( ( RichIterable < T > ) iterable ) . toArray ( target ) ; } MutableList < T > result = Lists . mutable . empty ( ) ; Iterate . addAllTo ( iterable , result ) ; return result . toArray ( target ) ; }", "public static < T > Object [ ] toArray ( Iterable < T > iterable ) { if ( iterable == null ) { throw new NullPointerException ( ) ; } if ( iterable instanceof Collection ) { return ( ( Collection < T > ) iterable ) . toArray ( ) ; } if ( iterable instanceof RichIterable ) { return ( ( RichIterable < T > ) iterable ) . toArray ( ) ; } MutableList < T > result = Lists . mutable . empty ( ) ; Iterate . addAllTo ( iterable , result ) ; return result . toArray ( ) ; }", "public static < T , X extends Throwable > Try < T , X > fromIterable ( final Iterable < T > iterable , T alt ) { if ( iterable instanceof Try ) { return ( Try ) iterable ; } return new Try <> ( LazyEither . fromIterable ( iterable , alt ) , new Class [ 0 ] ) ; }", "public static < T > Iterable < T > filteringIterable ( final Iterable < ? extends T > iterable , final Predicate < ? super T > predicate ) { Objects . requireNonNull ( iterable , \"The iterable is null\" ) ; Objects . requireNonNull ( predicate , \"The predicate is null\" ) ; return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new FilteringIterator < T > ( iterable . iterator ( ) , predicate ) ; } } ; }"], "similar_code_tokens": [["@", "GwtIncompatible", "(", "\"Array.newInstance(Class, int)\"", ")", "public", "static", "<", "T", ">", "T", "[", "]", "toArray", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "Class", "<", "T", ">", "type", ")", "{", "Collection", "<", "?", "extends", "T", ">", "collection", "=", "toCollection", "(", "iterable", ")", ";", "T", "[", "]", "array", "=", "ObjectArrays", ".", "newArray", "(", "type", ",", "collection", ".", "size", "(", ")", ")", ";", "return", "collection", ".", "toArray", "(", "array", ")", ";", "}"], ["public", "static", "<", "T", ">", "T", "[", "]", "toArray", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "T", "[", "]", "target", ")", "{", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "T", ">", ")", "iterable", ")", ".", "toArray", "(", "target", ")", ";", "}", "if", "(", "iterable", "instanceof", "RichIterable", ")", "{", "return", "(", "(", "RichIterable", "<", "T", ">", ")", "iterable", ")", ".", "toArray", "(", "target", ")", ";", "}", "MutableList", "<", "T", ">", "result", "=", "Lists", ".", "mutable", ".", "empty", "(", ")", ";", "Iterate", ".", "addAllTo", "(", "iterable", ",", "result", ")", ";", "return", "result", ".", "toArray", "(", "target", ")", ";", "}"], ["public", "static", "<", "T", ">", "Object", "[", "]", "toArray", "(", "Iterable", "<", "T", ">", "iterable", ")", "{", "if", "(", "iterable", "==", "null", ")", "{", "throw", "new", "NullPointerException", "(", ")", ";", "}", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "T", ">", ")", "iterable", ")", ".", "toArray", "(", ")", ";", "}", "if", "(", "iterable", "instanceof", "RichIterable", ")", "{", "return", "(", "(", "RichIterable", "<", "T", ">", ")", "iterable", ")", ".", "toArray", "(", ")", ";", "}", "MutableList", "<", "T", ">", "result", "=", "Lists", ".", "mutable", ".", "empty", "(", ")", ";", "Iterate", ".", "addAllTo", "(", "iterable", ",", "result", ")", ";", "return", "result", ".", "toArray", "(", ")", ";", "}"], ["public", "static", "<", "T", ",", "X", "extends", "Throwable", ">", "Try", "<", "T", ",", "X", ">", "fromIterable", "(", "final", "Iterable", "<", "T", ">", "iterable", ",", "T", "alt", ")", "{", "if", "(", "iterable", "instanceof", "Try", ")", "{", "return", "(", "Try", ")", "iterable", ";", "}", "return", "new", "Try", "<>", "(", "LazyEither", ".", "fromIterable", "(", "iterable", ",", "alt", ")", ",", "new", "Class", "[", "0", "]", ")", ";", "}"], ["public", "static", "<", "T", ">", "Iterable", "<", "T", ">", "filteringIterable", "(", "final", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "final", "Predicate", "<", "?", "super", "T", ">", "predicate", ")", "{", "Objects", ".", "requireNonNull", "(", "iterable", ",", "\"The iterable is null\"", ")", ";", "Objects", ".", "requireNonNull", "(", "predicate", ",", "\"The predicate is null\"", ")", ";", "return", "new", "Iterable", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "Iterator", "<", "T", ">", "iterator", "(", ")", "{", "return", "new", "FilteringIterator", "<", "T", ">", "(", "iterable", ".", "iterator", "(", ")", ",", "predicate", ")", ";", "}", "}", ";", "}"]], "similar_docstring": ["Copies an iterable s elements into an array .", "Copies the specified iterable into the specified array .", "Converts the specified iterable to an array .", "Construct a Try that contains a single value extracted from the supplied Iterable", "Returns an iterable that provides an iterator that only returns the elements provided by the iterator of the given iterable to which the given predicate applies ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.isEmpty", "original_string": "public static boolean isEmpty(Iterable<?> iterable) {\n    if (iterable instanceof Collection) {\n      return ((Collection<?>) iterable).isEmpty();\n    }\n    return !iterable.iterator().hasNext();\n  }", "language": "java", "code": "public static boolean isEmpty(Iterable<?> iterable) {\n    if (iterable instanceof Collection) {\n      return ((Collection<?>) iterable).isEmpty();\n    }\n    return !iterable.iterator().hasNext();\n  }", "code_tokens": ["public", "static", "boolean", "isEmpty", "(", "Iterable", "<", "?", ">", "iterable", ")", "{", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "isEmpty", "(", ")", ";", "}", "return", "!", "iterable", ".", "iterator", "(", ")", ".", "hasNext", "(", ")", ";", "}"], "docstring": "Determines if the given iterable contains no elements .", "docstring_tokens": ["Determines", "if", "the", "given", "iterable", "contains", "no", "elements", "."], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L980-L985", "partition": "valid", "similar_code": ["public static boolean isEmpty ( Iterable < ? > iterable ) { if ( iterable == null ) { return true ; } if ( iterable instanceof RichIterable ) { return ( ( RichIterable < ? > ) iterable ) . isEmpty ( ) ; } if ( iterable instanceof Collection ) { return ( ( Collection < ? > ) iterable ) . isEmpty ( ) ; } return IterableIterate . isEmpty ( iterable ) ; }", "public static < T > boolean addAll ( Collection < T > target , Iterable < ? extends T > iterable ) { if ( iterable instanceof Collection ) { return target . addAll ( ( Collection < ? extends T > ) iterable ) ; } return Iterators . addAll ( target , iterable . iterator ( ) ) ; }", "public static boolean contains ( Iterable < ? > iterable , Object value ) { if ( iterable instanceof Collection ) { return ( ( Collection < ? > ) iterable ) . contains ( value ) ; } if ( iterable instanceof RichIterable ) { return ( ( RichIterable < ? > ) iterable ) . contains ( value ) ; } return IterableIterate . detectIndex ( iterable , Predicates . equal ( value ) ) > - 1 ; }", "public static Predicates < Object > in ( Iterable < ? > iterable ) { if ( iterable instanceof SetIterable < ? > ) { return new InSetIterablePredicate ( ( SetIterable < ? > ) iterable ) ; } if ( iterable instanceof Set < ? > ) { return new InSetPredicate ( ( Set < ? > ) iterable ) ; } if ( iterable instanceof Collection < ? > && ( ( Collection < ? > ) iterable ) . size ( ) <= SMALL_COLLECTION_THRESHOLD ) { return new InCollectionPredicate ( ( Collection < ? > ) iterable ) ; } return new InSetIterablePredicate ( UnifiedSet . newSet ( iterable ) ) ; }", "public static Predicates < Object > notIn ( Iterable < ? > iterable ) { if ( iterable instanceof SetIterable < ? > ) { return new NotInSetIterablePredicate ( ( SetIterable < ? > ) iterable ) ; } if ( iterable instanceof Set < ? > ) { return new NotInSetPredicate ( ( Set < ? > ) iterable ) ; } if ( iterable instanceof Collection < ? > && ( ( Collection < ? > ) iterable ) . size ( ) <= SMALL_COLLECTION_THRESHOLD ) { return new NotInCollectionPredicate ( ( Collection < ? > ) iterable ) ; } return new NotInSetIterablePredicate ( UnifiedSet . newSet ( iterable ) ) ; }"], "similar_code_tokens": [["public", "static", "boolean", "isEmpty", "(", "Iterable", "<", "?", ">", "iterable", ")", "{", "if", "(", "iterable", "==", "null", ")", "{", "return", "true", ";", "}", "if", "(", "iterable", "instanceof", "RichIterable", ")", "{", "return", "(", "(", "RichIterable", "<", "?", ">", ")", "iterable", ")", ".", "isEmpty", "(", ")", ";", "}", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "isEmpty", "(", ")", ";", "}", "return", "IterableIterate", ".", "isEmpty", "(", "iterable", ")", ";", "}"], ["public", "static", "<", "T", ">", "boolean", "addAll", "(", "Collection", "<", "T", ">", "target", ",", "Iterable", "<", "?", "extends", "T", ">", "iterable", ")", "{", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "target", ".", "addAll", "(", "(", "Collection", "<", "?", "extends", "T", ">", ")", "iterable", ")", ";", "}", "return", "Iterators", ".", "addAll", "(", "target", ",", "iterable", ".", "iterator", "(", ")", ")", ";", "}"], ["public", "static", "boolean", "contains", "(", "Iterable", "<", "?", ">", "iterable", ",", "Object", "value", ")", "{", "if", "(", "iterable", "instanceof", "Collection", ")", "{", "return", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "contains", "(", "value", ")", ";", "}", "if", "(", "iterable", "instanceof", "RichIterable", ")", "{", "return", "(", "(", "RichIterable", "<", "?", ">", ")", "iterable", ")", ".", "contains", "(", "value", ")", ";", "}", "return", "IterableIterate", ".", "detectIndex", "(", "iterable", ",", "Predicates", ".", "equal", "(", "value", ")", ")", ">", "-", "1", ";", "}"], ["public", "static", "Predicates", "<", "Object", ">", "in", "(", "Iterable", "<", "?", ">", "iterable", ")", "{", "if", "(", "iterable", "instanceof", "SetIterable", "<", "?", ">", ")", "{", "return", "new", "InSetIterablePredicate", "(", "(", "SetIterable", "<", "?", ">", ")", "iterable", ")", ";", "}", "if", "(", "iterable", "instanceof", "Set", "<", "?", ">", ")", "{", "return", "new", "InSetPredicate", "(", "(", "Set", "<", "?", ">", ")", "iterable", ")", ";", "}", "if", "(", "iterable", "instanceof", "Collection", "<", "?", ">", "&&", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "size", "(", ")", "<=", "SMALL_COLLECTION_THRESHOLD", ")", "{", "return", "new", "InCollectionPredicate", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ";", "}", "return", "new", "InSetIterablePredicate", "(", "UnifiedSet", ".", "newSet", "(", "iterable", ")", ")", ";", "}"], ["public", "static", "Predicates", "<", "Object", ">", "notIn", "(", "Iterable", "<", "?", ">", "iterable", ")", "{", "if", "(", "iterable", "instanceof", "SetIterable", "<", "?", ">", ")", "{", "return", "new", "NotInSetIterablePredicate", "(", "(", "SetIterable", "<", "?", ">", ")", "iterable", ")", ";", "}", "if", "(", "iterable", "instanceof", "Set", "<", "?", ">", ")", "{", "return", "new", "NotInSetPredicate", "(", "(", "Set", "<", "?", ">", ")", "iterable", ")", ";", "}", "if", "(", "iterable", "instanceof", "Collection", "<", "?", ">", "&&", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ".", "size", "(", ")", "<=", "SMALL_COLLECTION_THRESHOLD", ")", "{", "return", "new", "NotInCollectionPredicate", "(", "(", "Collection", "<", "?", ">", ")", "iterable", ")", ";", "}", "return", "new", "NotInSetIterablePredicate", "(", "UnifiedSet", ".", "newSet", "(", "iterable", ")", ")", ";", "}"]], "similar_docstring": ["A null - safe check on a collection to see if it isEmpty . A null collection results in a true .", "Add all elements in the iterable to the collection .", "Returns true if the iterable contains the value . In the case of Collections and RichIterables the method contains is called . All other iterables will force a complete iteration to happen which can be unnecessarily costly .", "Creates a predicate which returns true if an object passed to accept method is contained in the iterable .", "Creates a predicate which returns true if an object passed to accept method is not contained in the iterable ."], "similar_docstring_tokens": []}
{"repo": "google/guava", "path": "android/guava/src/com/google/common/collect/Iterables.java", "func_name": "Iterables.toIterator", "original_string": "static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n      @Override\n      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n        return iterable.iterator();\n      }\n    };\n  }", "language": "java", "code": "static <T> Function<Iterable<? extends T>, Iterator<? extends T>> toIterator() {\n    return new Function<Iterable<? extends T>, Iterator<? extends T>>() {\n      @Override\n      public Iterator<? extends T> apply(Iterable<? extends T> iterable) {\n        return iterable.iterator();\n      }\n    };\n  }", "code_tokens": ["static", "<", "T", ">", "Function", "<", "Iterable", "<", "?", "extends", "T", ">", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "toIterator", "(", ")", "{", "return", "new", "Function", "<", "Iterable", "<", "?", "extends", "T", ">", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "(", ")", "{", "@", "Override", "public", "Iterator", "<", "?", "extends", "T", ">", "apply", "(", "Iterable", "<", "?", "extends", "T", ">", "iterable", ")", "{", "return", "iterable", ".", "iterator", "(", ")", ";", "}", "}", ";", "}"], "docstring": "Useful as a public method?", "docstring_tokens": ["Useful", "as", "a", "public", "method?"], "sha": "7155d12b70a2406fa84d94d4b8b3bc108e89abfd", "url": "https://github.com/google/guava/blob/7155d12b70a2406fa84d94d4b8b3bc108e89abfd/android/guava/src/com/google/common/collect/Iterables.java#L1018-L1025", "partition": "valid", "similar_code": ["public static < S , T > Iterable < T > transformingIterable ( final Iterable < ? extends S > iterable , final Function < S , ? extends T > function ) { Objects . requireNonNull ( iterable , \"The iterable is null\" ) ; Objects . requireNonNull ( function , \"The function is null\" ) ; return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new TransformingIterator < S , T > ( iterable . iterator ( ) , function ) ; } } ; }", "public static < S extends Iterable < ? extends T > , T > Iterator < T > iteratorOverIterables ( Iterator < S > iterablesIterator ) { Objects . requireNonNull ( iterablesIterator , \"The iterablesIterator is null\" ) ; TransformingIterator < S , Iterator < ? extends T > > iteratorIterator = new TransformingIterator < S , Iterator < ? extends T > > ( iterablesIterator , iterable -> iterable . iterator ( ) ) ; return new CombiningIterator < T > ( iteratorIterator ) ; }", "public static < T > Iterable < T > filteringIterable ( final Iterable < ? extends T > iterable , final Predicate < ? super T > predicate ) { Objects . requireNonNull ( iterable , \"The iterable is null\" ) ; Objects . requireNonNull ( predicate , \"The predicate is null\" ) ; return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new FilteringIterator < T > ( iterable . iterator ( ) , predicate ) ; } } ; }", "public static < T , V > LazyIterable < V > flatCollect ( Iterable < T > iterable , Function < ? super T , ? extends Iterable < V > > function ) { return new FlatCollectIterable < T , V > ( iterable , function ) ; }", "public static < T , V > LazyIterable < V > collect ( Iterable < T > iterable , Function < ? super T , ? extends V > function ) { return new CollectIterable < T , V > ( iterable , function ) ; }"], "similar_code_tokens": [["public", "static", "<", "S", ",", "T", ">", "Iterable", "<", "T", ">", "transformingIterable", "(", "final", "Iterable", "<", "?", "extends", "S", ">", "iterable", ",", "final", "Function", "<", "S", ",", "?", "extends", "T", ">", "function", ")", "{", "Objects", ".", "requireNonNull", "(", "iterable", ",", "\"The iterable is null\"", ")", ";", "Objects", ".", "requireNonNull", "(", "function", ",", "\"The function is null\"", ")", ";", "return", "new", "Iterable", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "Iterator", "<", "T", ">", "iterator", "(", ")", "{", "return", "new", "TransformingIterator", "<", "S", ",", "T", ">", "(", "iterable", ".", "iterator", "(", ")", ",", "function", ")", ";", "}", "}", ";", "}"], ["public", "static", "<", "S", "extends", "Iterable", "<", "?", "extends", "T", ">", ",", "T", ">", "Iterator", "<", "T", ">", "iteratorOverIterables", "(", "Iterator", "<", "S", ">", "iterablesIterator", ")", "{", "Objects", ".", "requireNonNull", "(", "iterablesIterator", ",", "\"The iterablesIterator is null\"", ")", ";", "TransformingIterator", "<", "S", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "iteratorIterator", "=", "new", "TransformingIterator", "<", "S", ",", "Iterator", "<", "?", "extends", "T", ">", ">", "(", "iterablesIterator", ",", "iterable", "->", "iterable", ".", "iterator", "(", ")", ")", ";", "return", "new", "CombiningIterator", "<", "T", ">", "(", "iteratorIterator", ")", ";", "}"], ["public", "static", "<", "T", ">", "Iterable", "<", "T", ">", "filteringIterable", "(", "final", "Iterable", "<", "?", "extends", "T", ">", "iterable", ",", "final", "Predicate", "<", "?", "super", "T", ">", "predicate", ")", "{", "Objects", ".", "requireNonNull", "(", "iterable", ",", "\"The iterable is null\"", ")", ";", "Objects", ".", "requireNonNull", "(", "predicate", ",", "\"The predicate is null\"", ")", ";", "return", "new", "Iterable", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "Iterator", "<", "T", ">", "iterator", "(", ")", "{", "return", "new", "FilteringIterator", "<", "T", ">", "(", "iterable", ".", "iterator", "(", ")", ",", "predicate", ")", ";", "}", "}", ";", "}"], ["public", "static", "<", "T", ",", "V", ">", "LazyIterable", "<", "V", ">", "flatCollect", "(", "Iterable", "<", "T", ">", "iterable", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "Iterable", "<", "V", ">", ">", "function", ")", "{", "return", "new", "FlatCollectIterable", "<", "T", ",", "V", ">", "(", "iterable", ",", "function", ")", ";", "}"], ["public", "static", "<", "T", ",", "V", ">", "LazyIterable", "<", "V", ">", "collect", "(", "Iterable", "<", "T", ">", "iterable", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "V", ">", "function", ")", "{", "return", "new", "CollectIterable", "<", "T", ",", "V", ">", "(", "iterable", ",", "function", ")", ";", "}"]], "similar_docstring": ["Returns an iterable that provides iterators that are transforming the elements provided by the iterators of the given iterable using the given function", "Returns an iterator that combines the iterators that are returned by the iterables that are provided by the given iterator", "Returns an iterable that provides an iterator that only returns the elements provided by the iterator of the given iterable to which the given predicate applies .", "Creates a deferred flattening iterable for the specified iterable", "Creates a deferred transforming iterable for the specified iterable"], "similar_docstring_tokens": []}
