{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java", "func_name": "QueueDrainObserver.fastPathOrderedEmit", "original_string": "protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {\n        final Observer<? super V> observer = downstream;\n        final SimplePlainQueue<U> q = queue;\n\n        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {\n            if (q.isEmpty()) {\n                accept(observer, value);\n                if (leave(-1) == 0) {\n                    return;\n                }\n            } else {\n                q.offer(value);\n            }\n        } else {\n            q.offer(value);\n            if (!enter()) {\n                return;\n            }\n        }\n        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);\n    }", "language": "java", "code": "protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {\n        final Observer<? super V> observer = downstream;\n        final SimplePlainQueue<U> q = queue;\n\n        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {\n            if (q.isEmpty()) {\n                accept(observer, value);\n                if (leave(-1) == 0) {\n                    return;\n                }\n            } else {\n                q.offer(value);\n            }\n        } else {\n            q.offer(value);\n            if (!enter()) {\n                return;\n            }\n        }\n        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);\n    }", "code_tokens": ["protected", "final", "void", "fastPathOrderedEmit", "(", "U", "value", ",", "boolean", "delayError", ",", "Disposable", "disposable", ")", "{", "final", "Observer", "<", "?", "super", "V", ">", "observer", "=", "downstream", ";", "final", "SimplePlainQueue", "<", "U", ">", "q", "=", "queue", ";", "if", "(", "wip", ".", "get", "(", ")", "==", "0", "&&", "wip", ".", "compareAndSet", "(", "0", ",", "1", ")", ")", "{", "if", "(", "q", ".", "isEmpty", "(", ")", ")", "{", "accept", "(", "observer", ",", "value", ")", ";", "if", "(", "leave", "(", "-", "1", ")", "==", "0", ")", "{", "return", ";", "}", "}", "else", "{", "q", ".", "offer", "(", "value", ")", ";", "}", "}", "else", "{", "q", ".", "offer", "(", "value", ")", ";", "if", "(", "!", "enter", "(", ")", ")", "{", "return", ";", "}", "}", "QueueDrainHelper", ".", "drainLoop", "(", "q", ",", "observer", ",", "delayError", ",", "disposable", ",", "this", ")", ";", "}"], "docstring": "Makes sure the fast - path emits in order .", "docstring_tokens": ["Makes", "sure", "the", "fast", "-", "path", "emits", "in", "order", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java#L88-L108", "partition": "test", "similar_code": ["private SQLQuery query ( Class < ? > ... entity ) { SQLQuery q = session . createSQLQuery ( sql ) ; if ( entity . length == 1 ) { q . addEntity ( entity [ 0 ] ) ; } for ( Map . Entry < String , Type > scalar : scalars . entrySet ( ) ) { q . addScalar ( scalar . getKey ( ) , scalar . getValue ( ) ) ; } for ( int i = 0 ; i < positionedParameters . length ; i ++ ) { q . setParameter ( i , positionedParameters [ i ] ) ; } for ( Map . Entry < String , Object > entry : namedParameters . entrySet ( ) ) { Object value = entry . getValue ( ) ; if ( Types . isArray ( value ) ) { Object [ ] parameter = ( Object [ ] ) value ; if ( parameter . length == 0 ) { throw new HibernateException ( String . format ( \"Invalid named parameter |%s|. Empty array.\" , entry . getKey ( ) ) ) ; } q . setParameterList ( entry . getKey ( ) , parameter ) ; } else if ( Types . isCollection ( value ) ) { Collection < ? > parameter = ( Collection < ? > ) value ; if ( parameter . isEmpty ( ) ) { throw new HibernateException ( String . format ( \"Invalid named parameter |%s|. Empty list.\" , entry . getKey ( ) ) ) ; } q . setParameterList ( entry . getKey ( ) , parameter ) ; } else { q . setParameter ( entry . getKey ( ) , value ) ; } } if ( offset > 0 ) { q . setFirstResult ( offset ) ; } if ( rowsCount > 0 ) { q . setMaxResults ( rowsCount ) ; } return q ; }", "public static < T > boolean onNext ( Subscriber < ? super T > subscriber , T value , AtomicInteger wip , AtomicThrowable error ) { if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { subscriber . onNext ( value ) ; if ( wip . decrementAndGet ( ) != 0 ) { Throwable ex = error . terminate ( ) ; if ( ex != null ) { subscriber . onError ( ex ) ; } else { subscriber . onComplete ( ) ; } return true ; } } return false ; }", "private org . hibernate . Query query ( String hql , Class < ? > ... type ) { org . hibernate . Query q = session . createQuery ( hql ) ; for ( int i = 0 ; i < positionedParameters . length ; i ++ ) { q . setParameter ( i , positionedParameters [ i ] ) ; } for ( Map . Entry < String , Object > entry : namedParameters . entrySet ( ) ) { Object value = entry . getValue ( ) ; if ( Types . isArray ( value ) ) { Object [ ] parameter = ( Object [ ] ) value ; if ( parameter . length == 0 ) { throw new HibernateException ( String . format ( \"Invalid named parameter |%s|. Empty array.\" , entry . getKey ( ) ) ) ; } q . setParameterList ( entry . getKey ( ) , parameter ) ; } else if ( Types . isCollection ( value ) ) { Collection < ? > parameter = ( Collection < ? > ) value ; if ( parameter . isEmpty ( ) ) { throw new HibernateException ( String . format ( \"Invalid named parameter |%s|. Empty list.\" , entry . getKey ( ) ) ) ; } q . setParameterList ( entry . getKey ( ) , parameter ) ; } else { q . setParameter ( entry . getKey ( ) , value ) ; } } if ( offset > 0 ) { q . setFirstResult ( offset ) ; } if ( rowsCount > 0 ) { q . setMaxResults ( rowsCount ) ; } if ( type . length > 0 ) { q . setResultTransformer ( Transformers . aliasToBean ( type [ 0 ] ) ) ; } return q ; }", "private void value ( final String val , final String quoteChar ) throws IOException { if ( val == null ) { return ; } String q = quoteChar ; if ( q == null ) { q = \"\" ; } if ( ( val . indexOf ( ' ' ) >= 0 ) || ( val . indexOf ( ' ' ) >= 0 ) ) { out ( \"<![CDATA[\" ) ; out ( q ) ; out ( val ) ; out ( q ) ; out ( \"]]>\" ) ; } else { out ( q ) ; out ( val ) ; out ( q ) ; } }", "int divideOneWord ( int divisor , MutableBigInteger quotient ) { long divisorLong = divisor & LONG_MASK ; // Special case of one word dividend if ( intLen == 1 ) { long dividendValue = value [ offset ] & LONG_MASK ; int q = ( int ) ( dividendValue / divisorLong ) ; int r = ( int ) ( dividendValue - q * divisorLong ) ; quotient . value [ 0 ] = q ; quotient . intLen = ( q == 0 ) ? 0 : 1 ; quotient . offset = 0 ; return r ; } if ( quotient . value . length < intLen ) quotient . value = new int [ intLen ] ; quotient . offset = 0 ; quotient . intLen = intLen ; // Normalize the divisor int shift = Integer . numberOfLeadingZeros ( divisor ) ; int rem = value [ offset ] ; long remLong = rem & LONG_MASK ; if ( remLong < divisorLong ) { quotient . value [ 0 ] = 0 ; } else { quotient . value [ 0 ] = ( int ) ( remLong / divisorLong ) ; rem = ( int ) ( remLong - ( quotient . value [ 0 ] * divisorLong ) ) ; remLong = rem & LONG_MASK ; } int xlen = intLen ; while ( -- xlen > 0 ) { long dividendEstimate = ( remLong << 32 ) | ( value [ offset + intLen - xlen ] & LONG_MASK ) ; int q ; if ( dividendEstimate >= 0 ) { q = ( int ) ( dividendEstimate / divisorLong ) ; rem = ( int ) ( dividendEstimate - q * divisorLong ) ; } else { long tmp = divWord ( dividendEstimate , divisor ) ; q = ( int ) ( tmp & LONG_MASK ) ; rem = ( int ) ( tmp >>> 32 ) ; } quotient . value [ intLen - xlen ] = q ; remLong = rem & LONG_MASK ; } quotient . normalize ( ) ; // Unnormalize if ( shift > 0 ) return rem % divisor ; else return rem ; }"], "similar_code_tokens": [["private", "SQLQuery", "query", "(", "Class", "<", "?", ">", "...", "entity", ")", "{", "SQLQuery", "q", "=", "session", ".", "createSQLQuery", "(", "sql", ")", ";", "if", "(", "entity", ".", "length", "==", "1", ")", "{", "q", ".", "addEntity", "(", "entity", "[", "0", "]", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Type", ">", "scalar", ":", "scalars", ".", "entrySet", "(", ")", ")", "{", "q", ".", "addScalar", "(", "scalar", ".", "getKey", "(", ")", ",", "scalar", ".", "getValue", "(", ")", ")", ";", "}", "for", "(", "int", "i", "=", "0", ";", "i", "<", "positionedParameters", ".", "length", ";", "i", "++", ")", "{", "q", ".", "setParameter", "(", "i", ",", "positionedParameters", "[", "i", "]", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "namedParameters", ".", "entrySet", "(", ")", ")", "{", "Object", "value", "=", "entry", ".", "getValue", "(", ")", ";", "if", "(", "Types", ".", "isArray", "(", "value", ")", ")", "{", "Object", "[", "]", "parameter", "=", "(", "Object", "[", "]", ")", "value", ";", "if", "(", "parameter", ".", "length", "==", "0", ")", "{", "throw", "new", "HibernateException", "(", "String", ".", "format", "(", "\"Invalid named parameter |%s|. Empty array.\"", ",", "entry", ".", "getKey", "(", ")", ")", ")", ";", "}", "q", ".", "setParameterList", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "else", "if", "(", "Types", ".", "isCollection", "(", "value", ")", ")", "{", "Collection", "<", "?", ">", "parameter", "=", "(", "Collection", "<", "?", ">", ")", "value", ";", "if", "(", "parameter", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HibernateException", "(", "String", ".", "format", "(", "\"Invalid named parameter |%s|. Empty list.\"", ",", "entry", ".", "getKey", "(", ")", ")", ")", ";", "}", "q", ".", "setParameterList", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "else", "{", "q", ".", "setParameter", "(", "entry", ".", "getKey", "(", ")", ",", "value", ")", ";", "}", "}", "if", "(", "offset", ">", "0", ")", "{", "q", ".", "setFirstResult", "(", "offset", ")", ";", "}", "if", "(", "rowsCount", ">", "0", ")", "{", "q", ".", "setMaxResults", "(", "rowsCount", ")", ";", "}", "return", "q", ";", "}"], ["public", "static", "<", "T", ">", "boolean", "onNext", "(", "Subscriber", "<", "?", "super", "T", ">", "subscriber", ",", "T", "value", ",", "AtomicInteger", "wip", ",", "AtomicThrowable", "error", ")", "{", "if", "(", "wip", ".", "get", "(", ")", "==", "0", "&&", "wip", ".", "compareAndSet", "(", "0", ",", "1", ")", ")", "{", "subscriber", ".", "onNext", "(", "value", ")", ";", "if", "(", "wip", ".", "decrementAndGet", "(", ")", "!=", "0", ")", "{", "Throwable", "ex", "=", "error", ".", "terminate", "(", ")", ";", "if", "(", "ex", "!=", "null", ")", "{", "subscriber", ".", "onError", "(", "ex", ")", ";", "}", "else", "{", "subscriber", ".", "onComplete", "(", ")", ";", "}", "return", "true", ";", "}", "}", "return", "false", ";", "}"], ["private", "org", ".", "hibernate", ".", "Query", "query", "(", "String", "hql", ",", "Class", "<", "?", ">", "...", "type", ")", "{", "org", ".", "hibernate", ".", "Query", "q", "=", "session", ".", "createQuery", "(", "hql", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "positionedParameters", ".", "length", ";", "i", "++", ")", "{", "q", ".", "setParameter", "(", "i", ",", "positionedParameters", "[", "i", "]", ")", ";", "}", "for", "(", "Map", ".", "Entry", "<", "String", ",", "Object", ">", "entry", ":", "namedParameters", ".", "entrySet", "(", ")", ")", "{", "Object", "value", "=", "entry", ".", "getValue", "(", ")", ";", "if", "(", "Types", ".", "isArray", "(", "value", ")", ")", "{", "Object", "[", "]", "parameter", "=", "(", "Object", "[", "]", ")", "value", ";", "if", "(", "parameter", ".", "length", "==", "0", ")", "{", "throw", "new", "HibernateException", "(", "String", ".", "format", "(", "\"Invalid named parameter |%s|. Empty array.\"", ",", "entry", ".", "getKey", "(", ")", ")", ")", ";", "}", "q", ".", "setParameterList", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "else", "if", "(", "Types", ".", "isCollection", "(", "value", ")", ")", "{", "Collection", "<", "?", ">", "parameter", "=", "(", "Collection", "<", "?", ">", ")", "value", ";", "if", "(", "parameter", ".", "isEmpty", "(", ")", ")", "{", "throw", "new", "HibernateException", "(", "String", ".", "format", "(", "\"Invalid named parameter |%s|. Empty list.\"", ",", "entry", ".", "getKey", "(", ")", ")", ")", ";", "}", "q", ".", "setParameterList", "(", "entry", ".", "getKey", "(", ")", ",", "parameter", ")", ";", "}", "else", "{", "q", ".", "setParameter", "(", "entry", ".", "getKey", "(", ")", ",", "value", ")", ";", "}", "}", "if", "(", "offset", ">", "0", ")", "{", "q", ".", "setFirstResult", "(", "offset", ")", ";", "}", "if", "(", "rowsCount", ">", "0", ")", "{", "q", ".", "setMaxResults", "(", "rowsCount", ")", ";", "}", "if", "(", "type", ".", "length", ">", "0", ")", "{", "q", ".", "setResultTransformer", "(", "Transformers", ".", "aliasToBean", "(", "type", "[", "0", "]", ")", ")", ";", "}", "return", "q", ";", "}"], ["private", "void", "value", "(", "final", "String", "val", ",", "final", "String", "quoteChar", ")", "throws", "IOException", "{", "if", "(", "val", "==", "null", ")", "{", "return", ";", "}", "String", "q", "=", "quoteChar", ";", "if", "(", "q", "==", "null", ")", "{", "q", "=", "\"\"", ";", "}", "if", "(", "(", "val", ".", "indexOf", "(", "'", "'", ")", ">=", "0", ")", "||", "(", "val", ".", "indexOf", "(", "'", "'", ")", ">=", "0", ")", ")", "{", "out", "(", "\"<![CDATA[\"", ")", ";", "out", "(", "q", ")", ";", "out", "(", "val", ")", ";", "out", "(", "q", ")", ";", "out", "(", "\"]]>\"", ")", ";", "}", "else", "{", "out", "(", "q", ")", ";", "out", "(", "val", ")", ";", "out", "(", "q", ")", ";", "}", "}"], ["int", "divideOneWord", "(", "int", "divisor", ",", "MutableBigInteger", "quotient", ")", "{", "long", "divisorLong", "=", "divisor", "&", "LONG_MASK", ";", "// Special case of one word dividend", "if", "(", "intLen", "==", "1", ")", "{", "long", "dividendValue", "=", "value", "[", "offset", "]", "&", "LONG_MASK", ";", "int", "q", "=", "(", "int", ")", "(", "dividendValue", "/", "divisorLong", ")", ";", "int", "r", "=", "(", "int", ")", "(", "dividendValue", "-", "q", "*", "divisorLong", ")", ";", "quotient", ".", "value", "[", "0", "]", "=", "q", ";", "quotient", ".", "intLen", "=", "(", "q", "==", "0", ")", "?", "0", ":", "1", ";", "quotient", ".", "offset", "=", "0", ";", "return", "r", ";", "}", "if", "(", "quotient", ".", "value", ".", "length", "<", "intLen", ")", "quotient", ".", "value", "=", "new", "int", "[", "intLen", "]", ";", "quotient", ".", "offset", "=", "0", ";", "quotient", ".", "intLen", "=", "intLen", ";", "// Normalize the divisor", "int", "shift", "=", "Integer", ".", "numberOfLeadingZeros", "(", "divisor", ")", ";", "int", "rem", "=", "value", "[", "offset", "]", ";", "long", "remLong", "=", "rem", "&", "LONG_MASK", ";", "if", "(", "remLong", "<", "divisorLong", ")", "{", "quotient", ".", "value", "[", "0", "]", "=", "0", ";", "}", "else", "{", "quotient", ".", "value", "[", "0", "]", "=", "(", "int", ")", "(", "remLong", "/", "divisorLong", ")", ";", "rem", "=", "(", "int", ")", "(", "remLong", "-", "(", "quotient", ".", "value", "[", "0", "]", "*", "divisorLong", ")", ")", ";", "remLong", "=", "rem", "&", "LONG_MASK", ";", "}", "int", "xlen", "=", "intLen", ";", "while", "(", "--", "xlen", ">", "0", ")", "{", "long", "dividendEstimate", "=", "(", "remLong", "<<", "32", ")", "|", "(", "value", "[", "offset", "+", "intLen", "-", "xlen", "]", "&", "LONG_MASK", ")", ";", "int", "q", ";", "if", "(", "dividendEstimate", ">=", "0", ")", "{", "q", "=", "(", "int", ")", "(", "dividendEstimate", "/", "divisorLong", ")", ";", "rem", "=", "(", "int", ")", "(", "dividendEstimate", "-", "q", "*", "divisorLong", ")", ";", "}", "else", "{", "long", "tmp", "=", "divWord", "(", "dividendEstimate", ",", "divisor", ")", ";", "q", "=", "(", "int", ")", "(", "tmp", "&", "LONG_MASK", ")", ";", "rem", "=", "(", "int", ")", "(", "tmp", ">>>", "32", ")", ";", "}", "quotient", ".", "value", "[", "intLen", "-", "xlen", "]", "=", "q", ";", "remLong", "=", "rem", "&", "LONG_MASK", ";", "}", "quotient", ".", "normalize", "(", ")", ";", "// Unnormalize", "if", "(", "shift", ">", "0", ")", "return", "rem", "%", "divisor", ";", "else", "return", "rem", ";", "}"]], "similar_docstring": ["Create SQL query object and initialize it from this helper properties .", "Emits the given value if possible and terminates if there was an onComplete or onError while emitting drops the value otherwise .", "Create Hibernate query object and initialize it from this helper properties .", "Write out a value", "This method is used for division of an n word dividend by a one word divisor . The quotient is placed into quotient . The one word divisor is specified by divisor ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Observable.java", "func_name": "Observable.wrap", "original_string": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> wrap(ObservableSource<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        if (source instanceof Observable) {\n            return RxJavaPlugins.onAssembly((Observable<T>)source);\n        }\n        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));\n    }", "language": "java", "code": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> wrap(ObservableSource<T> source) {\n        ObjectHelper.requireNonNull(source, \"source is null\");\n        if (source instanceof Observable) {\n            return RxJavaPlugins.onAssembly((Observable<T>)source);\n        }\n        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Observable", "<", "T", ">", "wrap", "(", "ObservableSource", "<", "T", ">", "source", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "source", ",", "\"source is null\"", ")", ";", "if", "(", "source", "instanceof", "Observable", ")", "{", "return", "RxJavaPlugins", ".", "onAssembly", "(", "(", "Observable", "<", "T", ">", ")", "source", ")", ";", "}", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "ObservableFromUnsafeSource", "<", "T", ">", "(", "source", ")", ")", ";", "}"], "docstring": "Wraps an ObservableSource into an Observable if not already an Observable .", "docstring_tokens": ["Wraps", "an", "ObservableSource", "into", "an", "Observable", "if", "not", "already", "an", "Observable", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L4082-L4090", "partition": "test", "similar_code": ["@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > retry ( long times , Predicate < ? super Throwable > predicate ) { if ( times < 0 ) { throw new IllegalArgumentException ( \"times >= 0 required but it was \" + times ) ; } ObjectHelper . requireNonNull ( predicate , \"predicate is null\" ) ; return RxJavaPlugins . onAssembly ( new FlowableRetryPredicate < T > ( this , times , predicate ) ) ; }", "static < T > Observable < T > wrap ( ObservableSource < T > source , Collection < ReactiveInstrumenter > instrumentations ) { if ( source instanceof Callable ) { return new RxInstrumentedCallableObservable <> ( source , instrumentations ) ; } return new RxInstrumentedObservable <> ( source , instrumentations ) ; }", "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Flowable < T > concatDelayError ( Iterable < ? extends Publisher < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , \"sources is null\" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) ; }", "private static < T > Observable < Boolean > commitOrRollbackOnNext ( final boolean isCommit , final Database db , Observable < T > source ) { return source . concatMap ( new Func1 < T , Observable < Boolean > > ( ) { @ Override public Observable < Boolean > call ( T t ) { if ( isCommit ) return db . commit ( ) ; else return db . rollback ( ) ; } } ) ; }", "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U , R > Maybe < R > zipWith ( MaybeSource < ? extends U > other , BiFunction < ? super T , ? super U , ? extends R > zipper ) { ObjectHelper . requireNonNull ( other , \"other is null\" ) ; return zip ( this , other , zipper ) ; }"], "similar_code_tokens": [["@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Flowable", "<", "T", ">", "retry", "(", "long", "times", ",", "Predicate", "<", "?", "super", "Throwable", ">", "predicate", ")", "{", "if", "(", "times", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"times >= 0 required but it was \"", "+", "times", ")", ";", "}", "ObjectHelper", ".", "requireNonNull", "(", "predicate", ",", "\"predicate is null\"", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "FlowableRetryPredicate", "<", "T", ">", "(", "this", ",", "times", ",", "predicate", ")", ")", ";", "}"], ["static", "<", "T", ">", "Observable", "<", "T", ">", "wrap", "(", "ObservableSource", "<", "T", ">", "source", ",", "Collection", "<", "ReactiveInstrumenter", ">", "instrumentations", ")", "{", "if", "(", "source", "instanceof", "Callable", ")", "{", "return", "new", "RxInstrumentedCallableObservable", "<>", "(", "source", ",", "instrumentations", ")", ";", "}", "return", "new", "RxInstrumentedObservable", "<>", "(", "source", ",", "instrumentations", ")", ";", "}"], ["@", "SuppressWarnings", "(", "{", "\"unchecked\"", ",", "\"rawtypes\"", "}", ")", "@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Flowable", "<", "T", ">", "concatDelayError", "(", "Iterable", "<", "?", "extends", "Publisher", "<", "?", "extends", "T", ">", ">", "sources", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sources", ",", "\"sources is null\"", ")", ";", "return", "fromIterable", "(", "sources", ")", ".", "concatMapDelayError", "(", "(", "Function", ")", "Functions", ".", "identity", "(", ")", ")", ";", "}"], ["private", "static", "<", "T", ">", "Observable", "<", "Boolean", ">", "commitOrRollbackOnNext", "(", "final", "boolean", "isCommit", ",", "final", "Database", "db", ",", "Observable", "<", "T", ">", "source", ")", "{", "return", "source", ".", "concatMap", "(", "new", "Func1", "<", "T", ",", "Observable", "<", "Boolean", ">", ">", "(", ")", "{", "@", "Override", "public", "Observable", "<", "Boolean", ">", "call", "(", "T", "t", ")", "{", "if", "(", "isCommit", ")", "return", "db", ".", "commit", "(", ")", ";", "else", "return", "db", ".", "rollback", "(", ")", ";", "}", "}", ")", ";", "}"], ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "<", "U", ",", "R", ">", "Maybe", "<", "R", ">", "zipWith", "(", "MaybeSource", "<", "?", "extends", "U", ">", "other", ",", "BiFunction", "<", "?", "super", "T", ",", "?", "super", "U", ",", "?", "extends", "R", ">", "zipper", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "other", ",", "\"other is null\"", ")", ";", "return", "zip", "(", "this", ",", "other", ",", "zipper", ")", ";", "}"]], "similar_docstring": ["Retries at most times or until the predicate returns false whichever happens first .", "Wrap a observable .", "Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher one after the other one at a time and delays any errors till the all inner Publishers terminate .", "Emits true for commit and false for rollback .", "Waits until this and the other MaybeSource signal a success value then applies the given BiFunction to those values and emits the BiFunction s resulting value to downstream ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/Observable.java", "func_name": "Observable.sorted", "original_string": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Observable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\");\n        return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "language": "java", "code": "@CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Observable<T> sorted(Comparator<? super T> sortFunction) {\n        ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\");\n        return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Observable", "<", "T", ">", "sorted", "(", "Comparator", "<", "?", "super", "T", ">", "sortFunction", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sortFunction", ",", "\"sortFunction is null\"", ")", ";", "return", "toList", "(", ")", ".", "toObservable", "(", ")", ".", "map", "(", "Functions", ".", "listSorter", "(", "sortFunction", ")", ")", ".", "flatMapIterable", "(", "Functions", ".", "<", "List", "<", "T", ">", ">", "identity", "(", ")", ")", ";", "}"], "docstring": "Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .", "docstring_tokens": ["Returns", "an", "Observable", "that", "emits", "the", "events", "emitted", "by", "source", "ObservableSource", "in", "a", "sorted", "order", "based", "on", "a", "specified", "comparison", "function", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/Observable.java#L12008-L12013", "partition": "test", "similar_code": ["@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Flowable < T > concatDelayError ( Iterable < ? extends Publisher < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , \"sources is null\" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) ; }", "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U , R > Maybe < R > zipWith ( MaybeSource < ? extends U > other , BiFunction < ? super T , ? super U , ? extends R > zipper ) { ObjectHelper . requireNonNull ( other , \"other is null\" ) ; return zip ( this , other , zipper ) ; }", "@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > retry ( long times , Predicate < ? super Throwable > predicate ) { if ( times < 0 ) { throw new IllegalArgumentException ( \"times >= 0 required but it was \" + times ) ; } ObjectHelper . requireNonNull ( predicate , \"predicate is null\" ) ; return RxJavaPlugins . onAssembly ( new FlowableRetryPredicate < T > ( this , times , predicate ) ) ; }", "public static < T > Choice < T > any ( final Collection < Choice < T > > choices ) { return from ( choices ) . thenChoose ( Functions . < Choice < T > > identity ( ) ) ; }", "public static < T , C extends Comparable < ? super C > > List < T > sortBy ( Iterable < T > iterable , final Functions . Function1 < ? super T , C > key ) { return ListExtensions . sortInplaceBy ( Lists . newArrayList ( iterable ) , key ) ; }"], "similar_code_tokens": [["@", "SuppressWarnings", "(", "{", "\"unchecked\"", ",", "\"rawtypes\"", "}", ")", "@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Flowable", "<", "T", ">", "concatDelayError", "(", "Iterable", "<", "?", "extends", "Publisher", "<", "?", "extends", "T", ">", ">", "sources", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sources", ",", "\"sources is null\"", ")", ";", "return", "fromIterable", "(", "sources", ")", ".", "concatMapDelayError", "(", "(", "Function", ")", "Functions", ".", "identity", "(", ")", ")", ";", "}"], ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "<", "U", ",", "R", ">", "Maybe", "<", "R", ">", "zipWith", "(", "MaybeSource", "<", "?", "extends", "U", ">", "other", ",", "BiFunction", "<", "?", "super", "T", ",", "?", "super", "U", ",", "?", "extends", "R", ">", "zipper", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "other", ",", "\"other is null\"", ")", ";", "return", "zip", "(", "this", ",", "other", ",", "zipper", ")", ";", "}"], ["@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Flowable", "<", "T", ">", "retry", "(", "long", "times", ",", "Predicate", "<", "?", "super", "Throwable", ">", "predicate", ")", "{", "if", "(", "times", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"times >= 0 required but it was \"", "+", "times", ")", ";", "}", "ObjectHelper", ".", "requireNonNull", "(", "predicate", ",", "\"predicate is null\"", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "FlowableRetryPredicate", "<", "T", ">", "(", "this", ",", "times", ",", "predicate", ")", ")", ";", "}"], ["public", "static", "<", "T", ">", "Choice", "<", "T", ">", "any", "(", "final", "Collection", "<", "Choice", "<", "T", ">", ">", "choices", ")", "{", "return", "from", "(", "choices", ")", ".", "thenChoose", "(", "Functions", ".", "<", "Choice", "<", "T", ">", ">", "identity", "(", ")", ")", ";", "}"], ["public", "static", "<", "T", ",", "C", "extends", "Comparable", "<", "?", "super", "C", ">", ">", "List", "<", "T", ">", "sortBy", "(", "Iterable", "<", "T", ">", "iterable", ",", "final", "Functions", ".", "Function1", "<", "?", "super", "T", ",", "C", ">", "key", ")", "{", "return", "ListExtensions", ".", "sortInplaceBy", "(", "Lists", ".", "newArrayList", "(", "iterable", ")", ",", "key", ")", ";", "}"]], "similar_docstring": ["Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher one after the other one at a time and delays any errors till the all inner Publishers terminate .", "Waits until this and the other MaybeSource signal a success value then applies the given BiFunction to those values and emits the BiFunction s resulting value to downstream .", "Retries at most times or until the predicate returns false whichever happens first .", "Returns a choice between any of the options from any of the specified choices .", "Creates a sorted list that contains the items of the given iterable . The resulting list is sorted according to the order induced by applying a key function to each element which yields a comparable criteria ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java", "func_name": "ObservableReplay.observeOn", "original_string": "public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {\n        final Observable<T> observable = co.observeOn(scheduler);\n        return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));\n    }", "language": "java", "code": "public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {\n        final Observable<T> observable = co.observeOn(scheduler);\n        return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));\n    }", "code_tokens": ["public", "static", "<", "T", ">", "ConnectableObservable", "<", "T", ">", "observeOn", "(", "final", "ConnectableObservable", "<", "T", ">", "co", ",", "final", "Scheduler", "scheduler", ")", "{", "final", "Observable", "<", "T", ">", "observable", "=", "co", ".", "observeOn", "(", "scheduler", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "Replay", "<", "T", ">", "(", "co", ",", "observable", ")", ")", ";", "}"], "docstring": "Child Observers will observe the events of the ConnectableObservable on the specified scheduler .", "docstring_tokens": ["Child", "Observers", "will", "observe", "the", "events", "of", "the", "ConnectableObservable", "on", "the", "specified", "scheduler", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java#L74-L77", "partition": "test", "similar_code": ["public static < T , U > StoppableObservable < U > runAsync ( Scheduler scheduler , final Subject < T , U > subject , final Action2 < ? super Observer < ? super T > , ? super Subscription > action ) { final SerialSubscription csub = new SerialSubscription ( ) ; StoppableObservable < U > co = new StoppableObservable < U > ( new Observable . OnSubscribe < U > ( ) { @ Override public void call ( Subscriber < ? super U > t1 ) { subject . subscribe ( t1 ) ; } } , csub ) ; final Worker inner = scheduler . createWorker ( ) ; csub . set ( inner ) ; inner . schedule ( new Action0 ( ) { @ Override public void call ( ) { if ( ! csub . isUnsubscribed ( ) ) { action . call ( subject , csub ) ; } } } ) ; return co ; }", "public static < T > StoppableObservable < T > runAsync ( Scheduler scheduler , final Action2 < ? super Observer < ? super T > , ? super Subscription > action ) { return runAsync ( scheduler , PublishSubject . < T > create ( ) , action ) ; }", "static < T > ConnectableObservable < T > wrap ( ConnectableObservable < T > source , Collection < ReactiveInstrumenter > instrumentations ) { return new RxInstrumentedConnectableObservable <> ( source , instrumentations ) ; }", "public static < T > Publisher < T > publisher ( Observable < T > observable ) { return observable . toFlowable ( BackpressureStrategy . BUFFER ) ; }", "public < T > Observable < ServiceResponse < T > > getPutOrPatchResultAsync ( Observable < Response < ResponseBody > > observable , final Type resourceType ) { return this . < T > beginPutOrPatchAsync ( observable , resourceType ) . toObservable ( ) . flatMap ( new Func1 < PollingState < T > , Observable < PollingState < T > > > ( ) { @ Override public Observable < PollingState < T > > call ( PollingState < T > pollingState ) { return pollPutOrPatchAsync ( pollingState , resourceType ) ; } } ) . last ( ) . map ( new Func1 < PollingState < T > , ServiceResponse < T > > ( ) { @ Override public ServiceResponse < T > call ( PollingState < T > pollingState ) { return new ServiceResponse <> ( pollingState . resource ( ) , pollingState . response ( ) ) ; } } ) ; }"], "similar_code_tokens": [["public", "static", "<", "T", ",", "U", ">", "StoppableObservable", "<", "U", ">", "runAsync", "(", "Scheduler", "scheduler", ",", "final", "Subject", "<", "T", ",", "U", ">", "subject", ",", "final", "Action2", "<", "?", "super", "Observer", "<", "?", "super", "T", ">", ",", "?", "super", "Subscription", ">", "action", ")", "{", "final", "SerialSubscription", "csub", "=", "new", "SerialSubscription", "(", ")", ";", "StoppableObservable", "<", "U", ">", "co", "=", "new", "StoppableObservable", "<", "U", ">", "(", "new", "Observable", ".", "OnSubscribe", "<", "U", ">", "(", ")", "{", "@", "Override", "public", "void", "call", "(", "Subscriber", "<", "?", "super", "U", ">", "t1", ")", "{", "subject", ".", "subscribe", "(", "t1", ")", ";", "}", "}", ",", "csub", ")", ";", "final", "Worker", "inner", "=", "scheduler", ".", "createWorker", "(", ")", ";", "csub", ".", "set", "(", "inner", ")", ";", "inner", ".", "schedule", "(", "new", "Action0", "(", ")", "{", "@", "Override", "public", "void", "call", "(", ")", "{", "if", "(", "!", "csub", ".", "isUnsubscribed", "(", ")", ")", "{", "action", ".", "call", "(", "subject", ",", "csub", ")", ";", "}", "}", "}", ")", ";", "return", "co", ";", "}"], ["public", "static", "<", "T", ">", "StoppableObservable", "<", "T", ">", "runAsync", "(", "Scheduler", "scheduler", ",", "final", "Action2", "<", "?", "super", "Observer", "<", "?", "super", "T", ">", ",", "?", "super", "Subscription", ">", "action", ")", "{", "return", "runAsync", "(", "scheduler", ",", "PublishSubject", ".", "<", "T", ">", "create", "(", ")", ",", "action", ")", ";", "}"], ["static", "<", "T", ">", "ConnectableObservable", "<", "T", ">", "wrap", "(", "ConnectableObservable", "<", "T", ">", "source", ",", "Collection", "<", "ReactiveInstrumenter", ">", "instrumentations", ")", "{", "return", "new", "RxInstrumentedConnectableObservable", "<>", "(", "source", ",", "instrumentations", ")", ";", "}"], ["public", "static", "<", "T", ">", "Publisher", "<", "T", ">", "publisher", "(", "Observable", "<", "T", ">", "observable", ")", "{", "return", "observable", ".", "toFlowable", "(", "BackpressureStrategy", ".", "BUFFER", ")", ";", "}"], ["public", "<", "T", ">", "Observable", "<", "ServiceResponse", "<", "T", ">", ">", "getPutOrPatchResultAsync", "(", "Observable", "<", "Response", "<", "ResponseBody", ">", ">", "observable", ",", "final", "Type", "resourceType", ")", "{", "return", "this", ".", "<", "T", ">", "beginPutOrPatchAsync", "(", "observable", ",", "resourceType", ")", ".", "toObservable", "(", ")", ".", "flatMap", "(", "new", "Func1", "<", "PollingState", "<", "T", ">", ",", "Observable", "<", "PollingState", "<", "T", ">", ">", ">", "(", ")", "{", "@", "Override", "public", "Observable", "<", "PollingState", "<", "T", ">", ">", "call", "(", "PollingState", "<", "T", ">", "pollingState", ")", "{", "return", "pollPutOrPatchAsync", "(", "pollingState", ",", "resourceType", ")", ";", "}", "}", ")", ".", "last", "(", ")", ".", "map", "(", "new", "Func1", "<", "PollingState", "<", "T", ">", ",", "ServiceResponse", "<", "T", ">", ">", "(", ")", "{", "@", "Override", "public", "ServiceResponse", "<", "T", ">", "call", "(", "PollingState", "<", "T", ">", "pollingState", ")", "{", "return", "new", "ServiceResponse", "<>", "(", "pollingState", ".", "resource", "(", ")", ",", "pollingState", ".", "response", "(", ")", ")", ";", "}", "}", ")", ";", "}"]], "similar_docstring": ["Runs the provided action on the given scheduler and allows propagation of multiple events to the observers of the returned StoppableObservable . The action is immediately executed and unobserved values might be lost depending on the Subject type used .", "Runs the provided action on the given scheduler and allows propagation of multiple events to the observers of the returned StoppableObservable . The action is immediately executed and unobserved values will be lost .", "Wrap a connectable observable .", "Convert an Observable to a reactive - streams Publisher", "Handles an initial response from a PUT or PATCH operation response by polling the status of the operation asynchronously once the operation finishes emits the final response ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/UnicastProcessor.java", "func_name": "UnicastProcessor.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint) {\n        return new UnicastProcessor<T>(capacityHint);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint) {\n        return new UnicastProcessor<T>(capacityHint);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastProcessor", "<", "T", ">", "create", "(", "int", "capacityHint", ")", "{", "return", "new", "UnicastProcessor", "<", "T", ">", "(", "capacityHint", ")", ";", "}"], "docstring": "Creates an UnicastProcessor with the given internal buffer capacity hint .", "docstring_tokens": ["Creates", "an", "UnicastProcessor", "with", "the", "given", "internal", "buffer", "capacity", "hint", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/UnicastProcessor.java#L192-L196", "partition": "test", "similar_code": ["public static final < T > Transformer < T , List < T > > bufferWhile ( Func1 < ? super T , Boolean > predicate , int capacityHint ) { return new OperatorBufferPredicateBoundary < T > ( predicate , RxRingBuffer . SIZE , capacityHint , false ) ; }", "@ Override public WritableBuffer allocate ( int capacityHint ) { capacityHint = Math . min ( MAX_BUFFER , Math . max ( MIN_BUFFER , capacityHint ) ) ; return new OkHttpWritableBuffer ( new Buffer ( ) , capacityHint ) ; }", "public static < T extends Enum < T > > @ NonNull NameMap < T > create ( final T @ NonNull [ ] constants , final @ NonNull Function < T , String > namer ) { final Map < String , T > byName = new HashMap <> ( constants . length ) ; final Map < T , String > byValue = new HashMap <> ( constants . length ) ; for ( int i = 0 , length = constants . length ; i < length ; i ++ ) { final T constant = constants [ i ] ; final String name = namer . apply ( constant ) ; byName . put ( name , constant ) ; byValue . put ( constant , name ) ; } return new NameMap <> ( Collections . unmodifiableMap ( byName ) , Collections . unmodifiableMap ( byValue ) ) ; }", "public static < T , E extends Throwable > @ NonNull Consumer < T > rethrowConsumer ( final @ NonNull ThrowingConsumer < T , E > consumer ) { return consumer ; }", "public static < T , E extends Throwable > @ NonNull Predicate < T > rethrowPredicate ( final @ NonNull ThrowingPredicate < T , E > predicate ) { return predicate ; }"], "similar_code_tokens": [["public", "static", "final", "<", "T", ">", "Transformer", "<", "T", ",", "List", "<", "T", ">", ">", "bufferWhile", "(", "Func1", "<", "?", "super", "T", ",", "Boolean", ">", "predicate", ",", "int", "capacityHint", ")", "{", "return", "new", "OperatorBufferPredicateBoundary", "<", "T", ">", "(", "predicate", ",", "RxRingBuffer", ".", "SIZE", ",", "capacityHint", ",", "false", ")", ";", "}"], ["@", "Override", "public", "WritableBuffer", "allocate", "(", "int", "capacityHint", ")", "{", "capacityHint", "=", "Math", ".", "min", "(", "MAX_BUFFER", ",", "Math", ".", "max", "(", "MIN_BUFFER", ",", "capacityHint", ")", ")", ";", "return", "new", "OkHttpWritableBuffer", "(", "new", "Buffer", "(", ")", ",", "capacityHint", ")", ";", "}"], ["public", "static", "<", "T", "extends", "Enum", "<", "T", ">", ">", "@", "NonNull", "NameMap", "<", "T", ">", "create", "(", "final", "T", "@", "NonNull", "[", "]", "constants", ",", "final", "@", "NonNull", "Function", "<", "T", ",", "String", ">", "namer", ")", "{", "final", "Map", "<", "String", ",", "T", ">", "byName", "=", "new", "HashMap", "<>", "(", "constants", ".", "length", ")", ";", "final", "Map", "<", "T", ",", "String", ">", "byValue", "=", "new", "HashMap", "<>", "(", "constants", ".", "length", ")", ";", "for", "(", "int", "i", "=", "0", ",", "length", "=", "constants", ".", "length", ";", "i", "<", "length", ";", "i", "++", ")", "{", "final", "T", "constant", "=", "constants", "[", "i", "]", ";", "final", "String", "name", "=", "namer", ".", "apply", "(", "constant", ")", ";", "byName", ".", "put", "(", "name", ",", "constant", ")", ";", "byValue", ".", "put", "(", "constant", ",", "name", ")", ";", "}", "return", "new", "NameMap", "<>", "(", "Collections", ".", "unmodifiableMap", "(", "byName", ")", ",", "Collections", ".", "unmodifiableMap", "(", "byValue", ")", ")", ";", "}"], ["public", "static", "<", "T", ",", "E", "extends", "Throwable", ">", "@", "NonNull", "Consumer", "<", "T", ">", "rethrowConsumer", "(", "final", "@", "NonNull", "ThrowingConsumer", "<", "T", ",", "E", ">", "consumer", ")", "{", "return", "consumer", ";", "}"], ["public", "static", "<", "T", ",", "E", "extends", "Throwable", ">", "@", "NonNull", "Predicate", "<", "T", ">", "rethrowPredicate", "(", "final", "@", "NonNull", "ThrowingPredicate", "<", "T", ",", "E", ">", "predicate", ")", "{", "return", "predicate", ";", "}"]], "similar_docstring": ["Buffers the elements into continuous non - overlapping Lists where the boundary is determined by a predicate receiving each item before being buffered and returns true to indicate a new buffer should start .", "For OkHttp we will often return a buffer smaller than the requested capacity as this is the mechanism for chunking a large GRPC message over many DATA frames .", "Creates a name map .", "Returns the same throwing consumer .", "Returns the same throwing predicate ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/processors/UnicastProcessor.java", "func_name": "UnicastProcessor.create", "original_string": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {\n        ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\n        return new UnicastProcessor<T>(capacityHint, onCancelled);\n    }", "language": "java", "code": "@CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {\n        ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\n        return new UnicastProcessor<T>(capacityHint, onCancelled);\n    }", "code_tokens": ["@", "CheckReturnValue", "@", "NonNull", "public", "static", "<", "T", ">", "UnicastProcessor", "<", "T", ">", "create", "(", "int", "capacityHint", ",", "Runnable", "onCancelled", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "onCancelled", ",", "\"onTerminate\"", ")", ";", "return", "new", "UnicastProcessor", "<", "T", ">", "(", "capacityHint", ",", "onCancelled", ")", ";", "}"], "docstring": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .", "docstring_tokens": ["Creates", "an", "UnicastProcessor", "with", "the", "given", "internal", "buffer", "capacity", "hint", "and", "a", "callback", "for", "the", "case", "when", "the", "single", "Subscriber", "cancels", "its", "subscription", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/processors/UnicastProcessor.java#L224-L229", "partition": "test", "similar_code": ["public static final < T > Transformer < T , List < T > > bufferWhile ( Func1 < ? super T , Boolean > predicate , int capacityHint ) { return new OperatorBufferPredicateBoundary < T > ( predicate , RxRingBuffer . SIZE , capacityHint , false ) ; }", "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Flowable < T > concatDelayError ( Iterable < ? extends Publisher < ? extends T > > sources ) { ObjectHelper . requireNonNull ( sources , \"sources is null\" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) ; }", "@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > retry ( long times , Predicate < ? super Throwable > predicate ) { if ( times < 0 ) { throw new IllegalArgumentException ( \"times >= 0 required but it was \" + times ) ; } ObjectHelper . requireNonNull ( predicate , \"predicate is null\" ) ; return RxJavaPlugins . onAssembly ( new FlowableRetryPredicate < T > ( this , times , predicate ) ) ; }", "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U , R > Maybe < R > zipWith ( MaybeSource < ? extends U > other , BiFunction < ? super T , ? super U , ? extends R > zipper ) { ObjectHelper . requireNonNull ( other , \"other is null\" ) ; return zip ( this , other , zipper ) ; }", "@ Override public WritableBuffer allocate ( int capacityHint ) { capacityHint = Math . min ( MAX_BUFFER , Math . max ( MIN_BUFFER , capacityHint ) ) ; return new OkHttpWritableBuffer ( new Buffer ( ) , capacityHint ) ; }"], "similar_code_tokens": [["public", "static", "final", "<", "T", ">", "Transformer", "<", "T", ",", "List", "<", "T", ">", ">", "bufferWhile", "(", "Func1", "<", "?", "super", "T", ",", "Boolean", ">", "predicate", ",", "int", "capacityHint", ")", "{", "return", "new", "OperatorBufferPredicateBoundary", "<", "T", ">", "(", "predicate", ",", "RxRingBuffer", ".", "SIZE", ",", "capacityHint", ",", "false", ")", ";", "}"], ["@", "SuppressWarnings", "(", "{", "\"unchecked\"", ",", "\"rawtypes\"", "}", ")", "@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "static", "<", "T", ">", "Flowable", "<", "T", ">", "concatDelayError", "(", "Iterable", "<", "?", "extends", "Publisher", "<", "?", "extends", "T", ">", ">", "sources", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "sources", ",", "\"sources is null\"", ")", ";", "return", "fromIterable", "(", "sources", ")", ".", "concatMapDelayError", "(", "(", "Function", ")", "Functions", ".", "identity", "(", ")", ")", ";", "}"], ["@", "CheckReturnValue", "@", "BackpressureSupport", "(", "BackpressureKind", ".", "FULL", ")", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "Flowable", "<", "T", ">", "retry", "(", "long", "times", ",", "Predicate", "<", "?", "super", "Throwable", ">", "predicate", ")", "{", "if", "(", "times", "<", "0", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"times >= 0 required but it was \"", "+", "times", ")", ";", "}", "ObjectHelper", ".", "requireNonNull", "(", "predicate", ",", "\"predicate is null\"", ")", ";", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "FlowableRetryPredicate", "<", "T", ">", "(", "this", ",", "times", ",", "predicate", ")", ")", ";", "}"], ["@", "CheckReturnValue", "@", "SchedulerSupport", "(", "SchedulerSupport", ".", "NONE", ")", "public", "final", "<", "U", ",", "R", ">", "Maybe", "<", "R", ">", "zipWith", "(", "MaybeSource", "<", "?", "extends", "U", ">", "other", ",", "BiFunction", "<", "?", "super", "T", ",", "?", "super", "U", ",", "?", "extends", "R", ">", "zipper", ")", "{", "ObjectHelper", ".", "requireNonNull", "(", "other", ",", "\"other is null\"", ")", ";", "return", "zip", "(", "this", ",", "other", ",", "zipper", ")", ";", "}"], ["@", "Override", "public", "WritableBuffer", "allocate", "(", "int", "capacityHint", ")", "{", "capacityHint", "=", "Math", ".", "min", "(", "MAX_BUFFER", ",", "Math", ".", "max", "(", "MIN_BUFFER", ",", "capacityHint", ")", ")", ";", "return", "new", "OkHttpWritableBuffer", "(", "new", "Buffer", "(", ")", ",", "capacityHint", ")", ";", "}"]], "similar_docstring": ["Buffers the elements into continuous non - overlapping Lists where the boundary is determined by a predicate receiving each item before being buffered and returns true to indicate a new buffer should start .", "Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher one after the other one at a time and delays any errors till the all inner Publishers terminate .", "Retries at most times or until the predicate returns false whichever happens first .", "Waits until this and the other MaybeSource signal a success value then applies the given BiFunction to those values and emits the BiFunction s resulting value to downstream .", "For OkHttp we will often return a buffer smaller than the requested capacity as this is the mechanism for chunking a large GRPC message over many DATA frames ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java", "func_name": "FlowableScalarXMap.tryScalarXMapSubscribe", "original_string": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,\n            Subscriber<? super R> subscriber,\n            Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (t == null) {\n                EmptySubscription.complete(subscriber);\n                return true;\n            }\n\n            Publisher<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptySubscription.error(ex, subscriber);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptySubscription.complete(subscriber);\n                    return true;\n                }\n                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));\n            } else {\n                r.subscribe(subscriber);\n            }\n\n            return true;\n        }\n        return false;\n    }", "language": "java", "code": "@SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,\n            Subscriber<? super R> subscriber,\n            Function<? super T, ? extends Publisher<? extends R>> mapper) {\n        if (source instanceof Callable) {\n            T t;\n\n            try {\n                t = ((Callable<T>)source).call();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (t == null) {\n                EmptySubscription.complete(subscriber);\n                return true;\n            }\n\n            Publisher<? extends R> r;\n\n            try {\n                r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, subscriber);\n                return true;\n            }\n\n            if (r instanceof Callable) {\n                R u;\n\n                try {\n                    u = ((Callable<R>)r).call();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptySubscription.error(ex, subscriber);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptySubscription.complete(subscriber);\n                    return true;\n                }\n                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));\n            } else {\n                r.subscribe(subscriber);\n            }\n\n            return true;\n        }\n        return false;\n    }", "code_tokens": ["@", "SuppressWarnings", "(", "\"unchecked\"", ")", "public", "static", "<", "T", ",", "R", ">", "boolean", "tryScalarXMapSubscribe", "(", "Publisher", "<", "T", ">", "source", ",", "Subscriber", "<", "?", "super", "R", ">", "subscriber", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "Publisher", "<", "?", "extends", "R", ">", ">", "mapper", ")", "{", "if", "(", "source", "instanceof", "Callable", ")", "{", "T", "t", ";", "try", "{", "t", "=", "(", "(", "Callable", "<", "T", ">", ")", "source", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "t", "==", "null", ")", "{", "EmptySubscription", ".", "complete", "(", "subscriber", ")", ";", "return", "true", ";", "}", "Publisher", "<", "?", "extends", "R", ">", "r", ";", "try", "{", "r", "=", "ObjectHelper", ".", "requireNonNull", "(", "mapper", ".", "apply", "(", "t", ")", ",", "\"The mapper returned a null Publisher\"", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "r", "instanceof", "Callable", ")", "{", "R", "u", ";", "try", "{", "u", "=", "(", "(", "Callable", "<", "R", ">", ")", "r", ")", ".", "call", "(", ")", ";", "}", "catch", "(", "Throwable", "ex", ")", "{", "Exceptions", ".", "throwIfFatal", "(", "ex", ")", ";", "EmptySubscription", ".", "error", "(", "ex", ",", "subscriber", ")", ";", "return", "true", ";", "}", "if", "(", "u", "==", "null", ")", "{", "EmptySubscription", ".", "complete", "(", "subscriber", ")", ";", "return", "true", ";", "}", "subscriber", ".", "onSubscribe", "(", "new", "ScalarSubscription", "<", "R", ">", "(", "subscriber", ",", "u", ")", ")", ";", "}", "else", "{", "r", ".", "subscribe", "(", "subscriber", ")", ";", "}", "return", "true", ";", "}", "return", "false", ";", "}"], "docstring": "Tries to subscribe to a possibly Callable source s mapped Publisher .", "docstring_tokens": ["Tries", "to", "subscribe", "to", "a", "possibly", "Callable", "source", "s", "mapped", "Publisher", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java#L46-L99", "partition": "test", "similar_code": ["public static < T > boolean onNext ( Subscriber < ? super T > subscriber , T value , AtomicInteger wip , AtomicThrowable error ) { if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { subscriber . onNext ( value ) ; if ( wip . decrementAndGet ( ) != 0 ) { Throwable ex = error . terminate ( ) ; if ( ex != null ) { subscriber . onError ( ex ) ; } else { subscriber . onComplete ( ) ; } return true ; } } return false ; }", "public static < T > Observable < T > wrapColdWithAutoRelease ( final Observable < T > source ) { return Observable . create ( new Observable . OnSubscribe < T > ( ) { @ Override public void call ( final Subscriber < ? super T > subscriber ) { source . subscribe ( new Subscriber < T > ( ) { @ Override public void onCompleted ( ) { if ( ! subscriber . isUnsubscribed ( ) ) { subscriber . onCompleted ( ) ; } } @ Override public void onError ( Throwable e ) { if ( ! subscriber . isUnsubscribed ( ) ) { subscriber . onError ( e ) ; } } @ Override public void onNext ( T t ) { if ( ! subscriber . isUnsubscribed ( ) ) { subscriber . onNext ( t ) ; } else { ReferenceCountUtil . release ( t ) ; } } } ) ; } } ) ; }", "public static < T , M , R > Processor < T , R > combine ( Processor < T , M > processor1 , Processor < M , R > processor2 ) { processor1 . subscribe ( processor2 ) ; return new Processor <> ( ) { @ Override public void subscribe ( Flow . Subscriber < ? super R > subscriber ) { processor2 . subscribe ( subscriber ) ; } @ Override public void onSubscribe ( Flow . Subscription subscription ) { processor1 . onSubscribe ( subscription ) ; } @ Override public void onNext ( T item ) { processor1 . onNext ( item ) ; } @ Override public void onError ( Throwable throwable ) { processor1 . onError ( throwable ) ; } @ Override public void onComplete ( ) { processor1 . onComplete ( ) ; } } ; }", "public static < T > Future < T > fromPublisher ( final Publisher < T > pub , final Executor ex ) { final ValueSubscriber < T > sub = ValueSubscriber . subscriber ( ) ; pub . subscribe ( sub ) ; return sub . toFutureAsync ( ex ) ; }", "@ SneakyThrows public static < T , R > Function < T , R > doAndHandle ( final CheckedFunction < T , R > function , final CheckedFunction < Throwable , R > errorHandler ) { return t -> { try { return function . apply ( t ) ; } catch ( final Throwable e ) { LOGGER . warn ( e . getMessage ( ) , e ) ; try { return errorHandler . apply ( e ) ; } catch ( final Throwable ex ) { throw new IllegalArgumentException ( ex . getMessage ( ) ) ; } } } ; }"], "similar_code_tokens": [["public", "static", "<", "T", ">", "boolean", "onNext", "(", "Subscriber", "<", "?", "super", "T", ">", "subscriber", ",", "T", "value", ",", "AtomicInteger", "wip", ",", "AtomicThrowable", "error", ")", "{", "if", "(", "wip", ".", "get", "(", ")", "==", "0", "&&", "wip", ".", "compareAndSet", "(", "0", ",", "1", ")", ")", "{", "subscriber", ".", "onNext", "(", "value", ")", ";", "if", "(", "wip", ".", "decrementAndGet", "(", ")", "!=", "0", ")", "{", "Throwable", "ex", "=", "error", ".", "terminate", "(", ")", ";", "if", "(", "ex", "!=", "null", ")", "{", "subscriber", ".", "onError", "(", "ex", ")", ";", "}", "else", "{", "subscriber", ".", "onComplete", "(", ")", ";", "}", "return", "true", ";", "}", "}", "return", "false", ";", "}"], ["public", "static", "<", "T", ">", "Observable", "<", "T", ">", "wrapColdWithAutoRelease", "(", "final", "Observable", "<", "T", ">", "source", ")", "{", "return", "Observable", ".", "create", "(", "new", "Observable", ".", "OnSubscribe", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "void", "call", "(", "final", "Subscriber", "<", "?", "super", "T", ">", "subscriber", ")", "{", "source", ".", "subscribe", "(", "new", "Subscriber", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "void", "onCompleted", "(", ")", "{", "if", "(", "!", "subscriber", ".", "isUnsubscribed", "(", ")", ")", "{", "subscriber", ".", "onCompleted", "(", ")", ";", "}", "}", "@", "Override", "public", "void", "onError", "(", "Throwable", "e", ")", "{", "if", "(", "!", "subscriber", ".", "isUnsubscribed", "(", ")", ")", "{", "subscriber", ".", "onError", "(", "e", ")", ";", "}", "}", "@", "Override", "public", "void", "onNext", "(", "T", "t", ")", "{", "if", "(", "!", "subscriber", ".", "isUnsubscribed", "(", ")", ")", "{", "subscriber", ".", "onNext", "(", "t", ")", ";", "}", "else", "{", "ReferenceCountUtil", ".", "release", "(", "t", ")", ";", "}", "}", "}", ")", ";", "}", "}", ")", ";", "}"], ["public", "static", "<", "T", ",", "M", ",", "R", ">", "Processor", "<", "T", ",", "R", ">", "combine", "(", "Processor", "<", "T", ",", "M", ">", "processor1", ",", "Processor", "<", "M", ",", "R", ">", "processor2", ")", "{", "processor1", ".", "subscribe", "(", "processor2", ")", ";", "return", "new", "Processor", "<>", "(", ")", "{", "@", "Override", "public", "void", "subscribe", "(", "Flow", ".", "Subscriber", "<", "?", "super", "R", ">", "subscriber", ")", "{", "processor2", ".", "subscribe", "(", "subscriber", ")", ";", "}", "@", "Override", "public", "void", "onSubscribe", "(", "Flow", ".", "Subscription", "subscription", ")", "{", "processor1", ".", "onSubscribe", "(", "subscription", ")", ";", "}", "@", "Override", "public", "void", "onNext", "(", "T", "item", ")", "{", "processor1", ".", "onNext", "(", "item", ")", ";", "}", "@", "Override", "public", "void", "onError", "(", "Throwable", "throwable", ")", "{", "processor1", ".", "onError", "(", "throwable", ")", ";", "}", "@", "Override", "public", "void", "onComplete", "(", ")", "{", "processor1", ".", "onComplete", "(", ")", ";", "}", "}", ";", "}"], ["public", "static", "<", "T", ">", "Future", "<", "T", ">", "fromPublisher", "(", "final", "Publisher", "<", "T", ">", "pub", ",", "final", "Executor", "ex", ")", "{", "final", "ValueSubscriber", "<", "T", ">", "sub", "=", "ValueSubscriber", ".", "subscriber", "(", ")", ";", "pub", ".", "subscribe", "(", "sub", ")", ";", "return", "sub", ".", "toFutureAsync", "(", "ex", ")", ";", "}"], ["@", "SneakyThrows", "public", "static", "<", "T", ",", "R", ">", "Function", "<", "T", ",", "R", ">", "doAndHandle", "(", "final", "CheckedFunction", "<", "T", ",", "R", ">", "function", ",", "final", "CheckedFunction", "<", "Throwable", ",", "R", ">", "errorHandler", ")", "{", "return", "t", "->", "{", "try", "{", "return", "function", ".", "apply", "(", "t", ")", ";", "}", "catch", "(", "final", "Throwable", "e", ")", "{", "LOGGER", ".", "warn", "(", "e", ".", "getMessage", "(", ")", ",", "e", ")", ";", "try", "{", "return", "errorHandler", ".", "apply", "(", "e", ")", ";", "}", "catch", "(", "final", "Throwable", "ex", ")", "{", "throw", "new", "IllegalArgumentException", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}", "}", ";", "}"]], "similar_docstring": ["Emits the given value if possible and terminates if there was an onComplete or onError while emitting drops the value otherwise .", "Wrap an observable and free a reference counted item if unsubscribed in the meantime .", "Combine processor .", "Construct a Future asynchronously that contains a single value extracted from the supplied reactive - streams Publisher", "Default function function ."], "similar_docstring_tokens": []}
{"repo": "ReactiveX/RxJava", "path": "src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java", "func_name": "FlowableScalarXMap.scalarXMap", "original_string": "public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));\n    }", "language": "java", "code": "public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));\n    }", "code_tokens": ["public", "static", "<", "T", ",", "U", ">", "Flowable", "<", "U", ">", "scalarXMap", "(", "final", "T", "value", ",", "final", "Function", "<", "?", "super", "T", ",", "?", "extends", "Publisher", "<", "?", "extends", "U", ">", ">", "mapper", ")", "{", "return", "RxJavaPlugins", ".", "onAssembly", "(", "new", "ScalarXMapFlowable", "<", "T", ",", "U", ">", "(", "value", ",", "mapper", ")", ")", ";", "}"], "docstring": "Maps a scalar value into a Publisher and emits its values .", "docstring_tokens": ["Maps", "a", "scalar", "value", "into", "a", "Publisher", "and", "emits", "its", "values", "."], "sha": "ac84182aa2bd866b53e01c8e3fe99683b882c60e", "url": "https://github.com/ReactiveX/RxJava/blob/ac84182aa2bd866b53e01c8e3fe99683b882c60e/src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java#L111-L113", "partition": "test", "similar_code": ["public < U > BindResult < U > map ( Function < ? super T , ? extends U > mapper ) { Assert . notNull ( mapper , \"Mapper must not be null\" ) ; return of ( ( this . value != null ) ? mapper . apply ( this . value ) : null ) ; }", "public < U , C extends Collection < U > > C toFlatCollection ( Function < ? super T , ? extends Collection < U > > mapper , Supplier < C > supplier ) { return map ( mapper ) . collect ( supplier , Collection :: addAll , Collection :: addAll ) ; }", "public static < T , K , U > Collector < T , ? , LinkedHashMap < K , U > > toLinkedMap ( Function < ? super T , ? extends K > keyMapper , Function < ? super T , ? extends U > valueMapper , BinaryOperator < U > mergeFunction ) { return Collectors . toMap ( keyMapper , valueMapper , mergeFunction , LinkedHashMap :: new ) ; }", "public static < T , K , U > Collector < T , ? , LinkedHashMap < K , U > > toLinkedMap ( Function < ? super T , ? extends K > keyMapper , Function < ? super T , ? extends U > valueMapper ) { BinaryOperator < U > mergeFunction = throwingMerger ( ) ; return toLinkedMap ( keyMapper , valueMapper , mergeFunction ) ; }", "@ NotNull public static < T , U > ComparatorCompat < T > comparing ( @ NotNull final Function < ? super T , ? extends U > keyExtractor , @ NotNull final Comparator < ? super U > keyComparator ) { Objects . requireNonNull ( keyExtractor ) ; Objects . requireNonNull ( keyComparator ) ; return new ComparatorCompat < T > ( new Comparator < T > ( ) { @ Override public int compare ( T t1 , T t2 ) { final U u1 = keyExtractor . apply ( t1 ) ; final U u2 = keyExtractor . apply ( t2 ) ; return keyComparator . compare ( u1 , u2 ) ; } } ) ; }"], "similar_code_tokens": [["public", "<", "U", ">", "BindResult", "<", "U", ">", "map", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "U", ">", "mapper", ")", "{", "Assert", ".", "notNull", "(", "mapper", ",", "\"Mapper must not be null\"", ")", ";", "return", "of", "(", "(", "this", ".", "value", "!=", "null", ")", "?", "mapper", ".", "apply", "(", "this", ".", "value", ")", ":", "null", ")", ";", "}"], ["public", "<", "U", ",", "C", "extends", "Collection", "<", "U", ">", ">", "C", "toFlatCollection", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "Collection", "<", "U", ">", ">", "mapper", ",", "Supplier", "<", "C", ">", "supplier", ")", "{", "return", "map", "(", "mapper", ")", ".", "collect", "(", "supplier", ",", "Collection", "::", "addAll", ",", "Collection", "::", "addAll", ")", ";", "}"], ["public", "static", "<", "T", ",", "K", ",", "U", ">", "Collector", "<", "T", ",", "?", ",", "LinkedHashMap", "<", "K", ",", "U", ">", ">", "toLinkedMap", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "K", ">", "keyMapper", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "U", ">", "valueMapper", ",", "BinaryOperator", "<", "U", ">", "mergeFunction", ")", "{", "return", "Collectors", ".", "toMap", "(", "keyMapper", ",", "valueMapper", ",", "mergeFunction", ",", "LinkedHashMap", "::", "new", ")", ";", "}"], ["public", "static", "<", "T", ",", "K", ",", "U", ">", "Collector", "<", "T", ",", "?", ",", "LinkedHashMap", "<", "K", ",", "U", ">", ">", "toLinkedMap", "(", "Function", "<", "?", "super", "T", ",", "?", "extends", "K", ">", "keyMapper", ",", "Function", "<", "?", "super", "T", ",", "?", "extends", "U", ">", "valueMapper", ")", "{", "BinaryOperator", "<", "U", ">", "mergeFunction", "=", "throwingMerger", "(", ")", ";", "return", "toLinkedMap", "(", "keyMapper", ",", "valueMapper", ",", "mergeFunction", ")", ";", "}"], ["@", "NotNull", "public", "static", "<", "T", ",", "U", ">", "ComparatorCompat", "<", "T", ">", "comparing", "(", "@", "NotNull", "final", "Function", "<", "?", "super", "T", ",", "?", "extends", "U", ">", "keyExtractor", ",", "@", "NotNull", "final", "Comparator", "<", "?", "super", "U", ">", "keyComparator", ")", "{", "Objects", ".", "requireNonNull", "(", "keyExtractor", ")", ";", "Objects", ".", "requireNonNull", "(", "keyComparator", ")", ";", "return", "new", "ComparatorCompat", "<", "T", ">", "(", "new", "Comparator", "<", "T", ">", "(", ")", "{", "@", "Override", "public", "int", "compare", "(", "T", "t1", ",", "T", "t2", ")", "{", "final", "U", "u1", "=", "keyExtractor", ".", "apply", "(", "t1", ")", ";", "final", "U", "u2", "=", "keyExtractor", ".", "apply", "(", "t2", ")", ";", "return", "keyComparator", ".", "compare", "(", "u1", ",", "u2", ")", ";", "}", "}", ")", ";", "}"]], "similar_docstring": ["Apply the provided mapping function to the bound value or return an updated unbound result if no value has been bound .", "Returns a collection created by provided supplier function which contains all the elements of the collections generated by provided mapper from each element of this stream .", "Collects a stream to a LinkedHashMap .", "Collects a stream to a LinkedHashMap each stream element is expected to produce map entry .", "Returns a comparator that uses a function that extracts a sort key to be compared with the specified comparator ."], "similar_docstring_tokens": []}
