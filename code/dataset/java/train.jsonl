{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/effect/height/Sobel.java", "func_name": "Sobel.apply", "original_string": "@Override\n    public ImageSource apply(ImageSource input) {\n        final int[][] pixelMatrix = new int[3][3];\n\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        int[][] output = new int[h][w];\n\n        for (int j = 1; j < h - 1; j++) {\n            for (int i = 1; i < w - 1; i++) {\n                pixelMatrix[0][0] = input.getR(i - 1, j - 1);\n                pixelMatrix[0][1] = input.getRGB(i - 1, j);\n                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);\n                pixelMatrix[1][0] = input.getRGB(i, j - 1);\n                pixelMatrix[1][2] = input.getRGB(i, j + 1);\n                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);\n                pixelMatrix[2][1] = input.getRGB(i + 1, j);\n                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);\n\n                int edge = (int) convolution(pixelMatrix);\n                int rgb = (edge << 16 | edge << 8 | edge);\n                output[j][i] = rgb;\n            }\n        }\n\n        MatrixSource source = new MatrixSource(output);\n        return source;\n    }", "language": "java", "code": "@Override\n    public ImageSource apply(ImageSource input) {\n        final int[][] pixelMatrix = new int[3][3];\n\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        int[][] output = new int[h][w];\n\n        for (int j = 1; j < h - 1; j++) {\n            for (int i = 1; i < w - 1; i++) {\n                pixelMatrix[0][0] = input.getR(i - 1, j - 1);\n                pixelMatrix[0][1] = input.getRGB(i - 1, j);\n                pixelMatrix[0][2] = input.getRGB(i - 1, j + 1);\n                pixelMatrix[1][0] = input.getRGB(i, j - 1);\n                pixelMatrix[1][2] = input.getRGB(i, j + 1);\n                pixelMatrix[2][0] = input.getRGB(i + 1, j - 1);\n                pixelMatrix[2][1] = input.getRGB(i + 1, j);\n                pixelMatrix[2][2] = input.getRGB(i + 1, j + 1);\n\n                int edge = (int) convolution(pixelMatrix);\n                int rgb = (edge << 16 | edge << 8 | edge);\n                output[j][i] = rgb;\n            }\n        }\n\n        MatrixSource source = new MatrixSource(output);\n        return source;\n    }", "code_tokens": ["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "final", "int", "[", "]", "[", "]", "pixelMatrix", "=", "new", "int", "[", "3", "]", "[", "3", "]", ";", "int", "w", "=", "input", ".", "getWidth", "(", ")", ";", "int", "h", "=", "input", ".", "getHeight", "(", ")", ";", "int", "[", "]", "[", "]", "output", "=", "new", "int", "[", "h", "]", "[", "w", "]", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "h", "-", "1", ";", "j", "++", ")", "{", "for", "(", "int", "i", "=", "1", ";", "i", "<", "w", "-", "1", ";", "i", "++", ")", "{", "pixelMatrix", "[", "0", "]", "[", "0", "]", "=", "input", ".", "getR", "(", "i", "-", "1", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "0", "]", "[", "1", "]", "=", "input", ".", "getRGB", "(", "i", "-", "1", ",", "j", ")", ";", "pixelMatrix", "[", "0", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", "-", "1", ",", "j", "+", "1", ")", ";", "pixelMatrix", "[", "1", "]", "[", "0", "]", "=", "input", ".", "getRGB", "(", "i", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "1", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", ",", "j", "+", "1", ")", ";", "pixelMatrix", "[", "2", "]", "[", "0", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", "-", "1", ")", ";", "pixelMatrix", "[", "2", "]", "[", "1", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", ")", ";", "pixelMatrix", "[", "2", "]", "[", "2", "]", "=", "input", ".", "getRGB", "(", "i", "+", "1", ",", "j", "+", "1", ")", ";", "int", "edge", "=", "(", "int", ")", "convolution", "(", "pixelMatrix", ")", ";", "int", "rgb", "=", "(", "edge", "<<", "16", "|", "edge", "<<", "8", "|", "edge", ")", ";", "output", "[", "j", "]", "[", "i", "]", "=", "rgb", ";", "}", "}", "MatrixSource", "source", "=", "new", "MatrixSource", "(", "output", ")", ";", "return", "source", ";", "}"], "docstring": "Expects a height mat as input", "docstring_tokens": ["Expects", "a", "height", "mat", "as", "input"], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/effect/height/Sobel.java#L19-L47", "partition": "train", "similar_code": ["@ Override public ImageSource apply ( ImageSource input ) { int w = input . getWidth ( ) ; int h = input . getHeight ( ) ; MatrixSource output = new MatrixSource ( input ) ; Vector3 n = new Vector3 ( 0 , 0 , 1 ) ; for ( int y = 0 ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { if ( x < border || x == w - border || y < border || y == h - border ) { output . setRGB ( x , y , VectorHelper . Z_NORMAL ) ; continue ; } float s0 = input . getR ( x - 1 , y + 1 ) ; float s1 = input . getR ( x , y + 1 ) ; float s2 = input . getR ( x + 1 , y + 1 ) ; float s3 = input . getR ( x - 1 , y ) ; float s5 = input . getR ( x + 1 , y ) ; float s6 = input . getR ( x - 1 , y - 1 ) ; float s7 = input . getR ( x , y - 1 ) ; float s8 = input . getR ( x + 1 , y - 1 ) ; float nx = - ( s2 - s0 + 2 * ( s5 - s3 ) + s8 - s6 ) ; float ny = - ( s6 - s0 + 2 * ( s7 - s1 ) + s8 - s2 ) ; n . set ( nx , ny , scale ) ; n . nor ( ) ; int rgb = VectorHelper . vectorToColor ( n ) ; output . setRGB ( x , y , rgb ) ; } } return new MatrixSource ( output ) ; }", "public static void process ( GrayI input , GrayI output , int radius , int [ ] storage ) { int w = 2 * radius + 1 ; if ( storage == null ) { storage = new int [ w * w ] ; } else if ( storage . length < w * w ) { throw new IllegalArgumentException ( \"'storage' must be at least of length \" + ( w * w ) ) ; } for ( int y = 0 ; y < input . height ; y ++ ) { int minI = y - radius ; int maxI = y + radius + 1 ; // bound the y-axius inside the image if ( minI < 0 ) minI = 0 ; if ( maxI > input . height ) maxI = input . height ; for ( int x = 0 ; x < input . width ; x ++ ) { int minJ = x - radius ; int maxJ = x + radius + 1 ; // bound the x-axis to be inside the image if ( minJ < 0 ) minJ = 0 ; if ( maxJ > input . width ) maxJ = input . width ; int index = 0 ; for ( int i = minI ; i < maxI ; i ++ ) { for ( int j = minJ ; j < maxJ ; j ++ ) { storage [ index ++ ] = input . get ( j , i ) ; } } // use quick select to avoid sorting the whole list int median = QuickSelect . select ( storage , index / 2 , index ) ; output . set ( x , y , median ) ; } } }", "@ Override public ImageSource apply ( ImageSource input ) { int w = input . getWidth ( ) ; int h = input . getHeight ( ) ; MatrixSource output = new MatrixSource ( w , h ) ; Vector3 s = new Vector3 ( 1 , 0 , 0 ) ; Vector3 t = new Vector3 ( 0 , 1 , 0 ) ; for ( int y = 0 ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { if ( x < border || x == w - border || y < border || y == h - border ) { output . setRGB ( x , y , VectorHelper . Z_NORMAL ) ; continue ; } float dh = input . getR ( x + 1 , y ) - input . getR ( x - 1 , y ) ; float dv = input . getR ( x , y + 1 ) - input . getR ( x , y - 1 ) ; s . set ( scale , 0 , dh ) ; t . set ( 0 , scale , dv ) ; Vector3 cross = s . crs ( t ) . nor ( ) ; int rgb = VectorHelper . vectorToColor ( cross ) ; output . setRGB ( x , y , rgb ) ; } } return new MatrixSource ( output ) ; }", "private static double similarity ( BufferedImage var , BufferedImage cont ) { double [ ] varArr = new double [ var . getWidth ( ) * var . getHeight ( ) * 3 ] ; double [ ] contArr = new double [ cont . getWidth ( ) * cont . getHeight ( ) * 3 ] ; if ( varArr . length != contArr . length ) throw new IllegalStateException ( \"The pictures are different sizes!\" ) ; //unroll pixels for ( int i = 0 ; i < var . getHeight ( ) ; i ++ ) { for ( int j = 0 ; j < var . getWidth ( ) ; j ++ ) { varArr [ i * var . getWidth ( ) + j + 0 ] = new Color ( var . getRGB ( j , i ) ) . getRed ( ) ; contArr [ i * cont . getWidth ( ) + j + 0 ] = new Color ( cont . getRGB ( j , i ) ) . getRed ( ) ; varArr [ i * var . getWidth ( ) + j + 1 ] = new Color ( var . getRGB ( j , i ) ) . getGreen ( ) ; contArr [ i * cont . getWidth ( ) + j + 1 ] = new Color ( cont . getRGB ( j , i ) ) . getGreen ( ) ; varArr [ i * var . getWidth ( ) + j + 2 ] = new Color ( var . getRGB ( j , i ) ) . getBlue ( ) ; contArr [ i * cont . getWidth ( ) + j + 2 ] = new Color ( cont . getRGB ( j , i ) ) . getBlue ( ) ; } } double mins = 0 ; double maxs = 0 ; for ( int i = 0 ; i != varArr . length ; i ++ ) { if ( varArr [ i ] > contArr [ i ] ) { mins += contArr [ i ] ; maxs += varArr [ i ] ; } else { mins += varArr [ i ] ; maxs += contArr [ i ] ; } } return mins / maxs ; }", "private static int getTrimmedWidth ( BufferedImage img ) { int height = img . getHeight ( ) ; int width = img . getWidth ( ) ; int trimmedWidth = 0 ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = width - 1 ; j >= 0 ; j -- ) { if ( img . getRGB ( j , i ) != Color . WHITE . getRGB ( ) && j > trimmedWidth ) { trimmedWidth = j ; break ; } } } return trimmedWidth ; }"], "similar_code_tokens": [["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "int", "w", "=", "input", ".", "getWidth", "(", ")", ";", "int", "h", "=", "input", ".", "getHeight", "(", ")", ";", "MatrixSource", "output", "=", "new", "MatrixSource", "(", "input", ")", ";", "Vector3", "n", "=", "new", "Vector3", "(", "0", ",", "0", ",", "1", ")", ";", "for", "(", "int", "y", "=", "0", ";", "y", "<", "h", ";", "y", "++", ")", "{", "for", "(", "int", "x", "=", "0", ";", "x", "<", "w", ";", "x", "++", ")", "{", "if", "(", "x", "<", "border", "||", "x", "==", "w", "-", "border", "||", "y", "<", "border", "||", "y", "==", "h", "-", "border", ")", "{", "output", ".", "setRGB", "(", "x", ",", "y", ",", "VectorHelper", ".", "Z_NORMAL", ")", ";", "continue", ";", "}", "float", "s0", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", "+", "1", ")", ";", "float", "s1", "=", "input", ".", "getR", "(", "x", ",", "y", "+", "1", ")", ";", "float", "s2", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", "+", "1", ")", ";", "float", "s3", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", ")", ";", "float", "s5", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", ")", ";", "float", "s6", "=", "input", ".", "getR", "(", "x", "-", "1", ",", "y", "-", "1", ")", ";", "float", "s7", "=", "input", ".", "getR", "(", "x", ",", "y", "-", "1", ")", ";", "float", "s8", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", "-", "1", ")", ";", "float", "nx", "=", "-", "(", "s2", "-", "s0", "+", "2", "*", "(", "s5", "-", "s3", ")", "+", "s8", "-", "s6", ")", ";", "float", "ny", "=", "-", "(", "s6", "-", "s0", "+", "2", "*", "(", "s7", "-", "s1", ")", "+", "s8", "-", "s2", ")", ";", "n", ".", "set", "(", "nx", ",", "ny", ",", "scale", ")", ";", "n", ".", "nor", "(", ")", ";", "int", "rgb", "=", "VectorHelper", ".", "vectorToColor", "(", "n", ")", ";", "output", ".", "setRGB", "(", "x", ",", "y", ",", "rgb", ")", ";", "}", "}", "return", "new", "MatrixSource", "(", "output", ")", ";", "}"], ["public", "static", "void", "process", "(", "GrayI", "input", ",", "GrayI", "output", ",", "int", "radius", ",", "int", "[", "]", "storage", ")", "{", "int", "w", "=", "2", "*", "radius", "+", "1", ";", "if", "(", "storage", "==", "null", ")", "{", "storage", "=", "new", "int", "[", "w", "*", "w", "]", ";", "}", "else", "if", "(", "storage", ".", "length", "<", "w", "*", "w", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"'storage' must be at least of length \"", "+", "(", "w", "*", "w", ")", ")", ";", "}", "for", "(", "int", "y", "=", "0", ";", "y", "<", "input", ".", "height", ";", "y", "++", ")", "{", "int", "minI", "=", "y", "-", "radius", ";", "int", "maxI", "=", "y", "+", "radius", "+", "1", ";", "// bound the y-axius inside the image", "if", "(", "minI", "<", "0", ")", "minI", "=", "0", ";", "if", "(", "maxI", ">", "input", ".", "height", ")", "maxI", "=", "input", ".", "height", ";", "for", "(", "int", "x", "=", "0", ";", "x", "<", "input", ".", "width", ";", "x", "++", ")", "{", "int", "minJ", "=", "x", "-", "radius", ";", "int", "maxJ", "=", "x", "+", "radius", "+", "1", ";", "// bound the x-axis to be inside the image", "if", "(", "minJ", "<", "0", ")", "minJ", "=", "0", ";", "if", "(", "maxJ", ">", "input", ".", "width", ")", "maxJ", "=", "input", ".", "width", ";", "int", "index", "=", "0", ";", "for", "(", "int", "i", "=", "minI", ";", "i", "<", "maxI", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "minJ", ";", "j", "<", "maxJ", ";", "j", "++", ")", "{", "storage", "[", "index", "++", "]", "=", "input", ".", "get", "(", "j", ",", "i", ")", ";", "}", "}", "// use quick select to avoid sorting the whole list", "int", "median", "=", "QuickSelect", ".", "select", "(", "storage", ",", "index", "/", "2", ",", "index", ")", ";", "output", ".", "set", "(", "x", ",", "y", ",", "median", ")", ";", "}", "}", "}"], ["@", "Override", "public", "ImageSource", "apply", "(", "ImageSource", "input", ")", "{", "int", "w", "=", "input", ".", "getWidth", "(", ")", ";", "int", "h", "=", "input", ".", "getHeight", "(", ")", ";", "MatrixSource", "output", "=", "new", "MatrixSource", "(", "w", ",", "h", ")", ";", "Vector3", "s", "=", "new", "Vector3", "(", "1", ",", "0", ",", "0", ")", ";", "Vector3", "t", "=", "new", "Vector3", "(", "0", ",", "1", ",", "0", ")", ";", "for", "(", "int", "y", "=", "0", ";", "y", "<", "h", ";", "y", "++", ")", "{", "for", "(", "int", "x", "=", "0", ";", "x", "<", "w", ";", "x", "++", ")", "{", "if", "(", "x", "<", "border", "||", "x", "==", "w", "-", "border", "||", "y", "<", "border", "||", "y", "==", "h", "-", "border", ")", "{", "output", ".", "setRGB", "(", "x", ",", "y", ",", "VectorHelper", ".", "Z_NORMAL", ")", ";", "continue", ";", "}", "float", "dh", "=", "input", ".", "getR", "(", "x", "+", "1", ",", "y", ")", "-", "input", ".", "getR", "(", "x", "-", "1", ",", "y", ")", ";", "float", "dv", "=", "input", ".", "getR", "(", "x", ",", "y", "+", "1", ")", "-", "input", ".", "getR", "(", "x", ",", "y", "-", "1", ")", ";", "s", ".", "set", "(", "scale", ",", "0", ",", "dh", ")", ";", "t", ".", "set", "(", "0", ",", "scale", ",", "dv", ")", ";", "Vector3", "cross", "=", "s", ".", "crs", "(", "t", ")", ".", "nor", "(", ")", ";", "int", "rgb", "=", "VectorHelper", ".", "vectorToColor", "(", "cross", ")", ";", "output", ".", "setRGB", "(", "x", ",", "y", ",", "rgb", ")", ";", "}", "}", "return", "new", "MatrixSource", "(", "output", ")", ";", "}"], ["private", "static", "double", "similarity", "(", "BufferedImage", "var", ",", "BufferedImage", "cont", ")", "{", "double", "[", "]", "varArr", "=", "new", "double", "[", "var", ".", "getWidth", "(", ")", "*", "var", ".", "getHeight", "(", ")", "*", "3", "]", ";", "double", "[", "]", "contArr", "=", "new", "double", "[", "cont", ".", "getWidth", "(", ")", "*", "cont", ".", "getHeight", "(", ")", "*", "3", "]", ";", "if", "(", "varArr", ".", "length", "!=", "contArr", ".", "length", ")", "throw", "new", "IllegalStateException", "(", "\"The pictures are different sizes!\"", ")", ";", "//unroll pixels", "for", "(", "int", "i", "=", "0", ";", "i", "<", "var", ".", "getHeight", "(", ")", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "var", ".", "getWidth", "(", ")", ";", "j", "++", ")", "{", "varArr", "[", "i", "*", "var", ".", "getWidth", "(", ")", "+", "j", "+", "0", "]", "=", "new", "Color", "(", "var", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getRed", "(", ")", ";", "contArr", "[", "i", "*", "cont", ".", "getWidth", "(", ")", "+", "j", "+", "0", "]", "=", "new", "Color", "(", "cont", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getRed", "(", ")", ";", "varArr", "[", "i", "*", "var", ".", "getWidth", "(", ")", "+", "j", "+", "1", "]", "=", "new", "Color", "(", "var", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getGreen", "(", ")", ";", "contArr", "[", "i", "*", "cont", ".", "getWidth", "(", ")", "+", "j", "+", "1", "]", "=", "new", "Color", "(", "cont", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getGreen", "(", ")", ";", "varArr", "[", "i", "*", "var", ".", "getWidth", "(", ")", "+", "j", "+", "2", "]", "=", "new", "Color", "(", "var", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getBlue", "(", ")", ";", "contArr", "[", "i", "*", "cont", ".", "getWidth", "(", ")", "+", "j", "+", "2", "]", "=", "new", "Color", "(", "cont", ".", "getRGB", "(", "j", ",", "i", ")", ")", ".", "getBlue", "(", ")", ";", "}", "}", "double", "mins", "=", "0", ";", "double", "maxs", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "!=", "varArr", ".", "length", ";", "i", "++", ")", "{", "if", "(", "varArr", "[", "i", "]", ">", "contArr", "[", "i", "]", ")", "{", "mins", "+=", "contArr", "[", "i", "]", ";", "maxs", "+=", "varArr", "[", "i", "]", ";", "}", "else", "{", "mins", "+=", "varArr", "[", "i", "]", ";", "maxs", "+=", "contArr", "[", "i", "]", ";", "}", "}", "return", "mins", "/", "maxs", ";", "}"], ["private", "static", "int", "getTrimmedWidth", "(", "BufferedImage", "img", ")", "{", "int", "height", "=", "img", ".", "getHeight", "(", ")", ";", "int", "width", "=", "img", ".", "getWidth", "(", ")", ";", "int", "trimmedWidth", "=", "0", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "height", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "width", "-", "1", ";", "j", ">=", "0", ";", "j", "--", ")", "{", "if", "(", "img", ".", "getRGB", "(", "j", ",", "i", ")", "!=", "Color", ".", "WHITE", ".", "getRGB", "(", ")", "&&", "j", ">", "trimmedWidth", ")", "{", "trimmedWidth", "=", "j", ";", "break", ";", "}", "}", "}", "return", "trimmedWidth", ";", "}"]], "similar_docstring": ["Sobel method to generate bump map from a height map", "Performs a median filter .", "Simple method to generate bump map from a height map", "Returns a double between 0 and 1 . 0", "Get the last non - white X point"], "similar_docstring_tokens": []}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/providers/EventStackImpl.java", "func_name": "EventStackImpl.popEvent", "original_string": "public <L extends Listener> void popEvent(Event<?, L> expected) {\n        synchronized (this.stack) {\n            final Event<?, ?> actual = this.stack.pop();\n            if (actual != expected) {\n                throw new IllegalStateException(String.format(\n                        \"Unbalanced pop: expected '%s' but encountered '%s'\",\n                        expected.getListenerClass(), actual));\n            }\n        }\n    }", "language": "java", "code": "public <L extends Listener> void popEvent(Event<?, L> expected) {\n        synchronized (this.stack) {\n            final Event<?, ?> actual = this.stack.pop();\n            if (actual != expected) {\n                throw new IllegalStateException(String.format(\n                        \"Unbalanced pop: expected '%s' but encountered '%s'\",\n                        expected.getListenerClass(), actual));\n            }\n        }\n    }", "code_tokens": ["public", "<", "L", "extends", "Listener", ">", "void", "popEvent", "(", "Event", "<", "?", ",", "L", ">", "expected", ")", "{", "synchronized", "(", "this", ".", "stack", ")", "{", "final", "Event", "<", "?", ",", "?", ">", "actual", "=", "this", ".", "stack", ".", "pop", "(", ")", ";", "if", "(", "actual", "!=", "expected", ")", "{", "throw", "new", "IllegalStateException", "(", "String", ".", "format", "(", "\"Unbalanced pop: expected '%s' but encountered '%s'\"", ",", "expected", ".", "getListenerClass", "(", ")", ",", "actual", ")", ")", ";", "}", "}", "}"], "docstring": "Pops the top event off the current event stack . This action has to be performed immediately after the event has been dispatched to all listeners .", "docstring_tokens": ["Pops", "the", "top", "event", "off", "the", "current", "event", "stack", ".", "This", "action", "has", "to", "be", "performed", "immediately", "after", "the", "event", "has", "been", "dispatched", "to", "all", "listeners", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/providers/EventStackImpl.java#L114-L123", "partition": "train", "similar_code": ["static public void assertEquals ( String message , String expected , String actual ) { if ( expected == null && actual == null ) { return ; } if ( expected != null && expected . equals ( actual ) ) { return ; } String cleanMessage = message == null ? \"\" : message ; throw new ComparisonFailure ( cleanMessage , expected , actual ) ; }", "private void checkFieldType ( int field , Type ... expected ) { Type actual = getType ( field ) ; for ( Type type : expected ) { if ( actual . equals ( type ) ) { return ; } } throw new IllegalArgumentException ( format ( \"Expected field %s to be a type of %s but is %s\" , field , StringUtils . join ( expected , \",\" ) , actual ) ) ; }", "public static void containsAll ( final Path expected , final Path actual ) throws IOException { final Assertion < Path > exists = existsIn ( expected , actual ) ; if ( Files . exists ( expected ) ) { walkFileTree ( expected , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( final Path file , final BasicFileAttributes attrs ) throws IOException { assertThat ( file , exists ) ; return super . visitFile ( file , attrs ) ; } } ) ; } }", "public boolean matches ( String prefix , Object actual , Object expected , JSONCompareResult result ) throws ValueMatcherException { if ( comparator instanceof LocationAwareValueMatcher ) { return ( ( LocationAwareValueMatcher < Object > ) comparator ) . equal ( prefix , actual , expected , result ) ; } return comparator . equal ( actual , expected ) ; }", "@ VisibleForTesting static ImmutableList < Fact > formatExpectedAndActual ( String expected , String actual ) { ImmutableList < Fact > result ; // TODO(cpovirk): Call attention to differences in trailing whitespace. // TODO(cpovirk): And changes in the *kind* of whitespace characters in the middle of the line. result = Platform . makeDiff ( expected , actual ) ; if ( result != null ) { return result ; } result = removeCommonPrefixAndSuffix ( expected , actual ) ; if ( result != null ) { return result ; } return ImmutableList . of ( fact ( \"expected\" , expected ) , fact ( \"but was\" , actual ) ) ; }"], "similar_code_tokens": [["static", "public", "void", "assertEquals", "(", "String", "message", ",", "String", "expected", ",", "String", "actual", ")", "{", "if", "(", "expected", "==", "null", "&&", "actual", "==", "null", ")", "{", "return", ";", "}", "if", "(", "expected", "!=", "null", "&&", "expected", ".", "equals", "(", "actual", ")", ")", "{", "return", ";", "}", "String", "cleanMessage", "=", "message", "==", "null", "?", "\"\"", ":", "message", ";", "throw", "new", "ComparisonFailure", "(", "cleanMessage", ",", "expected", ",", "actual", ")", ";", "}"], ["private", "void", "checkFieldType", "(", "int", "field", ",", "Type", "...", "expected", ")", "{", "Type", "actual", "=", "getType", "(", "field", ")", ";", "for", "(", "Type", "type", ":", "expected", ")", "{", "if", "(", "actual", ".", "equals", "(", "type", ")", ")", "{", "return", ";", "}", "}", "throw", "new", "IllegalArgumentException", "(", "format", "(", "\"Expected field %s to be a type of %s but is %s\"", ",", "field", ",", "StringUtils", ".", "join", "(", "expected", ",", "\",\"", ")", ",", "actual", ")", ")", ";", "}"], ["public", "static", "void", "containsAll", "(", "final", "Path", "expected", ",", "final", "Path", "actual", ")", "throws", "IOException", "{", "final", "Assertion", "<", "Path", ">", "exists", "=", "existsIn", "(", "expected", ",", "actual", ")", ";", "if", "(", "Files", ".", "exists", "(", "expected", ")", ")", "{", "walkFileTree", "(", "expected", ",", "new", "SimpleFileVisitor", "<", "Path", ">", "(", ")", "{", "@", "Override", "public", "FileVisitResult", "visitFile", "(", "final", "Path", "file", ",", "final", "BasicFileAttributes", "attrs", ")", "throws", "IOException", "{", "assertThat", "(", "file", ",", "exists", ")", ";", "return", "super", ".", "visitFile", "(", "file", ",", "attrs", ")", ";", "}", "}", ")", ";", "}", "}"], ["public", "boolean", "matches", "(", "String", "prefix", ",", "Object", "actual", ",", "Object", "expected", ",", "JSONCompareResult", "result", ")", "throws", "ValueMatcherException", "{", "if", "(", "comparator", "instanceof", "LocationAwareValueMatcher", ")", "{", "return", "(", "(", "LocationAwareValueMatcher", "<", "Object", ">", ")", "comparator", ")", ".", "equal", "(", "prefix", ",", "actual", ",", "expected", ",", "result", ")", ";", "}", "return", "comparator", ".", "equal", "(", "actual", ",", "expected", ")", ";", "}"], ["@", "VisibleForTesting", "static", "ImmutableList", "<", "Fact", ">", "formatExpectedAndActual", "(", "String", "expected", ",", "String", "actual", ")", "{", "ImmutableList", "<", "Fact", ">", "result", ";", "// TODO(cpovirk): Call attention to differences in trailing whitespace.", "// TODO(cpovirk): And changes in the *kind* of whitespace characters in the middle of the line.", "result", "=", "Platform", ".", "makeDiff", "(", "expected", ",", "actual", ")", ";", "if", "(", "result", "!=", "null", ")", "{", "return", "result", ";", "}", "result", "=", "removeCommonPrefixAndSuffix", "(", "expected", ",", "actual", ")", ";", "if", "(", "result", "!=", "null", ")", "{", "return", "result", ";", "}", "return", "ImmutableList", ".", "of", "(", "fact", "(", "\"expected\"", ",", "expected", ")", ",", "fact", "(", "\"but was\"", ",", "actual", ")", ")", ";", "}"]], "similar_docstring": ["Asserts that two Strings are equal .", "Checks that the given field is one of the provided types .", "Asserts that every file that exists relative to expected also exists relative to actual .", "Return true if actual value matches expected value using this Customization s comparator . The equal method used for comparison depends on type of comparator .", "Returns one or more facts describing the difference between the given expected and actual values ."], "similar_docstring_tokens": []}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java", "func_name": "AbstractSynchronizedListenerSource.modify", "original_string": "protected void modify(Transaction t) {\n        try {\n            this.lock.writeLock().lock();\n            t.perform();\n        } finally {\n            this.lock.writeLock().unlock();\n        }\n    }", "language": "java", "code": "protected void modify(Transaction t) {\n        try {\n            this.lock.writeLock().lock();\n            t.perform();\n        } finally {\n            this.lock.writeLock().unlock();\n        }\n    }", "code_tokens": ["protected", "void", "modify", "(", "Transaction", "t", ")", "{", "try", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "t", ".", "perform", "(", ")", ";", "}", "finally", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Executes the given transaction within the context of a write lock .", "docstring_tokens": ["Executes", "the", "given", "transaction", "within", "the", "context", "of", "a", "write", "lock", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java#L48-L55", "partition": "train", "similar_code": ["public void set ( T value ) { try { lock . writeLock ( ) . lock ( ) ; this . value = value ; } finally { lock . writeLock ( ) . unlock ( ) ; } }", "public void setValue ( T value ) { try { lock . writeLock ( ) . lock ( ) ; this . value = value ; } finally { lock . writeLock ( ) . unlock ( ) ; } }", "protected void unsetBaseInstance ( ServiceReference < ContextService > ref ) { lock . writeLock ( ) . lock ( ) ; try { threadContextConfigurations = null ; } finally { lock . writeLock ( ) . unlock ( ) ; } }", "public void put ( K key , V value ) { this . lock . writeLock ( ) . lock ( ) ; try { this . map . put ( key , new SoftReference <> ( value ) ) ; } finally { this . lock . writeLock ( ) . unlock ( ) ; } }", "public void reset ( ) { Lock lock = this . lock . writeLock ( ) ; lock . lock ( ) ; try { doReset ( ) ; } finally { lock . unlock ( ) ; } }"], "similar_code_tokens": [["public", "void", "set", "(", "T", "value", ")", "{", "try", "{", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "this", ".", "value", "=", "value", ";", "}", "finally", "{", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["public", "void", "setValue", "(", "T", "value", ")", "{", "try", "{", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "this", ".", "value", "=", "value", ";", "}", "finally", "{", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["protected", "void", "unsetBaseInstance", "(", "ServiceReference", "<", "ContextService", ">", "ref", ")", "{", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "threadContextConfigurations", "=", "null", ";", "}", "finally", "{", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["public", "void", "put", "(", "K", "key", ",", "V", "value", ")", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "this", ".", "map", ".", "put", "(", "key", ",", "new", "SoftReference", "<>", "(", "value", ")", ")", ";", "}", "finally", "{", "this", ".", "lock", ".", "writeLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["public", "void", "reset", "(", ")", "{", "Lock", "lock", "=", "this", ".", "lock", ".", "writeLock", "(", ")", ";", "lock", ".", "lock", "(", ")", ";", "try", "{", "doReset", "(", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}"]], "similar_docstring": ["This method assigns new value", "Change the value that is returned by this generator .", "Declarative Services method for unsetting the service reference to the base contextService instance .", "Associate passed key to passed value .", "Reset the statistics in this object and clear out any stored information ."], "similar_docstring_tokens": []}
{"repo": "skuzzle/jeve", "path": "jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java", "func_name": "AbstractSynchronizedListenerSource.read", "original_string": "protected <E> E read(Supplier<E> sup) {\n        try {\n            this.lock.readLock().lock();\n            return sup.get();\n        } finally {\n            this.lock.readLock().unlock();\n        }\n    }", "language": "java", "code": "protected <E> E read(Supplier<E> sup) {\n        try {\n            this.lock.readLock().lock();\n            return sup.get();\n        } finally {\n            this.lock.readLock().unlock();\n        }\n    }", "code_tokens": ["protected", "<", "E", ">", "E", "read", "(", "Supplier", "<", "E", ">", "sup", ")", "{", "try", "{", "this", ".", "lock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "return", "sup", ".", "get", "(", ")", ";", "}", "finally", "{", "this", ".", "lock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], "docstring": "Executes the given supplier within the context of a read lock .", "docstring_tokens": ["Executes", "the", "given", "supplier", "within", "the", "context", "of", "a", "read", "lock", "."], "sha": "42cc18947c9c8596c34410336e4e375e9fcd7c47", "url": "https://github.com/skuzzle/jeve/blob/42cc18947c9c8596c34410336e4e375e9fcd7c47/jeve/src/main/java/de/skuzzle/jeve/stores/AbstractSynchronizedListenerSource.java#L64-L71", "partition": "train", "similar_code": ["public E get ( int index ) { lock . readLock ( ) . lock ( ) ; try { if ( index >= size ) return null ; index ++ ; int c = 0 ; Node < E > finger = head ; for ( int i = maxHeight - 1 ; i >= 0 ; i -- ) { while ( c + finger . size [ i ] <= index ) { c += finger . size [ i ] ; finger = finger . next ( i ) ; } } assert c == index ; return finger . value ; } finally { lock . readLock ( ) . unlock ( ) ; } }", "public boolean hasDependent ( T element ) { lock . readLock ( ) . lock ( ) ; try { Set < T > ts = this . incomingEdges . get ( element ) ; return ts != null && ts . size ( ) > 0 ; } finally { lock . readLock ( ) . unlock ( ) ; } }", "protected Collection < JcrRepository > repositories ( ) { if ( this . state == State . RUNNING ) { final Lock lock = this . lock . readLock ( ) ; try { lock . lock ( ) ; return new ArrayList < JcrRepository > ( repositories . values ( ) ) ; } finally { lock . unlock ( ) ; } } return Collections . emptyList ( ) ; }", "public Set < T > getDependents ( T element ) { lock . readLock ( ) . lock ( ) ; try { Set < T > dependants = this . incomingEdges . get ( element ) ; if ( dependants == null || dependants . isEmpty ( ) ) { return new HashSet <> ( ) ; } return Collections . unmodifiableSet ( this . incomingEdges . get ( element ) ) ; } finally { lock . readLock ( ) . unlock ( ) ; } }", "public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = 0 ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }"], "similar_code_tokens": [["public", "E", "get", "(", "int", "index", ")", "{", "lock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "if", "(", "index", ">=", "size", ")", "return", "null", ";", "index", "++", ";", "int", "c", "=", "0", ";", "Node", "<", "E", ">", "finger", "=", "head", ";", "for", "(", "int", "i", "=", "maxHeight", "-", "1", ";", "i", ">=", "0", ";", "i", "--", ")", "{", "while", "(", "c", "+", "finger", ".", "size", "[", "i", "]", "<=", "index", ")", "{", "c", "+=", "finger", ".", "size", "[", "i", "]", ";", "finger", "=", "finger", ".", "next", "(", "i", ")", ";", "}", "}", "assert", "c", "==", "index", ";", "return", "finger", ".", "value", ";", "}", "finally", "{", "lock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["public", "boolean", "hasDependent", "(", "T", "element", ")", "{", "lock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "Set", "<", "T", ">", "ts", "=", "this", ".", "incomingEdges", ".", "get", "(", "element", ")", ";", "return", "ts", "!=", "null", "&&", "ts", ".", "size", "(", ")", ">", "0", ";", "}", "finally", "{", "lock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["protected", "Collection", "<", "JcrRepository", ">", "repositories", "(", ")", "{", "if", "(", "this", ".", "state", "==", "State", ".", "RUNNING", ")", "{", "final", "Lock", "lock", "=", "this", ".", "lock", ".", "readLock", "(", ")", ";", "try", "{", "lock", ".", "lock", "(", ")", ";", "return", "new", "ArrayList", "<", "JcrRepository", ">", "(", "repositories", ".", "values", "(", ")", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}", "return", "Collections", ".", "emptyList", "(", ")", ";", "}"], ["public", "Set", "<", "T", ">", "getDependents", "(", "T", "element", ")", "{", "lock", ".", "readLock", "(", ")", ".", "lock", "(", ")", ";", "try", "{", "Set", "<", "T", ">", "dependants", "=", "this", ".", "incomingEdges", ".", "get", "(", "element", ")", ";", "if", "(", "dependants", "==", "null", "||", "dependants", ".", "isEmpty", "(", ")", ")", "{", "return", "new", "HashSet", "<>", "(", ")", ";", "}", "return", "Collections", ".", "unmodifiableSet", "(", "this", ".", "incomingEdges", ".", "get", "(", "element", ")", ")", ";", "}", "finally", "{", "lock", ".", "readLock", "(", ")", ".", "unlock", "(", ")", ";", "}", "}"], ["public", "void", "clear", "(", ")", "{", "final", "ReentrantLock", "lock", "=", "this", ".", "lock", ";", "lock", ".", "lock", "(", ")", ";", "try", "{", "for", "(", "Node", "<", "E", ">", "f", "=", "first", ";", "f", "!=", "null", ";", ")", "{", "f", ".", "item", "=", "null", ";", "Node", "<", "E", ">", "n", "=", "f", ".", "next", ";", "f", ".", "prev", "=", "null", ";", "f", ".", "next", "=", "null", ";", "f", "=", "n", ";", "}", "first", "=", "last", "=", "null", ";", "count", "=", "0", ";", "notFull", ".", "signalAll", "(", ")", ";", "}", "finally", "{", "lock", ".", "unlock", "(", ")", ";", "}", "}"]], "similar_docstring": ["retrieve the item at the provided index or return null if the index is past the end of the list", "Check if an element is depended on", "Returns a copy of the repositories . Note that when returned not all repositories may be active .", "Return the dependents", "Atomically removes all of the elements from this deque . The deque will be empty after this call returns ."], "similar_docstring_tokens": []}
{"repo": "vnesek/nmote-iim4j", "path": "src/main/java/com/nmote/iim4j/stream/SubIIMInputStream.java", "func_name": "SubIIMInputStream.setOffsetAndLength", "original_string": "protected void setOffsetAndLength(long offset, int length) throws IOException {\r\n\t\tthis.offset = offset;\r\n\t\tthis.length = length;\r\n\t\tthis.position = 0;\r\n\r\n\t\tif (subStream.position() != offset) {\r\n\t\t\tsubStream.seek(offset);\r\n\t\t}\r\n\t}", "language": "java", "code": "protected void setOffsetAndLength(long offset, int length) throws IOException {\r\n\t\tthis.offset = offset;\r\n\t\tthis.length = length;\r\n\t\tthis.position = 0;\r\n\r\n\t\tif (subStream.position() != offset) {\r\n\t\t\tsubStream.seek(offset);\r\n\t\t}\r\n\t}", "code_tokens": ["protected", "void", "setOffsetAndLength", "(", "long", "offset", ",", "int", "length", ")", "throws", "IOException", "{", "this", ".", "offset", "=", "offset", ";", "this", ".", "length", "=", "length", ";", "this", ".", "position", "=", "0", ";", "if", "(", "subStream", ".", "position", "(", ")", "!=", "offset", ")", "{", "subStream", ".", "seek", "(", "offset", ")", ";", "}", "}"], "docstring": "This should be called from a subclass constructor if offset or length are unknown at a time when SubIIMInputStream constructor is called . This method shouldn t be called more than once .", "docstring_tokens": ["This", "should", "be", "called", "from", "a", "subclass", "constructor", "if", "offset", "or", "length", "are", "unknown", "at", "a", "time", "when", "SubIIMInputStream", "constructor", "is", "called", ".", "This", "method", "shouldn", "t", "be", "called", "more", "than", "once", "."], "sha": "ec55b02fc644cd722e93051ac0bdb96b00cb42a8", "url": "https://github.com/vnesek/nmote-iim4j/blob/ec55b02fc644cd722e93051ac0bdb96b00cb42a8/src/main/java/com/nmote/iim4j/stream/SubIIMInputStream.java#L64-L72", "partition": "train", "similar_code": ["public long seekToNextRecord ( LogRecordSerializer formatter ) throws IOException { long fileSize = reader . length ( ) ; long position = reader . getFilePointer ( ) ; int location ; int len = 0 ; int offset = 0 ; byte [ ] buffer = new byte [ 2048 ] ; do { if ( offset > 0 ) { position += len - offset ; // keep the last eyeCatcherSize-1 bytes of the buffer. for ( int i = 0 ; i < offset ; i ++ ) { buffer [ i ] = buffer [ buffer . length - offset + i ] ; } } if ( position + formatter . getEyeCatcherSize ( ) > fileSize ) { throw new IOException ( \"No eyeCatcher found in the rest of the file.\" ) ; } if ( position + buffer . length <= fileSize ) { len = buffer . length ; } else { len = ( int ) ( fileSize - position ) ; } reader . readFully ( buffer , offset , len - offset ) ; if ( offset == 0 ) { offset = formatter . getEyeCatcherSize ( ) - 1 ; } } while ( ( location = formatter . findFirstEyeCatcher ( buffer , 0 , len ) ) < 0 ) ; position += location - 4 ; reader . seek ( position ) ; return position ; }", "public long seekToPrevRecord ( LogRecordSerializer formatter ) throws IOException { long position = reader . getFilePointer ( ) ; byte [ ] buffer = new byte [ 2048 ] ; int location ; int offset = 0 ; int len = 0 ; do { if ( position <= formatter . getEyeCatcherSize ( ) + 3 ) { throw new IOException ( \"No eyeCatcher found in the rest of the file.\" ) ; } if ( position > buffer . length ) { len = buffer . length ; } else { len = ( int ) position ; } position -= len ; if ( offset > 0 ) { // keep the first eyeCatcherSize-1 bytes of the buffer. for ( int i = 0 ; i < offset ; i ++ ) { buffer [ len - offset + i ] = buffer [ i ] ; } } reader . seek ( position ) ; reader . readFully ( buffer , 0 , len - offset ) ; if ( offset == 0 ) { offset = formatter . getEyeCatcherSize ( ) - 1 ; } } while ( ( location = formatter . findLastEyeCatcher ( buffer , 0 , len ) ) < 0 ) ; position += location - 4 ; reader . seek ( position ) ; return position ; }", "public void writeRawBytes ( final byte [ ] value , int offset , int length ) throws IOException { if ( limit - position >= length ) { // We have room in the current buffer. System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { // Write extends past current buffer.  Fill the rest of this buffer and // flush. final int bytesWritten = limit - position ; System . arraycopy ( value , offset , buffer , position , bytesWritten ) ; offset += bytesWritten ; length -= bytesWritten ; position = limit ; refreshBuffer ( ) ; // Now deal with the rest. // Since we have an output stream, this is our buffer // and buffer offset == 0 if ( length <= limit ) { // Fits in new buffer. System . arraycopy ( value , offset , buffer , 0 , length ) ; position = length ; } else { // Write is very big.  Let's do it all at once. output . write ( value , offset , length ) ; } } }", "private ByteBuffer _read ( long offset , long length , ByteBuffer buffer ) throws IOException { if ( offset + length > this . length ) { throw new IllegalArgumentException ( \"Piece#\" + this . index + \" overrun (\" + offset + \" + \" + length + \" > \" + this . length + \") !\" ) ; } // TODO: remove cast to int when large ByteBuffer support is // implemented in Java. int position = buffer . position ( ) ; byte [ ] bytes = this . pieceStorage . readPiecePart ( this . index , ( int ) offset , ( int ) length ) ; buffer . put ( bytes ) ; buffer . rewind ( ) ; buffer . limit ( bytes . length + position ) ; return buffer ; }", "private List < FileOffset > select ( long offset , long length ) { if ( offset + length > this . size ) { throw new IllegalArgumentException ( \"Buffer overrun (\" + offset + \" + \" + length + \" > \" + this . size + \") !\" ) ; } List < FileOffset > selected = new LinkedList < FileOffset > ( ) ; long bytes = 0 ; for ( FileStorage file : this . files ) { if ( file . offset ( ) >= offset + length ) { break ; } if ( file . offset ( ) + file . size ( ) < offset ) { continue ; } long position = offset - file . offset ( ) ; position = position > 0 ? position : 0 ; long size = Math . min ( file . size ( ) - position , length - bytes ) ; selected . add ( new FileOffset ( file , position , size ) ) ; bytes += size ; } if ( selected . size ( ) == 0 || bytes < length ) { throw new IllegalStateException ( \"Buffer underrun (only got \" + bytes + \" out of \" + length + \" byte(s) requested)!\" ) ; } return selected ; }"], "similar_code_tokens": [["public", "long", "seekToNextRecord", "(", "LogRecordSerializer", "formatter", ")", "throws", "IOException", "{", "long", "fileSize", "=", "reader", ".", "length", "(", ")", ";", "long", "position", "=", "reader", ".", "getFilePointer", "(", ")", ";", "int", "location", ";", "int", "len", "=", "0", ";", "int", "offset", "=", "0", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "2048", "]", ";", "do", "{", "if", "(", "offset", ">", "0", ")", "{", "position", "+=", "len", "-", "offset", ";", "// keep the last eyeCatcherSize-1 bytes of the buffer.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "offset", ";", "i", "++", ")", "{", "buffer", "[", "i", "]", "=", "buffer", "[", "buffer", ".", "length", "-", "offset", "+", "i", "]", ";", "}", "}", "if", "(", "position", "+", "formatter", ".", "getEyeCatcherSize", "(", ")", ">", "fileSize", ")", "{", "throw", "new", "IOException", "(", "\"No eyeCatcher found in the rest of the file.\"", ")", ";", "}", "if", "(", "position", "+", "buffer", ".", "length", "<=", "fileSize", ")", "{", "len", "=", "buffer", ".", "length", ";", "}", "else", "{", "len", "=", "(", "int", ")", "(", "fileSize", "-", "position", ")", ";", "}", "reader", ".", "readFully", "(", "buffer", ",", "offset", ",", "len", "-", "offset", ")", ";", "if", "(", "offset", "==", "0", ")", "{", "offset", "=", "formatter", ".", "getEyeCatcherSize", "(", ")", "-", "1", ";", "}", "}", "while", "(", "(", "location", "=", "formatter", ".", "findFirstEyeCatcher", "(", "buffer", ",", "0", ",", "len", ")", ")", "<", "0", ")", ";", "position", "+=", "location", "-", "4", ";", "reader", ".", "seek", "(", "position", ")", ";", "return", "position", ";", "}"], ["public", "long", "seekToPrevRecord", "(", "LogRecordSerializer", "formatter", ")", "throws", "IOException", "{", "long", "position", "=", "reader", ".", "getFilePointer", "(", ")", ";", "byte", "[", "]", "buffer", "=", "new", "byte", "[", "2048", "]", ";", "int", "location", ";", "int", "offset", "=", "0", ";", "int", "len", "=", "0", ";", "do", "{", "if", "(", "position", "<=", "formatter", ".", "getEyeCatcherSize", "(", ")", "+", "3", ")", "{", "throw", "new", "IOException", "(", "\"No eyeCatcher found in the rest of the file.\"", ")", ";", "}", "if", "(", "position", ">", "buffer", ".", "length", ")", "{", "len", "=", "buffer", ".", "length", ";", "}", "else", "{", "len", "=", "(", "int", ")", "position", ";", "}", "position", "-=", "len", ";", "if", "(", "offset", ">", "0", ")", "{", "// keep the first eyeCatcherSize-1 bytes of the buffer.", "for", "(", "int", "i", "=", "0", ";", "i", "<", "offset", ";", "i", "++", ")", "{", "buffer", "[", "len", "-", "offset", "+", "i", "]", "=", "buffer", "[", "i", "]", ";", "}", "}", "reader", ".", "seek", "(", "position", ")", ";", "reader", ".", "readFully", "(", "buffer", ",", "0", ",", "len", "-", "offset", ")", ";", "if", "(", "offset", "==", "0", ")", "{", "offset", "=", "formatter", ".", "getEyeCatcherSize", "(", ")", "-", "1", ";", "}", "}", "while", "(", "(", "location", "=", "formatter", ".", "findLastEyeCatcher", "(", "buffer", ",", "0", ",", "len", ")", ")", "<", "0", ")", ";", "position", "+=", "location", "-", "4", ";", "reader", ".", "seek", "(", "position", ")", ";", "return", "position", ";", "}"], ["public", "void", "writeRawBytes", "(", "final", "byte", "[", "]", "value", ",", "int", "offset", ",", "int", "length", ")", "throws", "IOException", "{", "if", "(", "limit", "-", "position", ">=", "length", ")", "{", "// We have room in the current buffer.", "System", ".", "arraycopy", "(", "value", ",", "offset", ",", "buffer", ",", "position", ",", "length", ")", ";", "position", "+=", "length", ";", "}", "else", "{", "// Write extends past current buffer.  Fill the rest of this buffer and", "// flush.", "final", "int", "bytesWritten", "=", "limit", "-", "position", ";", "System", ".", "arraycopy", "(", "value", ",", "offset", ",", "buffer", ",", "position", ",", "bytesWritten", ")", ";", "offset", "+=", "bytesWritten", ";", "length", "-=", "bytesWritten", ";", "position", "=", "limit", ";", "refreshBuffer", "(", ")", ";", "// Now deal with the rest.", "// Since we have an output stream, this is our buffer", "// and buffer offset == 0", "if", "(", "length", "<=", "limit", ")", "{", "// Fits in new buffer.", "System", ".", "arraycopy", "(", "value", ",", "offset", ",", "buffer", ",", "0", ",", "length", ")", ";", "position", "=", "length", ";", "}", "else", "{", "// Write is very big.  Let's do it all at once.", "output", ".", "write", "(", "value", ",", "offset", ",", "length", ")", ";", "}", "}", "}"], ["private", "ByteBuffer", "_read", "(", "long", "offset", ",", "long", "length", ",", "ByteBuffer", "buffer", ")", "throws", "IOException", "{", "if", "(", "offset", "+", "length", ">", "this", ".", "length", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Piece#\"", "+", "this", ".", "index", "+", "\" overrun (\"", "+", "offset", "+", "\" + \"", "+", "length", "+", "\" > \"", "+", "this", ".", "length", "+", "\") !\"", ")", ";", "}", "// TODO: remove cast to int when large ByteBuffer support is", "// implemented in Java.", "int", "position", "=", "buffer", ".", "position", "(", ")", ";", "byte", "[", "]", "bytes", "=", "this", ".", "pieceStorage", ".", "readPiecePart", "(", "this", ".", "index", ",", "(", "int", ")", "offset", ",", "(", "int", ")", "length", ")", ";", "buffer", ".", "put", "(", "bytes", ")", ";", "buffer", ".", "rewind", "(", ")", ";", "buffer", ".", "limit", "(", "bytes", ".", "length", "+", "position", ")", ";", "return", "buffer", ";", "}"], ["private", "List", "<", "FileOffset", ">", "select", "(", "long", "offset", ",", "long", "length", ")", "{", "if", "(", "offset", "+", "length", ">", "this", ".", "size", ")", "{", "throw", "new", "IllegalArgumentException", "(", "\"Buffer overrun (\"", "+", "offset", "+", "\" + \"", "+", "length", "+", "\" > \"", "+", "this", ".", "size", "+", "\") !\"", ")", ";", "}", "List", "<", "FileOffset", ">", "selected", "=", "new", "LinkedList", "<", "FileOffset", ">", "(", ")", ";", "long", "bytes", "=", "0", ";", "for", "(", "FileStorage", "file", ":", "this", ".", "files", ")", "{", "if", "(", "file", ".", "offset", "(", ")", ">=", "offset", "+", "length", ")", "{", "break", ";", "}", "if", "(", "file", ".", "offset", "(", ")", "+", "file", ".", "size", "(", ")", "<", "offset", ")", "{", "continue", ";", "}", "long", "position", "=", "offset", "-", "file", ".", "offset", "(", ")", ";", "position", "=", "position", ">", "0", "?", "position", ":", "0", ";", "long", "size", "=", "Math", ".", "min", "(", "file", ".", "size", "(", ")", "-", "position", ",", "length", "-", "bytes", ")", ";", "selected", ".", "add", "(", "new", "FileOffset", "(", "file", ",", "position", ",", "size", ")", ")", ";", "bytes", "+=", "size", ";", "}", "if", "(", "selected", ".", "size", "(", ")", "==", "0", "||", "bytes", "<", "length", ")", "{", "throw", "new", "IllegalStateException", "(", "\"Buffer underrun (only got \"", "+", "bytes", "+", "\" out of \"", "+", "length", "+", "\" byte(s) requested)!\"", ")", ";", "}", "return", "selected", ";", "}"]], "similar_docstring": ["Repositions reader to the location of the next record . This is done by searching next eyeCatcher and then seek 4 bytes before its start .", "Repositions reader to the location of the previous record . This is done by searching prev eyeCatcher and then seek 4 bytes before its start .", "Write part of an array of bytes .", "Internal piece data read function .", "Select the group of files impacted by an operation ."], "similar_docstring_tokens": []}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.J0", "original_string": "public static double J0(double x) {\r\n        double ax;\r\n\r\n        if ((ax = Math.abs(x)) < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r\n                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r\n                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r\n\r\n            return ans1 / ans2;\r\n        } else {\r\n            double z = 8.0 / ax;\r\n            double y = z * z;\r\n            double xx = ax - 0.785398164;\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    - y * 0.934935152e-7)));\r\n\r\n            return Math.sqrt(0.636619772 / ax) *\r\n                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double J0(double x) {\r\n        double ax;\r\n\r\n        if ((ax = Math.abs(x)) < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7\r\n                    + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));\r\n            double ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718\r\n                    + y * (59272.64853 + y * (267.8532712 + y * 1.0))));\r\n\r\n            return ans1 / ans2;\r\n        } else {\r\n            double z = 8.0 / ax;\r\n            double y = z * z;\r\n            double xx = ax - 0.785398164;\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    - y * 0.934935152e-7)));\r\n\r\n            return Math.sqrt(0.636619772 / ax) *\r\n                    (Math.cos(xx) * ans1 - z * Math.sin(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "J0", "(", "double", "x", ")", "{", "double", "ax", ";", "if", "(", "(", "ax", "=", "Math", ".", "abs", "(", "x", ")", ")", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "57568490574.0", "+", "y", "*", "(", "-", "13362590354.0", "+", "y", "*", "(", "651619640.7", "+", "y", "*", "(", "-", "11214424.18", "+", "y", "*", "(", "77392.33017", "+", "y", "*", "(", "-", "184.9052456", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "57568490411.0", "+", "y", "*", "(", "1029532985.0", "+", "y", "*", "(", "9494680.718", "+", "y", "*", "(", "59272.64853", "+", "y", "*", "(", "267.8532712", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "ans1", "/", "ans2", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "ax", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "ax", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "-", "y", "*", "0.934935152e-7", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "ax", ")", "*", "(", "Math", ".", "cos", "(", "xx", ")", "*", "ans1", "-", "z", "*", "Math", ".", "sin", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of order 0 .", "docstring_tokens": ["Bessel", "function", "of", "order", "0", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L66-L90", "partition": "train", "similar_code": ["public static double Y0 ( double x ) { if ( x < 8.0 ) { double y = x * x ; double ans1 = - 2957821389.0 + y * ( 7062834065.0 + y * ( - 512359803.6 + y * ( 10879881.29 + y * ( - 86327.92757 + y * 228.4622733 ) ) ) ) ; double ans2 = 40076544269.0 + y * ( 745249964.8 + y * ( 7189466.438 + y * ( 47447.26470 + y * ( 226.1030244 + y * 1.0 ) ) ) ) ; return ( ans1 / ans2 ) + 0.636619772 * J0 ( x ) * Math . log ( x ) ; } else { double z = 8.0 / x ; double y = z * z ; double xx = x - 0.785398164 ; double ans1 = 1.0 + y * ( - 0.1098628627e-2 + y * ( 0.2734510407e-4 + y * ( - 0.2073370639e-5 + y * 0.2093887211e-6 ) ) ) ; double ans2 = - 0.1562499995e-1 + y * ( 0.1430488765e-3 + y * ( - 0.6911147651e-5 + y * ( 0.7621095161e-6 + y * ( - 0.934945152e-7 ) ) ) ) ; return Math . sqrt ( 0.636619772 / x ) * ( Math . sin ( xx ) * ans1 + z * Math . cos ( xx ) * ans2 ) ; } }", "public static double Y ( double x ) { if ( x < 8.0 ) { double y = x * x ; double ans1 = x * ( - 0.4900604943e13 + y * ( 0.1275274390e13 + y * ( - 0.5153438139e11 + y * ( 0.7349264551e9 + y * ( - 0.4237922726e7 + y * 0.8511937935e4 ) ) ) ) ) ; double ans2 = 0.2499580570e14 + y * ( 0.4244419664e12 + y * ( 0.3733650367e10 + y * ( 0.2245904002e8 + y * ( 0.1020426050e6 + y * ( 0.3549632885e3 + y ) ) ) ) ) ; return ( ans1 / ans2 ) + 0.636619772 * ( J ( x ) * Math . log ( x ) - 1.0 / x ) ; } else { double z = 8.0 / x ; double y = z * z ; double xx = x - 2.356194491 ; double ans1 = 1.0 + y * ( 0.183105e-2 + y * ( - 0.3516396496e-4 + y * ( 0.2457520174e-5 + y * ( - 0.240337019e-6 ) ) ) ) ; double ans2 = 0.04687499995 + y * ( - 0.2002690873e-3 + y * ( 0.8449199096e-5 + y * ( - 0.88228987e-6 + y * 0.105787412e-6 ) ) ) ; return Math . sqrt ( 0.636619772 / x ) * ( Math . sin ( xx ) * ans1 + z * Math . cos ( xx ) * ans2 ) ; } }", "public static double I0 ( double x ) { double ans ; double ax = Math . abs ( x ) ; if ( ax < 3.75 ) { double y = x / 3.75 ; y = y * y ; ans = 1.0 + y * ( 3.5156229 + y * ( 3.0899424 + y * ( 1.2067492 + y * ( 0.2659732 + y * ( 0.360768e-1 + y * 0.45813e-2 ) ) ) ) ) ; } else { double y = 3.75 / ax ; ans = ( Math . exp ( ax ) / Math . sqrt ( ax ) ) * ( 0.39894228 + y * ( 0.1328592e-1 + y * ( 0.225319e-2 + y * ( - 0.157565e-2 + y * ( 0.916281e-2 + y * ( - 0.2057706e-1 + y * ( 0.2635537e-1 + y * ( - 0.1647633e-1 + y * 0.392377e-2 ) ) ) ) ) ) ) ) ; } return ans ; }", "public static double ComplementedIncomplete ( double a , double x ) { final double big = 4.503599627370496e15 ; final double biginv = 2.22044604925031308085e-16 ; double ans , ax , c , yc , r , t , y , z ; double pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; if ( x <= 0 || a <= 0 ) return 1.0 ; if ( x < 1.0 || x < a ) return 1.0 - Incomplete ( a , x ) ; ax = a * Math . log ( x ) - x - Log ( a ) ; if ( ax < - Constants . LogMax ) return 0.0 ; ax = Math . exp ( ax ) ; // continued fraction y = 1.0 - a ; z = x + y + 1.0 ; c = 0.0 ; pkm2 = 1.0 ; qkm2 = x ; pkm1 = x + 1.0 ; qkm1 = z * x ; ans = pkm1 / qkm1 ; do { c += 1.0 ; y += 1.0 ; z += 2.0 ; yc = y * c ; pk = pkm1 * z - pkm2 * yc ; qk = qkm1 * z - qkm2 * yc ; if ( qk != 0 ) { r = pk / qk ; t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = 1.0 ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( Math . abs ( pk ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } } while ( t > Constants . DoubleEpsilon ) ; return ans * ax ; }", "public Matrix getRotationMatrix ( double theta ) { if ( rotationAxis == null ) { // special case for pure translational axes return Matrix . identity ( 3 , 3 ) ; } double x = rotationAxis . getX ( ) ; double y = rotationAxis . getY ( ) ; double z = rotationAxis . getZ ( ) ; double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; double com = 1 - cos ; return new Matrix ( new double [ ] [ ] { { com * x * x + cos , com * x * y + sin * z , com * x * z + - sin * y } , { com * x * y - sin * z , com * y * y + cos , com * y * z + sin * x } , { com * x * z + sin * y , com * y * z - sin * x , com * z * z + cos } , } ) ; }"], "similar_code_tokens": [["public", "static", "double", "Y0", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "-", "2957821389.0", "+", "y", "*", "(", "7062834065.0", "+", "y", "*", "(", "-", "512359803.6", "+", "y", "*", "(", "10879881.29", "+", "y", "*", "(", "-", "86327.92757", "+", "y", "*", "228.4622733", ")", ")", ")", ")", ";", "double", "ans2", "=", "40076544269.0", "+", "y", "*", "(", "745249964.8", "+", "y", "*", "(", "7189466.438", "+", "y", "*", "(", "47447.26470", "+", "y", "*", "(", "226.1030244", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "J0", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "+", "y", "*", "(", "-", "0.934945152e-7", ")", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "static", "double", "Y", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "x", "*", "(", "-", "0.4900604943e13", "+", "y", "*", "(", "0.1275274390e13", "+", "y", "*", "(", "-", "0.5153438139e11", "+", "y", "*", "(", "0.7349264551e9", "+", "y", "*", "(", "-", "0.4237922726e7", "+", "y", "*", "0.8511937935e4", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.2499580570e14", "+", "y", "*", "(", "0.4244419664e12", "+", "y", "*", "(", "0.3733650367e10", "+", "y", "*", "(", "0.2245904002e8", "+", "y", "*", "(", "0.1020426050e6", "+", "y", "*", "(", "0.3549632885e3", "+", "y", ")", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "(", "J", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", "-", "1.0", "/", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "2.356194491", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "0.183105e-2", "+", "y", "*", "(", "-", "0.3516396496e-4", "+", "y", "*", "(", "0.2457520174e-5", "+", "y", "*", "(", "-", "0.240337019e-6", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.04687499995", "+", "y", "*", "(", "-", "0.2002690873e-3", "+", "y", "*", "(", "0.8449199096e-5", "+", "y", "*", "(", "-", "0.88228987e-6", "+", "y", "*", "0.105787412e-6", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "static", "double", "I0", "(", "double", "x", ")", "{", "double", "ans", ";", "double", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "<", "3.75", ")", "{", "double", "y", "=", "x", "/", "3.75", ";", "y", "=", "y", "*", "y", ";", "ans", "=", "1.0", "+", "y", "*", "(", "3.5156229", "+", "y", "*", "(", "3.0899424", "+", "y", "*", "(", "1.2067492", "+", "y", "*", "(", "0.2659732", "+", "y", "*", "(", "0.360768e-1", "+", "y", "*", "0.45813e-2", ")", ")", ")", ")", ")", ";", "}", "else", "{", "double", "y", "=", "3.75", "/", "ax", ";", "ans", "=", "(", "Math", ".", "exp", "(", "ax", ")", "/", "Math", ".", "sqrt", "(", "ax", ")", ")", "*", "(", "0.39894228", "+", "y", "*", "(", "0.1328592e-1", "+", "y", "*", "(", "0.225319e-2", "+", "y", "*", "(", "-", "0.157565e-2", "+", "y", "*", "(", "0.916281e-2", "+", "y", "*", "(", "-", "0.2057706e-1", "+", "y", "*", "(", "0.2635537e-1", "+", "y", "*", "(", "-", "0.1647633e-1", "+", "y", "*", "0.392377e-2", ")", ")", ")", ")", ")", ")", ")", ")", ";", "}", "return", "ans", ";", "}"], ["public", "static", "double", "ComplementedIncomplete", "(", "double", "a", ",", "double", "x", ")", "{", "final", "double", "big", "=", "4.503599627370496e15", ";", "final", "double", "biginv", "=", "2.22044604925031308085e-16", ";", "double", "ans", ",", "ax", ",", "c", ",", "yc", ",", "r", ",", "t", ",", "y", ",", "z", ";", "double", "pk", ",", "pkm1", ",", "pkm2", ",", "qk", ",", "qkm1", ",", "qkm2", ";", "if", "(", "x", "<=", "0", "||", "a", "<=", "0", ")", "return", "1.0", ";", "if", "(", "x", "<", "1.0", "||", "x", "<", "a", ")", "return", "1.0", "-", "Incomplete", "(", "a", ",", "x", ")", ";", "ax", "=", "a", "*", "Math", ".", "log", "(", "x", ")", "-", "x", "-", "Log", "(", "a", ")", ";", "if", "(", "ax", "<", "-", "Constants", ".", "LogMax", ")", "return", "0.0", ";", "ax", "=", "Math", ".", "exp", "(", "ax", ")", ";", "// continued fraction", "y", "=", "1.0", "-", "a", ";", "z", "=", "x", "+", "y", "+", "1.0", ";", "c", "=", "0.0", ";", "pkm2", "=", "1.0", ";", "qkm2", "=", "x", ";", "pkm1", "=", "x", "+", "1.0", ";", "qkm1", "=", "z", "*", "x", ";", "ans", "=", "pkm1", "/", "qkm1", ";", "do", "{", "c", "+=", "1.0", ";", "y", "+=", "1.0", ";", "z", "+=", "2.0", ";", "yc", "=", "y", "*", "c", ";", "pk", "=", "pkm1", "*", "z", "-", "pkm2", "*", "yc", ";", "qk", "=", "qkm1", "*", "z", "-", "qkm2", "*", "yc", ";", "if", "(", "qk", "!=", "0", ")", "{", "r", "=", "pk", "/", "qk", ";", "t", "=", "Math", ".", "abs", "(", "(", "ans", "-", "r", ")", "/", "r", ")", ";", "ans", "=", "r", ";", "}", "else", "t", "=", "1.0", ";", "pkm2", "=", "pkm1", ";", "pkm1", "=", "pk", ";", "qkm2", "=", "qkm1", ";", "qkm1", "=", "qk", ";", "if", "(", "Math", ".", "abs", "(", "pk", ")", ">", "big", ")", "{", "pkm2", "*=", "biginv", ";", "pkm1", "*=", "biginv", ";", "qkm2", "*=", "biginv", ";", "qkm1", "*=", "biginv", ";", "}", "}", "while", "(", "t", ">", "Constants", ".", "DoubleEpsilon", ")", ";", "return", "ans", "*", "ax", ";", "}"], ["public", "Matrix", "getRotationMatrix", "(", "double", "theta", ")", "{", "if", "(", "rotationAxis", "==", "null", ")", "{", "// special case for pure translational axes", "return", "Matrix", ".", "identity", "(", "3", ",", "3", ")", ";", "}", "double", "x", "=", "rotationAxis", ".", "getX", "(", ")", ";", "double", "y", "=", "rotationAxis", ".", "getY", "(", ")", ";", "double", "z", "=", "rotationAxis", ".", "getZ", "(", ")", ";", "double", "cos", "=", "Math", ".", "cos", "(", "theta", ")", ";", "double", "sin", "=", "Math", ".", "sin", "(", "theta", ")", ";", "double", "com", "=", "1", "-", "cos", ";", "return", "new", "Matrix", "(", "new", "double", "[", "]", "[", "]", "{", "{", "com", "*", "x", "*", "x", "+", "cos", ",", "com", "*", "x", "*", "y", "+", "sin", "*", "z", ",", "com", "*", "x", "*", "z", "+", "-", "sin", "*", "y", "}", ",", "{", "com", "*", "x", "*", "y", "-", "sin", "*", "z", ",", "com", "*", "y", "*", "y", "+", "cos", ",", "com", "*", "y", "*", "z", "+", "sin", "*", "x", "}", ",", "{", "com", "*", "x", "*", "z", "+", "sin", "*", "y", ",", "com", "*", "y", "*", "z", "-", "sin", "*", "x", ",", "com", "*", "z", "*", "z", "+", "cos", "}", ",", "}", ")", ";", "}"]], "similar_docstring": ["Bessel function of the second kind of order 0 .", "Bessel function of the second kind of order 1 .", "Bessel function of the first kind of order 0 .", "Complemented incomplete gamma function .", "Get the rotation matrix corresponding to a rotation about this axis"], "similar_docstring_tokens": []}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.J", "original_string": "public static double J(int n, double x) {\r\n        int j, m;\r\n        double ax, bj, bjm, bjp, sum, tox, ans;\r\n        boolean jsum;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        if (n == 0) return J0(x);\r\n        if (n == 1) return J(x);\r\n\r\n        ax = Math.abs(x);\r\n        if (ax == 0.0) return 0.0;\r\n        else if (ax > (double) n) {\r\n            tox = 2.0 / ax;\r\n            bjm = J0(ax);\r\n            bj = J(ax);\r\n            for (j = 1; j < n; j++) {\r\n                bjp = j * tox * bj - bjm;\r\n                bjm = bj;\r\n                bj = bjp;\r\n            }\r\n            ans = bj;\r\n        } else {\r\n            tox = 2.0 / ax;\r\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\r\n            jsum = false;\r\n            bjp = ans = sum = 0.0;\r\n            bj = 1.0;\r\n            for (j = m; j > 0; j--) {\r\n                bjm = j * tox * bj - bjp;\r\n                bjp = bj;\r\n                bj = bjm;\r\n                if (Math.abs(bj) > BIGNO) {\r\n                    bj *= BIGNI;\r\n                    bjp *= BIGNI;\r\n                    ans *= BIGNI;\r\n                    sum *= BIGNI;\r\n                }\r\n                if (jsum) sum += bj;\r\n                jsum = !jsum;\r\n                if (j == n) ans = bjp;\r\n            }\r\n            sum = 2.0 * sum - bj;\r\n            ans /= sum;\r\n        }\r\n\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "language": "java", "code": "public static double J(int n, double x) {\r\n        int j, m;\r\n        double ax, bj, bjm, bjp, sum, tox, ans;\r\n        boolean jsum;\r\n\r\n        double ACC = 40.0;\r\n        double BIGNO = 1.0e+10;\r\n        double BIGNI = 1.0e-10;\r\n\r\n        if (n == 0) return J0(x);\r\n        if (n == 1) return J(x);\r\n\r\n        ax = Math.abs(x);\r\n        if (ax == 0.0) return 0.0;\r\n        else if (ax > (double) n) {\r\n            tox = 2.0 / ax;\r\n            bjm = J0(ax);\r\n            bj = J(ax);\r\n            for (j = 1; j < n; j++) {\r\n                bjp = j * tox * bj - bjm;\r\n                bjm = bj;\r\n                bj = bjp;\r\n            }\r\n            ans = bj;\r\n        } else {\r\n            tox = 2.0 / ax;\r\n            m = 2 * ((n + (int) Math.sqrt(ACC * n)) / 2);\r\n            jsum = false;\r\n            bjp = ans = sum = 0.0;\r\n            bj = 1.0;\r\n            for (j = m; j > 0; j--) {\r\n                bjm = j * tox * bj - bjp;\r\n                bjp = bj;\r\n                bj = bjm;\r\n                if (Math.abs(bj) > BIGNO) {\r\n                    bj *= BIGNI;\r\n                    bjp *= BIGNI;\r\n                    ans *= BIGNI;\r\n                    sum *= BIGNI;\r\n                }\r\n                if (jsum) sum += bj;\r\n                jsum = !jsum;\r\n                if (j == n) ans = bjp;\r\n            }\r\n            sum = 2.0 * sum - bj;\r\n            ans /= sum;\r\n        }\r\n\r\n        return x < 0.0 && n % 2 == 1 ? -ans : ans;\r\n    }", "code_tokens": ["public", "static", "double", "J", "(", "int", "n", ",", "double", "x", ")", "{", "int", "j", ",", "m", ";", "double", "ax", ",", "bj", ",", "bjm", ",", "bjp", ",", "sum", ",", "tox", ",", "ans", ";", "boolean", "jsum", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "if", "(", "n", "==", "0", ")", "return", "J0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "J", "(", "x", ")", ";", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "==", "0.0", ")", "return", "0.0", ";", "else", "if", "(", "ax", ">", "(", "double", ")", "n", ")", "{", "tox", "=", "2.0", "/", "ax", ";", "bjm", "=", "J0", "(", "ax", ")", ";", "bj", "=", "J", "(", "ax", ")", ";", "for", "(", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "bjp", "=", "j", "*", "tox", "*", "bj", "-", "bjm", ";", "bjm", "=", "bj", ";", "bj", "=", "bjp", ";", "}", "ans", "=", "bj", ";", "}", "else", "{", "tox", "=", "2.0", "/", "ax", ";", "m", "=", "2", "*", "(", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", "/", "2", ")", ";", "jsum", "=", "false", ";", "bjp", "=", "ans", "=", "sum", "=", "0.0", ";", "bj", "=", "1.0", ";", "for", "(", "j", "=", "m", ";", "j", ">", "0", ";", "j", "--", ")", "{", "bjm", "=", "j", "*", "tox", "*", "bj", "-", "bjp", ";", "bjp", "=", "bj", ";", "bj", "=", "bjm", ";", "if", "(", "Math", ".", "abs", "(", "bj", ")", ">", "BIGNO", ")", "{", "bj", "*=", "BIGNI", ";", "bjp", "*=", "BIGNI", ";", "ans", "*=", "BIGNI", ";", "sum", "*=", "BIGNI", ";", "}", "if", "(", "jsum", ")", "sum", "+=", "bj", ";", "jsum", "=", "!", "jsum", ";", "if", "(", "j", "==", "n", ")", "ans", "=", "bjp", ";", "}", "sum", "=", "2.0", "*", "sum", "-", "bj", ";", "ans", "/=", "sum", ";", "}", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], "docstring": "Bessel function of order n .", "docstring_tokens": ["Bessel", "function", "of", "order", "n", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L134-L183", "partition": "train", "similar_code": ["public static double I ( int n , double x ) { if ( n < 0 ) throw new IllegalArgumentException ( \"the variable n out of range.\" ) ; else if ( n == 0 ) return I0 ( x ) ; else if ( n == 1 ) return I ( x ) ; if ( x == 0.0 ) return 0.0 ; double ACC = 40.0 ; double BIGNO = 1.0e+10 ; double BIGNI = 1.0e-10 ; double tox = 2.0 / Math . abs ( x ) ; double bip = 0 , ans = 0.0 ; double bi = 1.0 ; for ( int j = 2 * ( n + ( int ) Math . sqrt ( ACC * n ) ) ; j > 0 ; j -- ) { double bim = bip + j * tox * bi ; bip = bi ; bi = bim ; if ( Math . abs ( bi ) > BIGNO ) { ans *= BIGNI ; bi *= BIGNI ; bip *= BIGNI ; } if ( j == n ) ans = bip ; } ans *= I0 ( x ) / bi ; return x < 0.0 && n % 2 == 1 ? - ans : ans ; }", "public static double Incomplete ( double a , double x ) { double ans , ax , c , r ; if ( x <= 0 || a <= 0 ) return 0.0 ; if ( x > 1.0 && x > a ) return 1.0 - ComplementedIncomplete ( a , x ) ; ax = a * Math . log ( x ) - x - Log ( a ) ; if ( ax < - Constants . LogMax ) return ( 0.0 ) ; ax = Math . exp ( ax ) ; r = a ; c = 1.0 ; ans = 1.0 ; do { r += 1.0 ; c *= x / r ; ans += c ; } while ( c / ans > Constants . DoubleEpsilon ) ; return ( ans * ax / a ) ; }", "public static double Y ( int n , double x ) { double by , bym , byp , tox ; if ( n == 0 ) return Y0 ( x ) ; if ( n == 1 ) return Y ( x ) ; tox = 2.0 / x ; by = Y ( x ) ; bym = Y0 ( x ) ; for ( int j = 1 ; j < n ; j ++ ) { byp = j * tox * by - bym ; bym = by ; by = byp ; } return by ; }", "public static double ComplementedIncomplete ( double a , double x ) { final double big = 4.503599627370496e15 ; final double biginv = 2.22044604925031308085e-16 ; double ans , ax , c , yc , r , t , y , z ; double pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; if ( x <= 0 || a <= 0 ) return 1.0 ; if ( x < 1.0 || x < a ) return 1.0 - Incomplete ( a , x ) ; ax = a * Math . log ( x ) - x - Log ( a ) ; if ( ax < - Constants . LogMax ) return 0.0 ; ax = Math . exp ( ax ) ; // continued fraction y = 1.0 - a ; z = x + y + 1.0 ; c = 0.0 ; pkm2 = 1.0 ; qkm2 = x ; pkm1 = x + 1.0 ; qkm1 = z * x ; ans = pkm1 / qkm1 ; do { c += 1.0 ; y += 1.0 ; z += 2.0 ; yc = y * c ; pk = pkm1 * z - pkm2 * yc ; qk = qkm1 * z - qkm2 * yc ; if ( qk != 0 ) { r = pk / qk ; t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = 1.0 ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( Math . abs ( pk ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } } while ( t > Constants . DoubleEpsilon ) ; return ans * ax ; }", "public static double I0 ( double x ) { double ans ; double ax = Math . abs ( x ) ; if ( ax < 3.75 ) { double y = x / 3.75 ; y = y * y ; ans = 1.0 + y * ( 3.5156229 + y * ( 3.0899424 + y * ( 1.2067492 + y * ( 0.2659732 + y * ( 0.360768e-1 + y * 0.45813e-2 ) ) ) ) ) ; } else { double y = 3.75 / ax ; ans = ( Math . exp ( ax ) / Math . sqrt ( ax ) ) * ( 0.39894228 + y * ( 0.1328592e-1 + y * ( 0.225319e-2 + y * ( - 0.157565e-2 + y * ( 0.916281e-2 + y * ( - 0.2057706e-1 + y * ( 0.2635537e-1 + y * ( - 0.1647633e-1 + y * 0.392377e-2 ) ) ) ) ) ) ) ) ; } return ans ; }"], "similar_code_tokens": [["public", "static", "double", "I", "(", "int", "n", ",", "double", "x", ")", "{", "if", "(", "n", "<", "0", ")", "throw", "new", "IllegalArgumentException", "(", "\"the variable n out of range.\"", ")", ";", "else", "if", "(", "n", "==", "0", ")", "return", "I0", "(", "x", ")", ";", "else", "if", "(", "n", "==", "1", ")", "return", "I", "(", "x", ")", ";", "if", "(", "x", "==", "0.0", ")", "return", "0.0", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "double", "tox", "=", "2.0", "/", "Math", ".", "abs", "(", "x", ")", ";", "double", "bip", "=", "0", ",", "ans", "=", "0.0", ";", "double", "bi", "=", "1.0", ";", "for", "(", "int", "j", "=", "2", "*", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", ";", "j", ">", "0", ";", "j", "--", ")", "{", "double", "bim", "=", "bip", "+", "j", "*", "tox", "*", "bi", ";", "bip", "=", "bi", ";", "bi", "=", "bim", ";", "if", "(", "Math", ".", "abs", "(", "bi", ")", ">", "BIGNO", ")", "{", "ans", "*=", "BIGNI", ";", "bi", "*=", "BIGNI", ";", "bip", "*=", "BIGNI", ";", "}", "if", "(", "j", "==", "n", ")", "ans", "=", "bip", ";", "}", "ans", "*=", "I0", "(", "x", ")", "/", "bi", ";", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], ["public", "static", "double", "Incomplete", "(", "double", "a", ",", "double", "x", ")", "{", "double", "ans", ",", "ax", ",", "c", ",", "r", ";", "if", "(", "x", "<=", "0", "||", "a", "<=", "0", ")", "return", "0.0", ";", "if", "(", "x", ">", "1.0", "&&", "x", ">", "a", ")", "return", "1.0", "-", "ComplementedIncomplete", "(", "a", ",", "x", ")", ";", "ax", "=", "a", "*", "Math", ".", "log", "(", "x", ")", "-", "x", "-", "Log", "(", "a", ")", ";", "if", "(", "ax", "<", "-", "Constants", ".", "LogMax", ")", "return", "(", "0.0", ")", ";", "ax", "=", "Math", ".", "exp", "(", "ax", ")", ";", "r", "=", "a", ";", "c", "=", "1.0", ";", "ans", "=", "1.0", ";", "do", "{", "r", "+=", "1.0", ";", "c", "*=", "x", "/", "r", ";", "ans", "+=", "c", ";", "}", "while", "(", "c", "/", "ans", ">", "Constants", ".", "DoubleEpsilon", ")", ";", "return", "(", "ans", "*", "ax", "/", "a", ")", ";", "}"], ["public", "static", "double", "Y", "(", "int", "n", ",", "double", "x", ")", "{", "double", "by", ",", "bym", ",", "byp", ",", "tox", ";", "if", "(", "n", "==", "0", ")", "return", "Y0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "Y", "(", "x", ")", ";", "tox", "=", "2.0", "/", "x", ";", "by", "=", "Y", "(", "x", ")", ";", "bym", "=", "Y0", "(", "x", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "byp", "=", "j", "*", "tox", "*", "by", "-", "bym", ";", "bym", "=", "by", ";", "by", "=", "byp", ";", "}", "return", "by", ";", "}"], ["public", "static", "double", "ComplementedIncomplete", "(", "double", "a", ",", "double", "x", ")", "{", "final", "double", "big", "=", "4.503599627370496e15", ";", "final", "double", "biginv", "=", "2.22044604925031308085e-16", ";", "double", "ans", ",", "ax", ",", "c", ",", "yc", ",", "r", ",", "t", ",", "y", ",", "z", ";", "double", "pk", ",", "pkm1", ",", "pkm2", ",", "qk", ",", "qkm1", ",", "qkm2", ";", "if", "(", "x", "<=", "0", "||", "a", "<=", "0", ")", "return", "1.0", ";", "if", "(", "x", "<", "1.0", "||", "x", "<", "a", ")", "return", "1.0", "-", "Incomplete", "(", "a", ",", "x", ")", ";", "ax", "=", "a", "*", "Math", ".", "log", "(", "x", ")", "-", "x", "-", "Log", "(", "a", ")", ";", "if", "(", "ax", "<", "-", "Constants", ".", "LogMax", ")", "return", "0.0", ";", "ax", "=", "Math", ".", "exp", "(", "ax", ")", ";", "// continued fraction", "y", "=", "1.0", "-", "a", ";", "z", "=", "x", "+", "y", "+", "1.0", ";", "c", "=", "0.0", ";", "pkm2", "=", "1.0", ";", "qkm2", "=", "x", ";", "pkm1", "=", "x", "+", "1.0", ";", "qkm1", "=", "z", "*", "x", ";", "ans", "=", "pkm1", "/", "qkm1", ";", "do", "{", "c", "+=", "1.0", ";", "y", "+=", "1.0", ";", "z", "+=", "2.0", ";", "yc", "=", "y", "*", "c", ";", "pk", "=", "pkm1", "*", "z", "-", "pkm2", "*", "yc", ";", "qk", "=", "qkm1", "*", "z", "-", "qkm2", "*", "yc", ";", "if", "(", "qk", "!=", "0", ")", "{", "r", "=", "pk", "/", "qk", ";", "t", "=", "Math", ".", "abs", "(", "(", "ans", "-", "r", ")", "/", "r", ")", ";", "ans", "=", "r", ";", "}", "else", "t", "=", "1.0", ";", "pkm2", "=", "pkm1", ";", "pkm1", "=", "pk", ";", "qkm2", "=", "qkm1", ";", "qkm1", "=", "qk", ";", "if", "(", "Math", ".", "abs", "(", "pk", ")", ">", "big", ")", "{", "pkm2", "*=", "biginv", ";", "pkm1", "*=", "biginv", ";", "qkm2", "*=", "biginv", ";", "qkm1", "*=", "biginv", ";", "}", "}", "while", "(", "t", ">", "Constants", ".", "DoubleEpsilon", ")", ";", "return", "ans", "*", "ax", ";", "}"], ["public", "static", "double", "I0", "(", "double", "x", ")", "{", "double", "ans", ";", "double", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "<", "3.75", ")", "{", "double", "y", "=", "x", "/", "3.75", ";", "y", "=", "y", "*", "y", ";", "ans", "=", "1.0", "+", "y", "*", "(", "3.5156229", "+", "y", "*", "(", "3.0899424", "+", "y", "*", "(", "1.2067492", "+", "y", "*", "(", "0.2659732", "+", "y", "*", "(", "0.360768e-1", "+", "y", "*", "0.45813e-2", ")", ")", ")", ")", ")", ";", "}", "else", "{", "double", "y", "=", "3.75", "/", "ax", ";", "ans", "=", "(", "Math", ".", "exp", "(", "ax", ")", "/", "Math", ".", "sqrt", "(", "ax", ")", ")", "*", "(", "0.39894228", "+", "y", "*", "(", "0.1328592e-1", "+", "y", "*", "(", "0.225319e-2", "+", "y", "*", "(", "-", "0.157565e-2", "+", "y", "*", "(", "0.916281e-2", "+", "y", "*", "(", "-", "0.2057706e-1", "+", "y", "*", "(", "0.2635537e-1", "+", "y", "*", "(", "-", "0.1647633e-1", "+", "y", "*", "0.392377e-2", ")", ")", ")", ")", ")", ")", ")", ")", ";", "}", "return", "ans", ";", "}"]], "similar_docstring": ["Bessel function of the first kind of order n .", "Incomplete gamma function .", "Bessel function of the second kind of order n .", "Complemented incomplete gamma function .", "Bessel function of the first kind of order 0 ."], "similar_docstring_tokens": []}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y0", "original_string": "public static double Y0(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n\r\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\r\n                    + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\r\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\r\n                    + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\r\n\r\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 0.785398164;\r\n\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    + y * (-0.934945152e-7))));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double Y0(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n\r\n            double ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6\r\n                    + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));\r\n            double ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438\r\n                    + y * (47447.26470 + y * (226.1030244 + y * 1.0))));\r\n\r\n            return (ans1 / ans2) + 0.636619772 * J0(x) * Math.log(x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 0.785398164;\r\n\r\n            double ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4\r\n                    + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));\r\n            double ans2 = -0.1562499995e-1 + y * (0.1430488765e-3\r\n                    + y * (-0.6911147651e-5 + y * (0.7621095161e-6\r\n                    + y * (-0.934945152e-7))));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Y0", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "-", "2957821389.0", "+", "y", "*", "(", "7062834065.0", "+", "y", "*", "(", "-", "512359803.6", "+", "y", "*", "(", "10879881.29", "+", "y", "*", "(", "-", "86327.92757", "+", "y", "*", "228.4622733", ")", ")", ")", ")", ";", "double", "ans2", "=", "40076544269.0", "+", "y", "*", "(", "745249964.8", "+", "y", "*", "(", "7189466.438", "+", "y", "*", "(", "47447.26470", "+", "y", "*", "(", "226.1030244", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "J0", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "+", "y", "*", "(", "-", "0.934945152e-7", ")", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of the second kind of order 0 .", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "0", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L191-L214", "partition": "train", "similar_code": ["public static double J0 ( double x ) { double ax ; if ( ( ax = Math . abs ( x ) ) < 8.0 ) { double y = x * x ; double ans1 = 57568490574.0 + y * ( - 13362590354.0 + y * ( 651619640.7 + y * ( - 11214424.18 + y * ( 77392.33017 + y * ( - 184.9052456 ) ) ) ) ) ; double ans2 = 57568490411.0 + y * ( 1029532985.0 + y * ( 9494680.718 + y * ( 59272.64853 + y * ( 267.8532712 + y * 1.0 ) ) ) ) ; return ans1 / ans2 ; } else { double z = 8.0 / ax ; double y = z * z ; double xx = ax - 0.785398164 ; double ans1 = 1.0 + y * ( - 0.1098628627e-2 + y * ( 0.2734510407e-4 + y * ( - 0.2073370639e-5 + y * 0.2093887211e-6 ) ) ) ; double ans2 = - 0.1562499995e-1 + y * ( 0.1430488765e-3 + y * ( - 0.6911147651e-5 + y * ( 0.7621095161e-6 - y * 0.934935152e-7 ) ) ) ; return Math . sqrt ( 0.636619772 / ax ) * ( Math . cos ( xx ) * ans1 - z * Math . sin ( xx ) * ans2 ) ; } }", "public static double Y ( double x ) { if ( x < 8.0 ) { double y = x * x ; double ans1 = x * ( - 0.4900604943e13 + y * ( 0.1275274390e13 + y * ( - 0.5153438139e11 + y * ( 0.7349264551e9 + y * ( - 0.4237922726e7 + y * 0.8511937935e4 ) ) ) ) ) ; double ans2 = 0.2499580570e14 + y * ( 0.4244419664e12 + y * ( 0.3733650367e10 + y * ( 0.2245904002e8 + y * ( 0.1020426050e6 + y * ( 0.3549632885e3 + y ) ) ) ) ) ; return ( ans1 / ans2 ) + 0.636619772 * ( J ( x ) * Math . log ( x ) - 1.0 / x ) ; } else { double z = 8.0 / x ; double y = z * z ; double xx = x - 2.356194491 ; double ans1 = 1.0 + y * ( 0.183105e-2 + y * ( - 0.3516396496e-4 + y * ( 0.2457520174e-5 + y * ( - 0.240337019e-6 ) ) ) ) ; double ans2 = 0.04687499995 + y * ( - 0.2002690873e-3 + y * ( 0.8449199096e-5 + y * ( - 0.88228987e-6 + y * 0.105787412e-6 ) ) ) ; return Math . sqrt ( 0.636619772 / x ) * ( Math . sin ( xx ) * ans1 + z * Math . cos ( xx ) * ans2 ) ; } }", "public Matrix getRotationMatrix ( double theta ) { if ( rotationAxis == null ) { // special case for pure translational axes return Matrix . identity ( 3 , 3 ) ; } double x = rotationAxis . getX ( ) ; double y = rotationAxis . getY ( ) ; double z = rotationAxis . getZ ( ) ; double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; double com = 1 - cos ; return new Matrix ( new double [ ] [ ] { { com * x * x + cos , com * x * y + sin * z , com * x * z + - sin * y } , { com * x * y - sin * z , com * y * y + cos , com * y * z + sin * x } , { com * x * z + sin * y , com * y * z - sin * x , com * z * z + cos } , } ) ; }", "public static double norm_vec ( double x , double y , double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }", "private double score ( Se3_F64 se ) { //\t\tRodrigues_F64 rod = new Rodrigues_F64(); //\t\tConvertRotation3D_F64.matrixToRodrigues(se.R,rod); double x = Math . abs ( se . T . x ) ; double y = Math . abs ( se . T . y ) ; double z = Math . abs ( se . T . z ) + 1e-8 ; double r = Math . max ( x / ( y + z ) , y / ( x + z ) ) ; //\t\tSystem.out.println(se.T+\"  angle=\"+rod.theta); //\t\treturn (Math.abs(rod.theta)+1e-3)/r; return 1.0 / r ; // ignoring rotation seems to work better <shrug> }"], "similar_code_tokens": [["public", "static", "double", "J0", "(", "double", "x", ")", "{", "double", "ax", ";", "if", "(", "(", "ax", "=", "Math", ".", "abs", "(", "x", ")", ")", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "57568490574.0", "+", "y", "*", "(", "-", "13362590354.0", "+", "y", "*", "(", "651619640.7", "+", "y", "*", "(", "-", "11214424.18", "+", "y", "*", "(", "77392.33017", "+", "y", "*", "(", "-", "184.9052456", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "57568490411.0", "+", "y", "*", "(", "1029532985.0", "+", "y", "*", "(", "9494680.718", "+", "y", "*", "(", "59272.64853", "+", "y", "*", "(", "267.8532712", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "ans1", "/", "ans2", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "ax", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "ax", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "-", "y", "*", "0.934935152e-7", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "ax", ")", "*", "(", "Math", ".", "cos", "(", "xx", ")", "*", "ans1", "-", "z", "*", "Math", ".", "sin", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "static", "double", "Y", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "x", "*", "(", "-", "0.4900604943e13", "+", "y", "*", "(", "0.1275274390e13", "+", "y", "*", "(", "-", "0.5153438139e11", "+", "y", "*", "(", "0.7349264551e9", "+", "y", "*", "(", "-", "0.4237922726e7", "+", "y", "*", "0.8511937935e4", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.2499580570e14", "+", "y", "*", "(", "0.4244419664e12", "+", "y", "*", "(", "0.3733650367e10", "+", "y", "*", "(", "0.2245904002e8", "+", "y", "*", "(", "0.1020426050e6", "+", "y", "*", "(", "0.3549632885e3", "+", "y", ")", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "(", "J", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", "-", "1.0", "/", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "2.356194491", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "0.183105e-2", "+", "y", "*", "(", "-", "0.3516396496e-4", "+", "y", "*", "(", "0.2457520174e-5", "+", "y", "*", "(", "-", "0.240337019e-6", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.04687499995", "+", "y", "*", "(", "-", "0.2002690873e-3", "+", "y", "*", "(", "0.8449199096e-5", "+", "y", "*", "(", "-", "0.88228987e-6", "+", "y", "*", "0.105787412e-6", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "Matrix", "getRotationMatrix", "(", "double", "theta", ")", "{", "if", "(", "rotationAxis", "==", "null", ")", "{", "// special case for pure translational axes", "return", "Matrix", ".", "identity", "(", "3", ",", "3", ")", ";", "}", "double", "x", "=", "rotationAxis", ".", "getX", "(", ")", ";", "double", "y", "=", "rotationAxis", ".", "getY", "(", ")", ";", "double", "z", "=", "rotationAxis", ".", "getZ", "(", ")", ";", "double", "cos", "=", "Math", ".", "cos", "(", "theta", ")", ";", "double", "sin", "=", "Math", ".", "sin", "(", "theta", ")", ";", "double", "com", "=", "1", "-", "cos", ";", "return", "new", "Matrix", "(", "new", "double", "[", "]", "[", "]", "{", "{", "com", "*", "x", "*", "x", "+", "cos", ",", "com", "*", "x", "*", "y", "+", "sin", "*", "z", ",", "com", "*", "x", "*", "z", "+", "-", "sin", "*", "y", "}", ",", "{", "com", "*", "x", "*", "y", "-", "sin", "*", "z", ",", "com", "*", "y", "*", "y", "+", "cos", ",", "com", "*", "y", "*", "z", "+", "sin", "*", "x", "}", ",", "{", "com", "*", "x", "*", "z", "+", "sin", "*", "y", ",", "com", "*", "y", "*", "z", "-", "sin", "*", "x", ",", "com", "*", "z", "*", "z", "+", "cos", "}", ",", "}", ")", ";", "}"], ["public", "static", "double", "norm_vec", "(", "double", "x", ",", "double", "y", ",", "double", "z", ")", "{", "return", "Math", ".", "sqrt", "(", "x", "*", "x", "+", "y", "*", "y", "+", "z", "*", "z", ")", ";", "}"], ["private", "double", "score", "(", "Se3_F64", "se", ")", "{", "//\t\tRodrigues_F64 rod = new Rodrigues_F64();", "//\t\tConvertRotation3D_F64.matrixToRodrigues(se.R,rod);", "double", "x", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "x", ")", ";", "double", "y", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "y", ")", ";", "double", "z", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "z", ")", "+", "1e-8", ";", "double", "r", "=", "Math", ".", "max", "(", "x", "/", "(", "y", "+", "z", ")", ",", "y", "/", "(", "x", "+", "z", ")", ")", ";", "//\t\tSystem.out.println(se.T+\"  angle=\"+rod.theta);", "//\t\treturn (Math.abs(rod.theta)+1e-3)/r;", "return", "1.0", "/", "r", ";", "// ignoring rotation seems to work better <shrug>", "}"]], "similar_docstring": ["Bessel function of order 0 .", "Bessel function of the second kind of order 1 .", "Get the rotation matrix corresponding to a rotation about this axis", "Normalized Vector .", "Give lower scores to transforms with no rotation and translations along x or y axis ."], "similar_docstring_tokens": []}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y", "original_string": "public static double Y(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\r\n                    + y * (-0.5153438139e11 + y * (0.7349264551e9\r\n                    + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\r\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\r\n                    + y * (0.3733650367e10 + y * (0.2245904002e8\r\n                    + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\r\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 2.356194491;\r\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\r\n                    + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\r\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\r\n                    + y * (0.8449199096e-5 + y * (-0.88228987e-6\r\n                    + y * 0.105787412e-6)));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "language": "java", "code": "public static double Y(double x) {\r\n        if (x < 8.0) {\r\n            double y = x * x;\r\n            double ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13\r\n                    + y * (-0.5153438139e11 + y * (0.7349264551e9\r\n                    + y * (-0.4237922726e7 + y * 0.8511937935e4)))));\r\n            double ans2 = 0.2499580570e14 + y * (0.4244419664e12\r\n                    + y * (0.3733650367e10 + y * (0.2245904002e8\r\n                    + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));\r\n            return (ans1 / ans2) + 0.636619772 * (J(x) * Math.log(x) - 1.0 / x);\r\n        } else {\r\n            double z = 8.0 / x;\r\n            double y = z * z;\r\n            double xx = x - 2.356194491;\r\n            double ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4\r\n                    + y * (0.2457520174e-5 + y * (-0.240337019e-6))));\r\n            double ans2 = 0.04687499995 + y * (-0.2002690873e-3\r\n                    + y * (0.8449199096e-5 + y * (-0.88228987e-6\r\n                    + y * 0.105787412e-6)));\r\n            return Math.sqrt(0.636619772 / x) *\r\n                    (Math.sin(xx) * ans1 + z * Math.cos(xx) * ans2);\r\n        }\r\n    }", "code_tokens": ["public", "static", "double", "Y", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "x", "*", "(", "-", "0.4900604943e13", "+", "y", "*", "(", "0.1275274390e13", "+", "y", "*", "(", "-", "0.5153438139e11", "+", "y", "*", "(", "0.7349264551e9", "+", "y", "*", "(", "-", "0.4237922726e7", "+", "y", "*", "0.8511937935e4", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.2499580570e14", "+", "y", "*", "(", "0.4244419664e12", "+", "y", "*", "(", "0.3733650367e10", "+", "y", "*", "(", "0.2245904002e8", "+", "y", "*", "(", "0.1020426050e6", "+", "y", "*", "(", "0.3549632885e3", "+", "y", ")", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "(", "J", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", "-", "1.0", "/", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "2.356194491", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "0.183105e-2", "+", "y", "*", "(", "-", "0.3516396496e-4", "+", "y", "*", "(", "0.2457520174e-5", "+", "y", "*", "(", "-", "0.240337019e-6", ")", ")", ")", ")", ";", "double", "ans2", "=", "0.04687499995", "+", "y", "*", "(", "-", "0.2002690873e-3", "+", "y", "*", "(", "0.8449199096e-5", "+", "y", "*", "(", "-", "0.88228987e-6", "+", "y", "*", "0.105787412e-6", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], "docstring": "Bessel function of the second kind of order 1 .", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "1", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L222-L244", "partition": "train", "similar_code": ["public static double Y0 ( double x ) { if ( x < 8.0 ) { double y = x * x ; double ans1 = - 2957821389.0 + y * ( 7062834065.0 + y * ( - 512359803.6 + y * ( 10879881.29 + y * ( - 86327.92757 + y * 228.4622733 ) ) ) ) ; double ans2 = 40076544269.0 + y * ( 745249964.8 + y * ( 7189466.438 + y * ( 47447.26470 + y * ( 226.1030244 + y * 1.0 ) ) ) ) ; return ( ans1 / ans2 ) + 0.636619772 * J0 ( x ) * Math . log ( x ) ; } else { double z = 8.0 / x ; double y = z * z ; double xx = x - 0.785398164 ; double ans1 = 1.0 + y * ( - 0.1098628627e-2 + y * ( 0.2734510407e-4 + y * ( - 0.2073370639e-5 + y * 0.2093887211e-6 ) ) ) ; double ans2 = - 0.1562499995e-1 + y * ( 0.1430488765e-3 + y * ( - 0.6911147651e-5 + y * ( 0.7621095161e-6 + y * ( - 0.934945152e-7 ) ) ) ) ; return Math . sqrt ( 0.636619772 / x ) * ( Math . sin ( xx ) * ans1 + z * Math . cos ( xx ) * ans2 ) ; } }", "public static double J0 ( double x ) { double ax ; if ( ( ax = Math . abs ( x ) ) < 8.0 ) { double y = x * x ; double ans1 = 57568490574.0 + y * ( - 13362590354.0 + y * ( 651619640.7 + y * ( - 11214424.18 + y * ( 77392.33017 + y * ( - 184.9052456 ) ) ) ) ) ; double ans2 = 57568490411.0 + y * ( 1029532985.0 + y * ( 9494680.718 + y * ( 59272.64853 + y * ( 267.8532712 + y * 1.0 ) ) ) ) ; return ans1 / ans2 ; } else { double z = 8.0 / ax ; double y = z * z ; double xx = ax - 0.785398164 ; double ans1 = 1.0 + y * ( - 0.1098628627e-2 + y * ( 0.2734510407e-4 + y * ( - 0.2073370639e-5 + y * 0.2093887211e-6 ) ) ) ; double ans2 = - 0.1562499995e-1 + y * ( 0.1430488765e-3 + y * ( - 0.6911147651e-5 + y * ( 0.7621095161e-6 - y * 0.934935152e-7 ) ) ) ; return Math . sqrt ( 0.636619772 / ax ) * ( Math . cos ( xx ) * ans1 - z * Math . sin ( xx ) * ans2 ) ; } }", "public Matrix getRotationMatrix ( double theta ) { if ( rotationAxis == null ) { // special case for pure translational axes return Matrix . identity ( 3 , 3 ) ; } double x = rotationAxis . getX ( ) ; double y = rotationAxis . getY ( ) ; double z = rotationAxis . getZ ( ) ; double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; double com = 1 - cos ; return new Matrix ( new double [ ] [ ] { { com * x * x + cos , com * x * y + sin * z , com * x * z + - sin * y } , { com * x * y - sin * z , com * y * y + cos , com * y * z + sin * x } , { com * x * z + sin * y , com * y * z - sin * x , com * z * z + cos } , } ) ; }", "public static double norm_vec ( double x , double y , double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }", "private double score ( Se3_F64 se ) { //\t\tRodrigues_F64 rod = new Rodrigues_F64(); //\t\tConvertRotation3D_F64.matrixToRodrigues(se.R,rod); double x = Math . abs ( se . T . x ) ; double y = Math . abs ( se . T . y ) ; double z = Math . abs ( se . T . z ) + 1e-8 ; double r = Math . max ( x / ( y + z ) , y / ( x + z ) ) ; //\t\tSystem.out.println(se.T+\"  angle=\"+rod.theta); //\t\treturn (Math.abs(rod.theta)+1e-3)/r; return 1.0 / r ; // ignoring rotation seems to work better <shrug> }"], "similar_code_tokens": [["public", "static", "double", "Y0", "(", "double", "x", ")", "{", "if", "(", "x", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "-", "2957821389.0", "+", "y", "*", "(", "7062834065.0", "+", "y", "*", "(", "-", "512359803.6", "+", "y", "*", "(", "10879881.29", "+", "y", "*", "(", "-", "86327.92757", "+", "y", "*", "228.4622733", ")", ")", ")", ")", ";", "double", "ans2", "=", "40076544269.0", "+", "y", "*", "(", "745249964.8", "+", "y", "*", "(", "7189466.438", "+", "y", "*", "(", "47447.26470", "+", "y", "*", "(", "226.1030244", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "(", "ans1", "/", "ans2", ")", "+", "0.636619772", "*", "J0", "(", "x", ")", "*", "Math", ".", "log", "(", "x", ")", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "x", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "x", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "+", "y", "*", "(", "-", "0.934945152e-7", ")", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "x", ")", "*", "(", "Math", ".", "sin", "(", "xx", ")", "*", "ans1", "+", "z", "*", "Math", ".", "cos", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "static", "double", "J0", "(", "double", "x", ")", "{", "double", "ax", ";", "if", "(", "(", "ax", "=", "Math", ".", "abs", "(", "x", ")", ")", "<", "8.0", ")", "{", "double", "y", "=", "x", "*", "x", ";", "double", "ans1", "=", "57568490574.0", "+", "y", "*", "(", "-", "13362590354.0", "+", "y", "*", "(", "651619640.7", "+", "y", "*", "(", "-", "11214424.18", "+", "y", "*", "(", "77392.33017", "+", "y", "*", "(", "-", "184.9052456", ")", ")", ")", ")", ")", ";", "double", "ans2", "=", "57568490411.0", "+", "y", "*", "(", "1029532985.0", "+", "y", "*", "(", "9494680.718", "+", "y", "*", "(", "59272.64853", "+", "y", "*", "(", "267.8532712", "+", "y", "*", "1.0", ")", ")", ")", ")", ";", "return", "ans1", "/", "ans2", ";", "}", "else", "{", "double", "z", "=", "8.0", "/", "ax", ";", "double", "y", "=", "z", "*", "z", ";", "double", "xx", "=", "ax", "-", "0.785398164", ";", "double", "ans1", "=", "1.0", "+", "y", "*", "(", "-", "0.1098628627e-2", "+", "y", "*", "(", "0.2734510407e-4", "+", "y", "*", "(", "-", "0.2073370639e-5", "+", "y", "*", "0.2093887211e-6", ")", ")", ")", ";", "double", "ans2", "=", "-", "0.1562499995e-1", "+", "y", "*", "(", "0.1430488765e-3", "+", "y", "*", "(", "-", "0.6911147651e-5", "+", "y", "*", "(", "0.7621095161e-6", "-", "y", "*", "0.934935152e-7", ")", ")", ")", ";", "return", "Math", ".", "sqrt", "(", "0.636619772", "/", "ax", ")", "*", "(", "Math", ".", "cos", "(", "xx", ")", "*", "ans1", "-", "z", "*", "Math", ".", "sin", "(", "xx", ")", "*", "ans2", ")", ";", "}", "}"], ["public", "Matrix", "getRotationMatrix", "(", "double", "theta", ")", "{", "if", "(", "rotationAxis", "==", "null", ")", "{", "// special case for pure translational axes", "return", "Matrix", ".", "identity", "(", "3", ",", "3", ")", ";", "}", "double", "x", "=", "rotationAxis", ".", "getX", "(", ")", ";", "double", "y", "=", "rotationAxis", ".", "getY", "(", ")", ";", "double", "z", "=", "rotationAxis", ".", "getZ", "(", ")", ";", "double", "cos", "=", "Math", ".", "cos", "(", "theta", ")", ";", "double", "sin", "=", "Math", ".", "sin", "(", "theta", ")", ";", "double", "com", "=", "1", "-", "cos", ";", "return", "new", "Matrix", "(", "new", "double", "[", "]", "[", "]", "{", "{", "com", "*", "x", "*", "x", "+", "cos", ",", "com", "*", "x", "*", "y", "+", "sin", "*", "z", ",", "com", "*", "x", "*", "z", "+", "-", "sin", "*", "y", "}", ",", "{", "com", "*", "x", "*", "y", "-", "sin", "*", "z", ",", "com", "*", "y", "*", "y", "+", "cos", ",", "com", "*", "y", "*", "z", "+", "sin", "*", "x", "}", ",", "{", "com", "*", "x", "*", "z", "+", "sin", "*", "y", ",", "com", "*", "y", "*", "z", "-", "sin", "*", "x", ",", "com", "*", "z", "*", "z", "+", "cos", "}", ",", "}", ")", ";", "}"], ["public", "static", "double", "norm_vec", "(", "double", "x", ",", "double", "y", ",", "double", "z", ")", "{", "return", "Math", ".", "sqrt", "(", "x", "*", "x", "+", "y", "*", "y", "+", "z", "*", "z", ")", ";", "}"], ["private", "double", "score", "(", "Se3_F64", "se", ")", "{", "//\t\tRodrigues_F64 rod = new Rodrigues_F64();", "//\t\tConvertRotation3D_F64.matrixToRodrigues(se.R,rod);", "double", "x", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "x", ")", ";", "double", "y", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "y", ")", ";", "double", "z", "=", "Math", ".", "abs", "(", "se", ".", "T", ".", "z", ")", "+", "1e-8", ";", "double", "r", "=", "Math", ".", "max", "(", "x", "/", "(", "y", "+", "z", ")", ",", "y", "/", "(", "x", "+", "z", ")", ")", ";", "//\t\tSystem.out.println(se.T+\"  angle=\"+rod.theta);", "//\t\treturn (Math.abs(rod.theta)+1e-3)/r;", "return", "1.0", "/", "r", ";", "// ignoring rotation seems to work better <shrug>", "}"]], "similar_docstring": ["Bessel function of the second kind of order 0 .", "Bessel function of order 0 .", "Get the rotation matrix corresponding to a rotation about this axis", "Normalized Vector .", "Give lower scores to transforms with no rotation and translations along x or y axis ."], "similar_docstring_tokens": []}
{"repo": "Harium/keel", "path": "src/main/java/com/harium/keel/catalano/math/function/Bessel.java", "func_name": "Bessel.Y", "original_string": "public static double Y(int n, double x) {\r\n        double by, bym, byp, tox;\r\n\r\n        if (n == 0) return Y0(x);\r\n        if (n == 1) return Y(x);\r\n\r\n        tox = 2.0 / x;\r\n        by = Y(x);\r\n        bym = Y0(x);\r\n        for (int j = 1; j < n; j++) {\r\n            byp = j * tox * by - bym;\r\n            bym = by;\r\n            by = byp;\r\n        }\r\n        return by;\r\n    }", "language": "java", "code": "public static double Y(int n, double x) {\r\n        double by, bym, byp, tox;\r\n\r\n        if (n == 0) return Y0(x);\r\n        if (n == 1) return Y(x);\r\n\r\n        tox = 2.0 / x;\r\n        by = Y(x);\r\n        bym = Y0(x);\r\n        for (int j = 1; j < n; j++) {\r\n            byp = j * tox * by - bym;\r\n            bym = by;\r\n            by = byp;\r\n        }\r\n        return by;\r\n    }", "code_tokens": ["public", "static", "double", "Y", "(", "int", "n", ",", "double", "x", ")", "{", "double", "by", ",", "bym", ",", "byp", ",", "tox", ";", "if", "(", "n", "==", "0", ")", "return", "Y0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "Y", "(", "x", ")", ";", "tox", "=", "2.0", "/", "x", ";", "by", "=", "Y", "(", "x", ")", ";", "bym", "=", "Y0", "(", "x", ")", ";", "for", "(", "int", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "byp", "=", "j", "*", "tox", "*", "by", "-", "bym", ";", "bym", "=", "by", ";", "by", "=", "byp", ";", "}", "return", "by", ";", "}"], "docstring": "Bessel function of the second kind of order n .", "docstring_tokens": ["Bessel", "function", "of", "the", "second", "kind", "of", "order", "n", "."], "sha": "0369ae674f9e664bccc5f9e161ae7e7a3b949a1e", "url": "https://github.com/Harium/keel/blob/0369ae674f9e664bccc5f9e161ae7e7a3b949a1e/src/main/java/com/harium/keel/catalano/math/function/Bessel.java#L253-L268", "partition": "train", "similar_code": ["public static double J ( int n , double x ) { int j , m ; double ax , bj , bjm , bjp , sum , tox , ans ; boolean jsum ; double ACC = 40.0 ; double BIGNO = 1.0e+10 ; double BIGNI = 1.0e-10 ; if ( n == 0 ) return J0 ( x ) ; if ( n == 1 ) return J ( x ) ; ax = Math . abs ( x ) ; if ( ax == 0.0 ) return 0.0 ; else if ( ax > ( double ) n ) { tox = 2.0 / ax ; bjm = J0 ( ax ) ; bj = J ( ax ) ; for ( j = 1 ; j < n ; j ++ ) { bjp = j * tox * bj - bjm ; bjm = bj ; bj = bjp ; } ans = bj ; } else { tox = 2.0 / ax ; m = 2 * ( ( n + ( int ) Math . sqrt ( ACC * n ) ) / 2 ) ; jsum = false ; bjp = ans = sum = 0.0 ; bj = 1.0 ; for ( j = m ; j > 0 ; j -- ) { bjm = j * tox * bj - bjp ; bjp = bj ; bj = bjm ; if ( Math . abs ( bj ) > BIGNO ) { bj *= BIGNI ; bjp *= BIGNI ; ans *= BIGNI ; sum *= BIGNI ; } if ( jsum ) sum += bj ; jsum = ! jsum ; if ( j == n ) ans = bjp ; } sum = 2.0 * sum - bj ; ans /= sum ; } return x < 0.0 && n % 2 == 1 ? - ans : ans ; }", "public static double I ( int n , double x ) { if ( n < 0 ) throw new IllegalArgumentException ( \"the variable n out of range.\" ) ; else if ( n == 0 ) return I0 ( x ) ; else if ( n == 1 ) return I ( x ) ; if ( x == 0.0 ) return 0.0 ; double ACC = 40.0 ; double BIGNO = 1.0e+10 ; double BIGNI = 1.0e-10 ; double tox = 2.0 / Math . abs ( x ) ; double bip = 0 , ans = 0.0 ; double bi = 1.0 ; for ( int j = 2 * ( n + ( int ) Math . sqrt ( ACC * n ) ) ; j > 0 ; j -- ) { double bim = bip + j * tox * bi ; bip = bi ; bi = bim ; if ( Math . abs ( bi ) > BIGNO ) { ans *= BIGNI ; bi *= BIGNI ; bip *= BIGNI ; } if ( j == n ) ans = bip ; } ans *= I0 ( x ) / bi ; return x < 0.0 && n % 2 == 1 ? - ans : ans ; }", "public static boolean cs_utsolve ( Dcs U , double [ ] x ) { int p , j , n , Up [ ] , Ui [ ] ; double Ux [ ] ; if ( ! Dcs_util . CS_CSC ( U ) || x == null ) return ( false ) ; /* check inputs */ n = U . n ; Up = U . p ; Ui = U . i ; Ux = U . x ; for ( j = 0 ; j < n ; j ++ ) { for ( p = Up [ j ] ; p < Up [ j + 1 ] - 1 ; p ++ ) { x [ j ] -= Ux [ p ] * x [ Ui [ p ] ] ; } x [ j ] /= Ux [ Up [ j + 1 ] - 1 ] ; } return ( true ) ; }", "protected double trapezoid ( int n ) { double x = 0 ; double tnm = 0 ; double sum = 0 ; double del = 0 ; int it = 0 ; int j = 0 ; if ( n == 1 ) { strapezoid = 0.5f * ( upperlimit - lowerlimit ) * ( equation ( lowerlimit ) + equation ( upperlimit ) ) ; } else { /*\n             * for (it = 1, j = 1; j < n - 1; j++) { it <<= 1; }\n             */ it = ( int ) Math . pow ( 2.0 , n - 1 ) ; tnm = ( double ) it ; del = ( upperlimit - lowerlimit ) / tnm ; x = lowerlimit + 0.5f * del ; for ( sum = 0f , j = 1 ; j <= it ; j ++ , x += del ) { if ( x >= upperlimit ) { System . out . println ( \"hoi\" ) ; } sum += equation ( x ) ; } strapezoid = ( double ) ( 0.5f * ( strapezoid + ( upperlimit - lowerlimit ) * sum / tnm ) ) ; } return strapezoid ; }", "public static boolean cs_ltsolve ( Dcs L , double [ ] x ) { int p , j , n , Lp [ ] , Li [ ] ; double Lx [ ] ; if ( ! Dcs_util . CS_CSC ( L ) || x == null ) return ( false ) ; /* check inputs */ n = L . n ; Lp = L . p ; Li = L . i ; Lx = L . x ; for ( j = n - 1 ; j >= 0 ; j -- ) { for ( p = Lp [ j ] + 1 ; p < Lp [ j + 1 ] ; p ++ ) { x [ j ] -= Lx [ p ] * x [ Li [ p ] ] ; } x [ j ] /= Lx [ Lp [ j ] ] ; } return ( true ) ; }"], "similar_code_tokens": [["public", "static", "double", "J", "(", "int", "n", ",", "double", "x", ")", "{", "int", "j", ",", "m", ";", "double", "ax", ",", "bj", ",", "bjm", ",", "bjp", ",", "sum", ",", "tox", ",", "ans", ";", "boolean", "jsum", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "if", "(", "n", "==", "0", ")", "return", "J0", "(", "x", ")", ";", "if", "(", "n", "==", "1", ")", "return", "J", "(", "x", ")", ";", "ax", "=", "Math", ".", "abs", "(", "x", ")", ";", "if", "(", "ax", "==", "0.0", ")", "return", "0.0", ";", "else", "if", "(", "ax", ">", "(", "double", ")", "n", ")", "{", "tox", "=", "2.0", "/", "ax", ";", "bjm", "=", "J0", "(", "ax", ")", ";", "bj", "=", "J", "(", "ax", ")", ";", "for", "(", "j", "=", "1", ";", "j", "<", "n", ";", "j", "++", ")", "{", "bjp", "=", "j", "*", "tox", "*", "bj", "-", "bjm", ";", "bjm", "=", "bj", ";", "bj", "=", "bjp", ";", "}", "ans", "=", "bj", ";", "}", "else", "{", "tox", "=", "2.0", "/", "ax", ";", "m", "=", "2", "*", "(", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", "/", "2", ")", ";", "jsum", "=", "false", ";", "bjp", "=", "ans", "=", "sum", "=", "0.0", ";", "bj", "=", "1.0", ";", "for", "(", "j", "=", "m", ";", "j", ">", "0", ";", "j", "--", ")", "{", "bjm", "=", "j", "*", "tox", "*", "bj", "-", "bjp", ";", "bjp", "=", "bj", ";", "bj", "=", "bjm", ";", "if", "(", "Math", ".", "abs", "(", "bj", ")", ">", "BIGNO", ")", "{", "bj", "*=", "BIGNI", ";", "bjp", "*=", "BIGNI", ";", "ans", "*=", "BIGNI", ";", "sum", "*=", "BIGNI", ";", "}", "if", "(", "jsum", ")", "sum", "+=", "bj", ";", "jsum", "=", "!", "jsum", ";", "if", "(", "j", "==", "n", ")", "ans", "=", "bjp", ";", "}", "sum", "=", "2.0", "*", "sum", "-", "bj", ";", "ans", "/=", "sum", ";", "}", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], ["public", "static", "double", "I", "(", "int", "n", ",", "double", "x", ")", "{", "if", "(", "n", "<", "0", ")", "throw", "new", "IllegalArgumentException", "(", "\"the variable n out of range.\"", ")", ";", "else", "if", "(", "n", "==", "0", ")", "return", "I0", "(", "x", ")", ";", "else", "if", "(", "n", "==", "1", ")", "return", "I", "(", "x", ")", ";", "if", "(", "x", "==", "0.0", ")", "return", "0.0", ";", "double", "ACC", "=", "40.0", ";", "double", "BIGNO", "=", "1.0e+10", ";", "double", "BIGNI", "=", "1.0e-10", ";", "double", "tox", "=", "2.0", "/", "Math", ".", "abs", "(", "x", ")", ";", "double", "bip", "=", "0", ",", "ans", "=", "0.0", ";", "double", "bi", "=", "1.0", ";", "for", "(", "int", "j", "=", "2", "*", "(", "n", "+", "(", "int", ")", "Math", ".", "sqrt", "(", "ACC", "*", "n", ")", ")", ";", "j", ">", "0", ";", "j", "--", ")", "{", "double", "bim", "=", "bip", "+", "j", "*", "tox", "*", "bi", ";", "bip", "=", "bi", ";", "bi", "=", "bim", ";", "if", "(", "Math", ".", "abs", "(", "bi", ")", ">", "BIGNO", ")", "{", "ans", "*=", "BIGNI", ";", "bi", "*=", "BIGNI", ";", "bip", "*=", "BIGNI", ";", "}", "if", "(", "j", "==", "n", ")", "ans", "=", "bip", ";", "}", "ans", "*=", "I0", "(", "x", ")", "/", "bi", ";", "return", "x", "<", "0.0", "&&", "n", "%", "2", "==", "1", "?", "-", "ans", ":", "ans", ";", "}"], ["public", "static", "boolean", "cs_utsolve", "(", "Dcs", "U", ",", "double", "[", "]", "x", ")", "{", "int", "p", ",", "j", ",", "n", ",", "Up", "[", "]", ",", "Ui", "[", "]", ";", "double", "Ux", "[", "]", ";", "if", "(", "!", "Dcs_util", ".", "CS_CSC", "(", "U", ")", "||", "x", "==", "null", ")", "return", "(", "false", ")", ";", "/* check inputs */", "n", "=", "U", ".", "n", ";", "Up", "=", "U", ".", "p", ";", "Ui", "=", "U", ".", "i", ";", "Ux", "=", "U", ".", "x", ";", "for", "(", "j", "=", "0", ";", "j", "<", "n", ";", "j", "++", ")", "{", "for", "(", "p", "=", "Up", "[", "j", "]", ";", "p", "<", "Up", "[", "j", "+", "1", "]", "-", "1", ";", "p", "++", ")", "{", "x", "[", "j", "]", "-=", "Ux", "[", "p", "]", "*", "x", "[", "Ui", "[", "p", "]", "]", ";", "}", "x", "[", "j", "]", "/=", "Ux", "[", "Up", "[", "j", "+", "1", "]", "-", "1", "]", ";", "}", "return", "(", "true", ")", ";", "}"], ["protected", "double", "trapezoid", "(", "int", "n", ")", "{", "double", "x", "=", "0", ";", "double", "tnm", "=", "0", ";", "double", "sum", "=", "0", ";", "double", "del", "=", "0", ";", "int", "it", "=", "0", ";", "int", "j", "=", "0", ";", "if", "(", "n", "==", "1", ")", "{", "strapezoid", "=", "0.5f", "*", "(", "upperlimit", "-", "lowerlimit", ")", "*", "(", "equation", "(", "lowerlimit", ")", "+", "equation", "(", "upperlimit", ")", ")", ";", "}", "else", "{", "/*\n             * for (it = 1, j = 1; j < n - 1; j++) { it <<= 1; }\n             */", "it", "=", "(", "int", ")", "Math", ".", "pow", "(", "2.0", ",", "n", "-", "1", ")", ";", "tnm", "=", "(", "double", ")", "it", ";", "del", "=", "(", "upperlimit", "-", "lowerlimit", ")", "/", "tnm", ";", "x", "=", "lowerlimit", "+", "0.5f", "*", "del", ";", "for", "(", "sum", "=", "0f", ",", "j", "=", "1", ";", "j", "<=", "it", ";", "j", "++", ",", "x", "+=", "del", ")", "{", "if", "(", "x", ">=", "upperlimit", ")", "{", "System", ".", "out", ".", "println", "(", "\"hoi\"", ")", ";", "}", "sum", "+=", "equation", "(", "x", ")", ";", "}", "strapezoid", "=", "(", "double", ")", "(", "0.5f", "*", "(", "strapezoid", "+", "(", "upperlimit", "-", "lowerlimit", ")", "*", "sum", "/", "tnm", ")", ")", ";", "}", "return", "strapezoid", ";", "}"], ["public", "static", "boolean", "cs_ltsolve", "(", "Dcs", "L", ",", "double", "[", "]", "x", ")", "{", "int", "p", ",", "j", ",", "n", ",", "Lp", "[", "]", ",", "Li", "[", "]", ";", "double", "Lx", "[", "]", ";", "if", "(", "!", "Dcs_util", ".", "CS_CSC", "(", "L", ")", "||", "x", "==", "null", ")", "return", "(", "false", ")", ";", "/* check inputs */", "n", "=", "L", ".", "n", ";", "Lp", "=", "L", ".", "p", ";", "Li", "=", "L", ".", "i", ";", "Lx", "=", "L", ".", "x", ";", "for", "(", "j", "=", "n", "-", "1", ";", "j", ">=", "0", ";", "j", "--", ")", "{", "for", "(", "p", "=", "Lp", "[", "j", "]", "+", "1", ";", "p", "<", "Lp", "[", "j", "+", "1", "]", ";", "p", "++", ")", "{", "x", "[", "j", "]", "-=", "Lx", "[", "p", "]", "*", "x", "[", "Li", "[", "p", "]", "]", ";", "}", "x", "[", "j", "]", "/=", "Lx", "[", "Lp", "[", "j", "]", "]", ";", "}", "return", "(", "true", ")", ";", "}"]], "similar_docstring": ["Bessel function of order n .", "Bessel function of the first kind of order n .", "Solves a lower triangular system U x = b where x and b are dense vectors . The diagonal of U must be the last entry of each column .", "Calculate the integral with the trapezoidal algorithm of the equation implemented in the method equation", "Solves an upper triangular system L x = b where x and b are dense . x = b on input solution on output ."], "similar_docstring_tokens": []}
